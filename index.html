<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life Notebook â†’ Web</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #94a3b8;
            --accent: #38ef7d;
            --accent-2: #667eea;
            --border: #1e293b;
            --card: #0b1220;
            --text: #e2e8f0;
            --text-strong: #fff;
            --highlight-bg: #4CAF50;
            --highlight-text: #0b1220;
            /* Canvas connection line color for dark mode */
            --connection-line-color: #ff5722;
            /* deep orange - contrasts with dark bg and yellow cells */
        }

        [data-theme="light"] {
            --bg: #f8f9ff;
            --panel: #ffffff;
            --muted: #666;
            --accent: #38ef7d;
            --accent-2: #11998e;
            --border: #eee;
            --card: #fafafa;
            --text: #333;
            --text-strong: #000;
            --highlight-bg: #4CAF50;
            --highlight-text: #fff;
            /* Canvas connection line color for light mode */
            --connection-line-color: #00cc00;
            /* keep green in light theme */
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        [data-theme="dark"] body {
            background: radial-gradient(circle at 20% 20%, rgba(56, 239, 125, 0.08), transparent 35%),
                radial-gradient(circle at 80% 10%, rgba(102, 126, 234, 0.12), transparent 40%),
                var(--bg);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }

        [data-theme="light"] header {
            background: rgba(248, 250, 252, 0.9);
        }

        .theme-toggle {
            margin-left: auto;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .topbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand span {
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border-radius: 8px;
            font-size: 12px;
            color: var(--highlight-text);
            font-weight: 900;
            cursor: pointer;
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }

        .brand span:hover {
            transform: scale(1.05);
        }

        /* Number Picker Popup and Place Boxes (copied from index.html) */
        .number-picker-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 500px;
            max-height: 800px;
            /* increased to reduce internal scrolling when mode wraps */
            overflow-y: auto;
            left: 0;
            top: 0;
            cursor: move;
            transform-origin: top left;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            opacity: 0;
        }

        .popup-scale-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            display: none;
            background: var(--accent);
            border: 1px solid var(--accent-2);
            opacity: 0.7;
        }

        .popup-scale-handle.visible {
            display: block;
        }

        .number-picker-popup * {
            cursor: default;
        }

        .number-picker-popup .popup-scale-handle {
            cursor: nwse-resize !important;
        }

        [data-theme="dark"] .number-picker-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .number-picker-popup.show {
            display: block;
            opacity: 1;
        }

        /* Highlight the selected option inside native dropdowns where supported */
        select option:checked,
        select option.highlighted {
            background: var(--highlight-bg) !important;
            color: var(--highlight-text) !important;
            font-weight: 800;
        }

        /* Inline opacity control placed next to Î£ */
        .inline-opacity-container {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        .inline-opacity-container input[type="range"] {
            width: 100px;
            max-width: 100%;
            height: 6px;
            accent-color: var(--accent);
        }

        /* Smaller slider when placed inside compact mode rows/selectors */
        .mode-rows .inline-opacity-container input[type="range"],
        .mode-selector .inline-opacity-container input[type="range"] {
            width: 72px;
        }

        .inline-opacity-container .inline-percent {
            min-width: 36px;
            font-weight: 800;
            font-size: 13px;
            color: var(--text-strong);
        }

        .number-picker-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .number-picker-table th {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: center;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table th.label-cell {
            cursor: grab;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            color: white;
        }

        .number-picker-table th.label-cell:active {
            cursor: grabbing;
        }

        .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        .number-picker-table th:nth-child(3) {
            border-right: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset -3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table th:nth-child(4) {
            border-left: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset 3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table td:active {
            cursor: grabbing;
        }

        [data-theme="light"] .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
        }

        [data-theme="light"] .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table th:nth-child(3) {
            border-right: 3px solid #11998e !important;
            box-shadow: inset -3px 0 0 0 #11998e;
        }

        [data-theme="light"] .number-picker-table th:nth-child(4) {
            border-left: 3px solid #11998e !important;
            box-shadow: inset 3px 0 0 0 #11998e;
        }

        .number-picker-table td:hover {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
            color: var(--highlight-text);
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
        }

        /* Highlighted numbers (when placed or hovered via quick-place)
           Use the same (day.html) "placed" visual: a solid/soft green fill
           rather than the gradient. This matches the place-box.filled style. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number {
            /* Use dark placed-background from day.html */
            background: #1a2a3a !important;
            /* Do not set a global text color on the cell so rank badges keep their own color.
               Color for the main number is applied to the number span below. */
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        /* Target only the main number span inside the cell; exclude rank badge spans */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number>span:not(.rank-in-cell) {
            color: #00ff00 !important;
            font-weight: 900;
        }

        #numberPickerPopup #numberPickerTable td.disabled {
            opacity: 1;
            cursor: not-allowed;
            background: #1a2a3a !important;
            pointer-events: none;
            /* avoid changing all nested text color (rank badges must keep their own color) */
            font-weight: 700 !important;
        }

        /* For disabled cells, color only the displayed number span (not the rank badge) */
        #numberPickerPopup #numberPickerTable td.disabled>span:not(.rank-in-cell) {
            color: #00ff00 !important;
        }

        /* If a disabled cell is also selected/placed, show the selected highlight instead
           (override the darker disabled styling). This ensures dragging a number into a place
           will display the same accent highlight as hover/selection and will be cleared
           by the normal highlight-sync logic. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number,
        #numberPickerPopup #numberPickerTable td.selected-number.disabled,
        #numberPickerPopup #numberPickerTable td.number-cell.disabled.selected-number {
            background: #1a2a3a !important;
            color: #00ff00 !important;
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        [data-theme="light"] #numberPickerPopup #numberPickerTable td.disabled {
            background: #e8f4f8 !important;
            color: #1a1a1a !important;
        }

        /* Apply bright label-cell style when column has values */
        .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        [data-theme="light"] .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Dim label cells that don't have values */
        .number-picker-table tfoot:not(.disabled) th.label-cell:not(.with-values) {
            opacity: 0.3 !important;
            pointer-events: none !important;
        }

        .number-picker-table tbody.disabled,
        .number-picker-table tfoot.disabled {
            pointer-events: none;
            opacity: 0.3;
            position: relative;
        }

        .number-picker-table tbody.disabled::after,
        .number-picker-table tfoot.disabled::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.03) 10px,
                    rgba(0, 0, 0, 0.03) 20px);
            pointer-events: none;
        }

        [data-theme="dark"] .number-picker-table tbody.disabled::after,
        [data-theme="dark"] .number-picker-table tfoot.disabled::after {
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px);
        }

        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 60px;
            height: 60px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: var(--accent);
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 4px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        .image-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
        }

        [data-theme="dark"] .image-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .image-popup.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        .image-popup img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            border-radius: 8px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .image-popup img {
                max-width: 200px;
                max-height: 200px;
            }
        }

        nav {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .nav-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn.active {
            border-color: var(--accent);
            color: var(--highlight-text);
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            font-weight: 800;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
        }

        section h2 {
            margin: 0 0 12px;
            color: var(--text-strong);
            letter-spacing: 0.3px;
        }

        section p.lead {
            margin: 6px 0 16px;
            color: var(--muted);
        }

        .card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .card {
            background: var(--card);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 14px;
        }

        select,
        input,
        button {
            border-radius: 10px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            font-size: 13px;
        }

        select:focus,
        input:focus {
            outline: 1px solid var(--accent);
        }

        /* Hide number input spinner arrows */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100());
            border: none;
            color: var(--highlight-text);
            font-weight: 700;
            cursor: pointer;
        }

        button.ghost {
            background: var(--card);
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        [data-theme="dark"] table {
            background: var(--panel);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            z-index: 1;
        }

        /* Allow opt-out of sticky table headers for small popup tables
           â€” keep header visuals (background + text color) but disable sticky positioning */
        table.no-sticky thead {
            position: static !important;
            top: auto !important;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%) !important;
            color: white !important;
            z-index: auto !important;
        }

        th {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        th:last-child {
            border-right: none;
        }

        td {
            padding: 5px 6px;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        /* Ensure Cell5.5 table cells center their content (date and result pills) */
        #cell5_5 table th,
        #cell5_5 table td {
            text-align: center !important;
            vertical-align: middle !important;
            display: table-cell !important;
        }

        [data-theme="dark"] td {
            border-color: var(--border);
        }

        td:last-child {
            border-right: none;
        }

        tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        tbody tr:nth-child(odd) {
            background: white;
        }

        [data-theme="dark"] tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        [data-theme="dark"] tbody tr:nth-child(odd) {
            background: transparent;
        }

        tbody tr:hover {
            background: #ffe6b3 !important;
        }

        [data-theme="dark"] tbody tr:hover {
            background: rgba(255, 230, 179, 0.2) !important;
        }

        /* Keep top ranks in Cell4 readable on dark theme */
        [data-theme="dark"] #cell4 tbody tr.rank-top td {
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr.rank-top .pill {
            background: #fffbea;
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr:nth-child(n+4) td[style*="background:linear-gradient"] {
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.15) 0%, rgba(56, 239, 125, 0.25) 100%) !important;
            color: #fff !important;
        }

        .pill {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: #e6f4ea;
            color: #0b8a60;
            white-space: nowrap;
            margin: 1px;
            font-family: monospace;
        }

        /* Euclid small framed pills (default style copied from day.html) */
        .euclid-pill {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            /* single soft orange for lower glare */
            background: #f8f333;
            color: #000;
            white-space: nowrap;
            margin: 0 1px 0 0;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }

        .euclid-pill.empty {
            opacity: 0.45;
        }

        /* Popup-scoped euclid pill appearance (keeps high-contrast pill look in info popup) */
        table.no-sticky .euclid-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 28px;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 900;
            background: #fffbea;
            color: var(--text-strong);
            margin: 0 6px 0 0;
            font-family: monospace;
            text-align: center;
            border: none;
            -webkit-text-stroke: 0.36px rgba(0, 0, 0, 0.6);
            text-shadow: 0 0 1px rgba(0, 0, 0, 0.22);
        }

        /* Color the pill text according to 5 rank tiers (1..5) inside popup only */
        table.no-sticky .euclid-pill.rank-tier-1 {
            color: #08eb56;
        }

        table.no-sticky .euclid-pill.rank-tier-2 {
            color: #00E5FF;
        }

        table.no-sticky .euclid-pill.rank-tier-3 {
            color: #1a62ea;
        }

        table.no-sticky .euclid-pill.rank-tier-4 {
            color: #ea3ade;
        }

        table.no-sticky .euclid-pill.rank-tier-5 {
            color: #ea0313;
        }

        /* Info popup number pill (Sá»‘ column) */
        table.no-sticky td.num-cell {
            text-align: center;
        }

        .info-num-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 22px;
            padding: 2px 4px;
            border-radius: 6px;
            background: #2e7d32;
            color: #ffffff;
            font-weight: 800;
            font-family: monospace;
            box-sizing: border-box;
        }

        /* teal */

        .euclid-total-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 2px 5px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 800;
            background: #38ef7d;
            color: #072018;
            margin-left: 3px;
            font-family: monospace;
            min-width: 38px;
            text-align: center;
        }

        .label-chip {
            display: inline-block;
            min-width: 18px;
            padding: 2px 5px;
            margin: 1px 2px 1px 0;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-weight: 700;
            background: transparent;
            color: inherit;
        }

        .label-chip.highlight {
            background: var(--highlight-bg);
            color: var(--highlight-text);
        }

        /* Highlight class applied to number cells in the popup when hovering a group row.
           Use an outline + stronger box-shadow and z-index so the orange accent isn't
           visually obscured by darker 'selected/disabled' backgrounds or competing rules. */
        #numberPickerPopup #numberPickerTable td.popup-number-highlight {
            /* Thicker visible outline with inward emphasis (inner glow)
               Keep properties conservative to avoid linter noise. */
            outline: 4px solid #ff8c00;
            outline-offset: 2px;
            /* Outer soft glow + subtle ring to increase perceived thickness */
            box-shadow:
                0 10px 24px rgba(255, 140, 0, 0.10),
                /* outer soft shadow */
                0 0 0 6px rgba(255, 140, 0, 0.06),
                /* mid ring */
                inset 0 0 0 4px rgba(255, 140, 0, 0.18);
            /* inner thickening */
            position: relative;
            z-index: 1100;
        }

        [data-theme="dark"] .pill {
            background: rgba(56, 239, 125, 0.15);
            color: #38ef7d;
        }

        /* Prevent pill containers from wrapping.
           The selector `:has()` isn't supported in some editors/linters â€”
           provide a compatible class-based fallback and a tiny JS shim
           that marks `td` elements containing `.pill` with `.td-has-pill`. */
        td.td-has-pill {
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .pill {
                font-size: 10px;
                padding: 2px 5px;
                margin: 1px;
            }

            th,
            td {
                padding: 4px 6px;
                font-size: 11px;
            }
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid>* {
            flex: 1 1 350px;
            min-width: 0;
        }

        .grid-centered {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .grid-centered>* {
            flex: 0 1 calc(33.333% - 10px);
            max-width: 600px;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            .grid>* {
                flex: 1 1 100%;
            }

            .grid-centered>* {
                flex: 1 1 100%;
                max-width: none;
            }
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            padding: 3px 8px;
            border-radius: 8px;
            background: var(--accent-2);
            color: white;
            font-weight: 700;
            font-size: 12px;
            opacity: 0.9;
        }

        main {
            padding: 16px 12px 32px;
        }

        section {
            margin: 20px 0;
            padding: 16px;
        }

        /* Performance: skip rendering offscreen content like large apps do */
        section {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 800px 600px;
        }

        .card {
            content-visibility: auto;
            contain: content;
        }

        /* Marker for cards nested inside "card-inner" wrappers.
           JS will add the class 'card-inner-child' to any .card inside .card.card-inner.
           Use this selector to style inner cards separately. */
        .card-inner-child {
            /* empty by default; add overrides as needed */
            box-sizing: border-box;
            /* harmless default to avoid empty-selector warning */
        }

        /* Layout rule: make the inner wrapper a flex container so we can
           enforce max 2 child cards per row. Each child gets up to 50%
           width and will be centered when it's the only child. */
        .card.card-inner {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-start;
        }

        .card.card-inner>.card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* Some renderers create .card elements nested deeper than direct children.
           Ensure any descendant marked with .card-inner-child gets the same sizing. */
        .card.card-inner .card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* When a .card.card-inner contains exactly one inner card, center that
           inner card horizontally and allow it to size to its content (up to
           the wrapper width). This centers narrow tables while still allowing
           wider tables to grow up to the container. */
        .card.card-inner.single-child {
            justify-content: center;
        }

        .card.card-inner.single-child .card-inner-child {
            flex: 0 1 auto !important;
            max-width: 100% !important;
            width: auto !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* Prefer intrinsic table width inside a centered single child; allow
           the table to grow up to the wrapper width but not force 100% width. */
        .card.card-inner.single-child .card-inner-child table {
            width: auto !important;
            max-width: 100% !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* If a wrapper contains a single child, center it horizontally */
        .card.card-inner>.card-inner-child:only-child {
            margin-left: auto;
            margin-right: auto;
        }

        /* Small screens: stack to single column */
        @media (max-width: 768px) {
            .card.card-inner>.card-inner-child {
                flex: 0 0 100%;
                max-width: 100%;
            }
        }

        /* Reduce paint/layout when card bodies are offscreen */
        .card-body {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 200px 120px;
        }

        @media (min-width: 768px) {
            main {
                padding: 24px 18px 48px;
            }

            section {
                margin: 32px 0;
                padding: 22px;
            }
        }

        .error {
            color: #fca5a5;
            font-weight: 600;
        }

        .success {
            color: #34d399;
            font-weight: 700;
        }

        .loader {
            text-align: center;
            color: var(--muted);
            padding: 16px 0;
        }

        .flex {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        a.anchor {
            color: inherit;
            text-decoration: none;
        }

        .hidden {
            display: none;
        }

        /* Flash highlight after copying a row */
        tr.copied-row {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Floating scroll-to-top button */
        #scrollToTop {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToTop:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToTop:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #scrollToTop {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }

        /* Close button for number picker popup */
        .number-picker-close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255, 67, 67, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .number-picker-close-btn:hover {
            background: rgba(255, 67, 67, 1);
            transform: scale(1.1);
        }

        .number-picker-close-btn:active {
            transform: scale(0.95);
        }

        /* Canvas overlay for drawing connections */
        #connectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Make controls inside Cell8/9/10/11 stick under the header when scrolling.
           Keep them in normal flow so they match other sections visually.
        */
        #cell5_5 .controls,
        #cell6_5 .controls,
        #cell6_6 .controls,
        #cell8 .controls,
        #cell9 .controls,
        #cell10 .controls,
        #cell11 .controls {
            position: sticky;
            top: 64px;
            /* space for sticky header */
            z-index: 11;
            /* blue-gray â†’ dark-gray gradient to match normal section look */
            background: linear-gradient(135deg, #334155 0%, #1f2937 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px 12px;
            margin: 0 0 14px 0;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        /* Some browsers prevent sticky when an ancestor uses 'contain' or
           'content-visibility'. Disable containment for this specific
           section so the controls can stick correctly. */
        #cell5_5,
        #cell6_5,
        #cell6_6,
        #cell8,
        #cell9,
        #cell10,
        #cell11 {
            contain: none;
            content-visibility: visible;
        }

        /* JS fallback will add this class when it needs to pin the controls */
        .controls.stuck {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.24);
            transition: box-shadow 0.12s ease;
        }

        /* Mode selector two-row layout + swap control */
        .mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .mode-rows {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-row {
            display: flex;
            gap: 8px;
            align-items: center;
            /* Keep controls on a single row; allow horizontal scroll when space is tight */
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .mode-rows.reversed {
            flex-direction: column-reverse;
        }

        #swapRowsBtn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
        }

        /* === Exact place styles copied from day.html to match visuals === */
        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 60px;
            height: 60px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: var(--accent);
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 4px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        /* === End copied styles === */
    </style>
</head>

<body>
    <header>
        <div class="topbar">
            <div class="brand">Life Notebook
                <span id="htmlBadge">HTML</span>
            </div>
            <nav id="nav"></nav>
            <button class="theme-toggle" id="themeToggle" title="Chuyá»ƒn giao diá»‡n">ðŸŒ“</button>
        </div>
    </header>
    <div class="image-popup" id="imagePopup">
        <img src="anh.png" alt="Preview">
    </div>
    <!-- Number Picker Popup (copied from index.html) -->
    <div class="number-picker-popup" id="numberPickerPopup">
        <button class="number-picker-close-btn" id="closeNumberPickerBtn" title="ÄÃ³ng">âœ•</button>
        <table class="number-picker-table" id="numberPickerTable">
            <!-- Generated by JS -->
        </table>
        <div class="place-container">
            <div class="places-grid" id="placesGrid">
                <!-- Generated by JS: 6 place boxes V1-V6 -->
            </div>
        </div>
        <div class="mode-selector" id="modeSelectorContainer">
            <div class="mode-rows reversed" id="modeRows">
                <div class="mode-row" id="modeRowTop">
                    <label style="font-size: 12px;">Mode:</label>
                    <button id="modeSelector"
                        style="width: 100px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);">Sá»‘
                        (1-45)</button>
                    <button id="clearPlaceBtn" class="clear-btn" title="XÃ³a toÃ n bá»™ place"
                        style="padding: 6px 10px; font-size: 12px;">XÃ³a</button>
                    <label style="margin-left:6px;font-size:12px;">Rank:</label>
                    <button id="rankToggle"
                        style="width:80px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">rank</button>
                    <label style="margin-left:6px;font-size:12px;">Hover:</label>
                    <button id="quickPlaceToggle"
                        style="width:auto;min-width:48px;font-size:11px;padding:6px 4px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);box-sizing:border-box;max-width:100%;"
                        title="Toggle hover mode: 'Normal' = dblclick copies; 'Hover' = hover fills places">Normal</button>
                </div>
                <div class="mode-row" id="modeRowBottom">
                    <label style="margin-left: 6px; font-size: 12px;" id="connectionToggleLabel">Ná»‘i:</label>
                    <button id="connectionToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiá»‡n/áº©n Ä‘Æ°á»ng ná»‘i giá»¯a cÃ¡c sá»‘ liÃªn tiáº¿p">Hiá»‡n</button>
                    <label style="font-size: 12px;" id="euclidToggleLabel">Euclid:</label>
                    <button id="euclidToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiá»‡n/áº©n hiá»ƒn thá»‹ khoáº£ng cÃ¡ch Euclid">Hiá»‡n</button>
                    <span id="euclidTotal"
                        style="margin-left:8px;font-size:13px;font-weight:700;color:var(--text-strong);opacity:1;">Î£:&nbsp;&nbsp;
                        <span id="euclidTotalValue"
                            style="color:#38ef7d;font-weight:900;margin-left:8px;font-size:16px;text-shadow:0 0 8px rgba(56,239,125,0.22);">0.00</span>
                    </span>
                </div>
            </div>
        </div>
    </div>
    <button id="scrollToTop" title="Quay vá» Ä‘áº§u trang">â†‘</button>
    <main>
        <div id="status" class="card" style="margin-bottom:18px;">Äang táº£i dá»¯ liá»‡u...</div>
        <!-- Sections injected by JS -->
    </main>

    <script>
        // ===== Helpers from notebook =====
        const COL_MAP = { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 2, 10: 2, 11: 2, 12: 2, 13: 2, 14: 2, 15: 2, 16: 2, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 3, 23: 3, 24: 3, 25: 4, 26: 4, 27: 4, 28: 4, 29: 4, 30: 4, 31: 4, 32: 5, 33: 5, 34: 5, 35: 5, 36: 5, 37: 5, 38: 5, 39: 6, 40: 6, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6 };
        const getCol = (v) => COL_MAP[v] ?? 0;

        // Safe focus helper: prefer preventing scroll when moving focus programmatically
        function safeFocus(el) {
            if (!el) return;
            try {
                el.focus({ preventScroll: true });
            } catch (e) {
                try { el.focus(); } catch (e2) { /* ignore */ }
            }
        }
        // ===== Web Worker Setup =====
        // Táº¡o web worker inline Ä‘á»ƒ xá»­ lÃ½ tÃ­nh toÃ¡n náº·ng
        const workerCode = `
            // Helpers for worker
            const compareKey = (a, b) => { const pa = a.split("-").map(Number); const pb = b.split("-").map(Number); for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; } return pa.length - pb.length; };

            function kCombinations(set, k) {
                const combs = [];
                const recur = (start, combo) => {
                    if (combo.length === k) { combs.push([...combo]); return; }
                    for (let i = start; i < set.length; i++) { combo.push(set[i]); recur(i + 1, combo); combo.pop(); }
                };
                recur(0, []);
                return combs;
            }

            self.onmessage = (e) => {
                const { rows, xSel, consec, order, sortSel, workerType } = e.data;
                if (workerType === 'groupBySet') {
                    const x = parseInt(xSel, 10);
                    const groups = new Map();

                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            // Always enumerate combinations of size x from the 6 numbers.
                            // This ensures sets like size 5 (and 6) are counted correctly
                            // rather than only checking consecutive slices.
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                });
                            }
                        });

                    let arr = [...groups.entries()].filter(([, indices]) => indices.size >= 2);
                    if (sortSel === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sortSel === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sortSel === "count_asc") arr.sort((a, b) => a[1].size - b[1].size);
                    else arr.sort((a, b) => b[1].size - a[1].size);

                    self.postMessage({ result: arr.map(([k, v]) => [k, Array.from(v)]) });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        let worker = null;

        const getWorker = () => {
            if (!worker) worker = new Worker(workerUrl);
            return worker;
        };

        // ===== Data Loading =====
        let rows = [];
        async function loadData() {
            const status = document.getElementById("status");
            try {
                // Expect data.json in format: [{"date": "2024-01-01", "Result": "1,2,3,4,5,6"}, ...]
                const res = await fetch("data.json");
                if (!res.ok) throw new Error("KhÃ´ng tÃ¬m tháº¥y data.json. HÃ£y xuáº¥t tá»« Excel trÆ°á»›c.");
                const raw = await res.json();
                // Parse rows and normalize dates into a Date object + display string
                function parseDateString(raw) {
                    if (raw === undefined || raw === null) return { parsedDate: null, displayDate: '' };
                    let s = String(raw).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    if (s.includes('/')) {
                        const parts = s.split('/').map(p => p.trim());
                        if (parts.length >= 3) {
                            let [dd, mm, yy] = parts;
                            dd = dd.padStart(2, '0');
                            mm = mm.padStart(2, '0');
                            if (yy.length === 2) yy = '20' + yy;
                            const date = new Date(Number(yy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yy}` };
                        }
                    }
                    // only digits: try ddmmyyyy or ddmmyy (padded)
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = digits.slice(0, 2), mm = digits.slice(2, 4), yyyy = digits.slice(4, 8);
                            const date = new Date(Number(yyyy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                        }
                        // pad to 6 digits (ddmmyy) â€” handles numbers like 10117 -> 010117
                        const d6 = digits.padStart(6, '0');
                        const dd = d6.slice(0, 2), mm = d6.slice(2, 4), yy = d6.slice(4, 6);
                        const yyyy = 2000 + Number(yy);
                        const date = new Date(yyyy, Number(mm) - 1, Number(dd));
                        if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    // fallback to Date.parse
                    const dt = new Date(s);
                    if (!isNaN(dt)) {
                        const dd = String(dt.getDate()).padStart(2, '0');
                        const mm = String(dt.getMonth() + 1).padStart(2, '0');
                        const yyyy = dt.getFullYear();
                        return { parsedDate: dt, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    return { parsedDate: null, displayDate: s };
                }

                // Treat `date` as raw display string (don't attempt heavy parsing).
                rows = raw
                    .map(r => {
                        if (!r.Result || typeof r.Result !== "string") return null;
                        const nums = r.Result.split(",").map(x => parseInt(x.trim(), 10)).filter(Number.isInteger);
                        if (nums.length !== 6) return null;
                        const dateStr = String(r.date ?? r.Date ?? r.dateStr ?? r["date"] ?? '');
                        return { dateRaw: dateStr, date: dateStr, parsedDate: null, nums, label: nums.map(getCol).join("") };
                    })
                    .filter(Boolean);
                status.innerHTML = `<span class="success">ÄÃ£ táº£i ${rows.length} dÃ²ng</span> Â· file: data.json`;
            } catch (err) {
                status.innerHTML = `<span class="error">${err.message}</span><br/><span class="muted">Táº¡o file data.json tá»« Excel báº±ng script python: <code>python - <<'PY'\nimport pandas as pd, json\ndf = pd.read_excel('data.xlsx')\nout = df[['date','Result']]\nout.to_json('data.json', orient='records', force_ascii=False, indent=2)\nPY</code></span>`;
            }
        }

        // ===== Utilities =====
        let decimalPlaces = 2; // default decimal places for percentage
        const fmtPct = (v) => `${(v * 100).toFixed(decimalPlaces)}%`;
        const fmtPctCustom = (v, decimals) => `${(v * 100).toFixed(decimals)}%`;
        const MATCH_STYLE = "background:#2e7d32;color:#fff;"; // dark green with white text for matched values

        // Helpers to highlight numbers inside the number-picker popup
        function clearPopupHighlights() {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            tbl.querySelectorAll('td.popup-number-highlight').forEach(td => td.classList.remove('popup-number-highlight'));
        }

        function applyPopupHighlights(nums) {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            clearPopupHighlights();
            nums.forEach(n => {
                try {
                    const td = tbl.querySelector(`td[data-number="${n}"]`);
                    if (td) td.classList.add('popup-number-highlight');
                } catch (e) { /* ignore */ }
            });
        }

        // Debounce helper to prevent excessive function calls
        const createDebounce = (fn, delay = 100) => {
            let timeout;
            return function debounced(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        };

        // Throttle helper for smoother updates
        const createThrottle = (fn, delay = 100) => {
            let lastCall = 0;
            return function throttled(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return fn.apply(this, args);
                }
            };
        };

        // Double-click any table row that has data-result to copy its result string (format: 1,2,3,4,5,6)
        const handleRowCopyDblClick = (e) => {
            const row = e.target.closest("tr[data-result]");
            if (!row || !row.dataset.result) return;
            // Always allow dblclick-copy regardless of quick-place mode
            const text = row.dataset.result;

            const flash = () => {
                row.classList.add("copied-row");
                setTimeout(() => row.classList.remove("copied-row"), 500);
            };

            const fallbackCopy = () => {
                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.top = "-9999px";
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    document.execCommand("copy");
                    document.body.removeChild(ta);
                    flash();
                } catch (_) { /* ignore */ }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(flash).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        };

        // Global listener to catch all dynamic tables
        document.addEventListener('dblclick', handleRowCopyDblClick, true);

        // Global mouseover: apply popup highlights when hovering any record row
        // and clear when moving to a different card. This centralizes the
        // hover->popup behavior so all cells (cell6, cell6.5, cell6.6, etc.)
        // behave consistently.
        document.addEventListener('mouseover', (ev) => {
            try {
                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                const cardEl = tr ? tr.closest('.card') : null;

                // If hovering a result row, try to find the header <strong>{...}</strong>
                // in the same card and use it to compute popup highlights.
                if (tr && cardEl) {
                    const s = cardEl.querySelector('strong');
                    if (s && s.textContent) {
                        const nums = String(s.textContent || '').replace(/[{}]/g, '')
                            .split(/[^0-9]+/).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
                        if (nums.length) {
                            try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                            applyPopupHighlights(nums);
                            return;
                        }
                    }
                }

                // Otherwise, if moving to a different card, clear existing highlights
                const src = window.__popupHighlightSource || null;
                if (src && cardEl && cardEl !== src) {
                    clearPopupHighlights();
                    try { window.__popupHighlights = null; window.__popupHighlightSource = null; } catch (e) { }
                }
            } catch (e) { /* ignore */ }
        }, true);

        const anchorNav = [
            { id: "cell4", label: "Cell4 Â· Tá»· lá»‡ theo vá»‹ trÃ­" },
            { id: "cell5", label: "Cell5 Â· Xáº¿p háº¡ng vá»‹ trÃ­" },
            { id: "cell5_5", label: "Cell5.5 Â· Lá»‹ch sá»­" },
            { id: "cell6", label: "Cell6 Â· Cáº·p phá»• biáº¿n" },
            { id: "cell6_5", label: "Cell6.5 Â· Truy x" },
            { id: "cell6_6", label: "Cell6.6 Â· Má»• pattern" },
            { id: "cell7", label: "Cell7 Â· NhÃ³m label" },
            { id: "cell8", label: "Cell8 Â· TÃ¬m label" },
            { id: "cell9", label: "Cell9 Â· Tá»• há»£p tÃ¹y chá»n" },
            { id: "cell10", label: "Cell10 Â· PhÃ¢n tÃ­ch vá»‹ trÃ­" },
            { id: "cell11", label: "Cell11 Â· Pattern sá»‘" },
        ];

        function buildNav(showSection) {
            const nav = document.getElementById("nav");
            anchorNav.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "nav-btn";
                btn.textContent = item.label;
                btn.dataset.target = item.id;
                btn.onclick = () => {
                    // Lazy render the section only when needed
                    if (typeof ensureRendered === 'function') {
                        ensureRendered(item.id);
                    }
                    showSection(item.id);
                    history.replaceState(null, "", `#${item.id}`);
                };
                nav.appendChild(btn);
            });
        }

        // ===== Renderers =====
        function sectionShell(id, title, lead = "") {
            const sec = document.createElement("section");
            sec.id = id;
            sec.dataset.section = id;
            const h2 = document.createElement("h2");
            h2.textContent = title;
            sec.appendChild(h2);
            if (lead) {
                const p = document.createElement("p");
                p.className = "lead";
                p.textContent = lead;
                sec.appendChild(p);
            }
            const body = document.createElement("div");
            sec.appendChild(body);
            document.querySelector("main").appendChild(sec);
            return body;
        }

        // Quáº£n lÃ½ hiá»ƒn thá»‹ tá»«ng "trang" (section) mÃ  khÃ´ng máº¥t state
        function createSectionSwitcher() {
            const main = document.querySelector("main");
            const buttons = () => Array.from(document.querySelectorAll(".nav-btn"));
            const sections = () => Array.from(main.querySelectorAll("section"));
            const scrollPositions = new Map(); // LÆ°u vá»‹ trÃ­ scroll cho tá»«ng section

            function setActive(id) {
                // LÆ°u vá»‹ trÃ­ scroll hiá»‡n táº¡i trÆ°á»›c khi chuyá»ƒn
                const currentSection = sections().find(sec => !sec.classList.contains("hidden"));
                if (currentSection) {
                    scrollPositions.set(currentSection.id, window.scrollY);
                }

                buttons().forEach(btn => {
                    const active = btn.dataset.target === id;
                    btn.classList.toggle("active", active);
                });
                sections().forEach(sec => {
                    sec.classList.toggle("hidden", sec.id !== id);
                });

                // notify other components which section is now active
                try { document.dispatchEvent(new CustomEvent('sectionchange', { detail: { id } })); } catch (e) { }

                // Restore vá»‹ trÃ­ scroll cá»§a section má»›i
                requestAnimationFrame(() => {
                    // Prefer per-input saved scroll for cell10 when available
                    let savedPosition;
                    try {
                        if (id === 'cell10' && window._cell10LastIndex !== undefined && window._cell10LastIndex !== null && window._cell10ScrollByIndex instanceof Map) {
                            const p = window._cell10ScrollByIndex.get(window._cell10LastIndex);
                            if (p !== undefined) savedPosition = p;
                        }
                    } catch (e) { }

                    if (savedPosition === undefined) savedPosition = scrollPositions.get(id);
                    if (savedPosition !== undefined) {
                        window.scrollTo(0, savedPosition);
                    } else {
                        window.scrollTo(0, 0); // Scroll vá» Ä‘áº§u náº¿u chÆ°a cÃ³ lá»‹ch sá»­
                    }
                });
            }

            function showSection(id) {
                const target = sections().find(sec => sec.id === id);
                const fallback = "cell4";
                const finalId = target ? id : fallback;
                setActive(finalId);
            }

            return showSection;
        }


        function renderCell4() {
            const body = sectionShell("cell4", "Cell4 Â· Tá»· lá»‡ theo vá»‹ trÃ­ (home)", "Top/Sort tÆ°Æ¡ng tá»± notebook: hiá»ƒn thá»‹ tá»· lá»‡ tá»«ng sá»‘ theo 6 vá»‹ trÃ­.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[10, "Top 10"], [20, "Top 20"], [30, "Top 30"], [45, "Táº¥t cáº£ (45)"]].forEach(([v, l]) => {
                const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o);
            });
            topSel.value = "45";
            const sortSel = document.createElement("select");
            [["default", "Máº·c Ä‘á»‹nh (1â†’45)"], ["total_desc", "Theo tá»•ng % giáº£m dáº§n"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const decimalSel = document.createElement("select");
            [[0, "0 chá»¯ sá»‘"], [1, "1 chá»¯ sá»‘"], [2, "2 chá»¯ sá»‘"], [3, "3 chá»¯ sá»‘"], [4, "4 chá»¯ sá»‘"], [5, "5 chá»¯ sá»‘"], [6, "6 chá»¯ sá»‘"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiá»ƒn thá»‹:", topSel, "Sáº¯p xáº¿p:", sortSel, "Äá»™ chÃ­nh xÃ¡c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);
            // (removed debug placeholder)

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                const counts = Array.from({ length: 46 }, () => Array(6).fill(0));
                let total = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return;
                    total++;
                    r.nums.forEach((v, i) => { counts[v][i]++; });
                });
                let data = [];
                for (let v = 1; v <= 45; v++) {
                    const pcts = counts[v].map(c => total ? c / total : 0);
                    const countSum = counts[v].reduce((a, b) => a + b, 0);
                    data.push({ v, pcts, sum: pcts.reduce((a, b) => a + b, 0), count: countSum });
                }
                if (sortSel.value === "total_desc") data.sort((a, b) => b.sum - a.sum); else data.sort((a, b) => a.v - b.v);
                data = data.slice(0, parseInt(topSel.value, 10));

                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr>" +
                    "<th>Rank</th><th>Sá»‘</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>Tá»•ng %</th></tr></thead><tbody>";
                data.forEach((row, idx) => {
                    const bg = idx % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.05)";
                    html += `<tr style="background:${bg};">` +
                        `<td>#${idx + 1}</td><td><span class='pill'>${row.v}</span></td>` +
                        row.pcts.map(p => `<td>${fmtPctCustom(p, decimals)}</td>`).join("") +
                        `<td><span class='muted' style='font-size:12px;margin-right:8px;'>${row.count}/${total}=</span><strong>${fmtPctCustom(row.sum, decimals)}</strong></td></tr>`;
                });
                html += "</tbody></table></div>";
                wrap.innerHTML = html;
                // ensure viewport shows controls + results consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            topSel.onchange = sortSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5: xáº¿p háº¡ng theo vá»‹ trÃ­
        function renderCell5() {
            const body = sectionShell("cell5", "Cell5 Â· Xáº¿p háº¡ng theo vá»‹ trÃ­", "Chá»n top vÃ  tÃ´ Ä‘áº­m theo notebook.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[3, "Top 3"], [5, "Top 5"], [10, "Top 10"], [45, "Táº¥t cáº£ (45)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o); });
            topSel.value = "45";
            const decimalSel = document.createElement("select");
            [[0, "0 chá»¯ sá»‘"], [1, "1 chá»¯ sá»‘"], [2, "2 chá»¯ sá»‘"], [3, "3 chá»¯ sá»‘"], [4, "4 chá»¯ sá»‘"], [5, "5 chá»¯ sá»‘"], [6, "6 chá»¯ sá»‘"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiá»ƒn thá»‹:", topSel, "Äá»™ chÃ­nh xÃ¡c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                const count = Array.from({ length: 6 }, () => Array(46).fill(0));
                rows.forEach(r => { r.nums.forEach((v, i) => { count[i][v]++; }); });
                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                const topN = parseInt(topSel.value, 10);
                for (let rank = 0; rank < topN; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        const arr = [...Array(45).keys()].map(i => i + 1).map(v => [v, count[pos][v]]).sort((a, b) => b[1] - a[1]);
                        const [v, c] = arr[rank];
                        const pct = rows.length ? (c / rows.length) : 0;
                        const col = getCol(v);
                        cells.push(`<td><div><strong>${v}</strong> <span class='muted'>[C${col}]</span></div><div class='muted'>${c}/${rows.length}= ${fmtPctCustom(pct, decimals)}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank + 1}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                // ThÃªm báº£ng má»›i: Xáº¿p háº¡ng cá»™t theo vá»‹ trÃ­ (6x6)
                html += "<h3 style='margin-top: 24px; margin-bottom: 12px;'>Xáº¿p háº¡ng cá»™t theo vá»‹ trÃ­</h3>";

                // Tá»•ng % cá»§a tá»«ng cá»™t (C1-C6) trÃªn toÃ n bá»™ 6 vá»‹ trÃ­
                const colTotals = Array(6).fill(0);
                rows.forEach(r => {
                    r.nums.forEach(v => { const col = getCol(v); colTotals[col - 1]++; });
                });
                const totalPositions = rows.length * 6;
                const colPctDisplay = colTotals.map((c, idx) => {
                    const pct = fmtPctCustom(totalPositions ? c / totalPositions : 0, decimals);
                    return `<span class="pill" style="background:linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%); color:#fff; border:none;">C${idx + 1}</span> <strong>${pct}</strong>`;
                }).join(" Â· ");
                html += `<div style='margin:6px 0 10px; font-size:12px; color:var(--text-strong);'>${colPctDisplay}</div>`;

                html += "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";

                // TÃ­nh toÃ¡n: vá»›i má»—i vá»‹ trÃ­, xáº¿p háº¡ng cÃ¡c cá»™t (1-6) theo sá»‘ láº§n xuáº¥t hiá»‡n
                for (let rank = 1; rank <= 6; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        // Äáº¿m má»—i cá»™t (1-6) xuáº¥t hiá»‡n á»Ÿ vá»‹ trÃ­ nÃ y
                        const colCounts = {};
                        for (let col = 1; col <= 6; col++) colCounts[col] = 0;

                        rows.forEach(r => {
                            const v = r.nums[pos];
                            const col = getCol(v);
                            colCounts[col]++;
                        });

                        // Sáº¯p xáº¿p cÃ¡c cá»™t theo sá»‘ láº§n xuáº¥t hiá»‡n (giáº£m dáº§n)
                        const sortedCols = Object.entries(colCounts)
                            .map(([col, count]) => ({ col: parseInt(col), count }))
                            .sort((a, b) => b.count - a.count);

                        // Láº¥y cá»™t á»Ÿ rank nÃ y (rank - 1 vÃ¬ rank báº¯t Ä‘áº§u tá»« 1)
                        const { col: topCol, count: topCount } = sortedCols[rank - 1];
                        const pct = rows.length ? (topCount / rows.length) : 0;
                        cells.push(`<td><div><strong>C${topCol}</strong></div><div class='muted'>${topCount}/${rows.length}= ${fmtPctCustom(pct, parseInt(decimalSel.value, 10))}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                wrap.innerHTML = html;
            }
            topSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5.5: Lá»‹ch sá»­ â€” in ra toÃ n bá»™ bá»™ cÃ¡c ká»³, 3 báº£ng trÃªn má»™t hÃ ng, loáº¡i bá» cá»™t euclid
        function renderCell5_5() {
            const body = sectionShell("cell5_5", "Cell5.5 Â· Lá»‹ch sá»­", "Hiá»ƒn thá»‹ lá»‹ch sá»­ toÃ n bá»™ bá»™ cÃ¡c ká»³. Lá»c theo nÄƒm vÃ  sáº¯p xáº¿p theo thá»i gian.");
            const controls = document.createElement("div");
            controls.className = "controls";

            const sortSel = document.createElement("select");
            [["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            sortSel.value = 'desc';

            const yearSel = document.createElement("select");
            // will populate years after data is ready

            const monthSel = document.createElement("select");
            // will populate months after years are populated

            // info button that shows counts popup on hover
            const infoBtn = document.createElement('div');
            infoBtn.textContent = 'info';
            infoBtn.title = 'Di chuá»™t Ä‘á»ƒ xem thá»‘ng kÃª sá»‘ láº§n xuáº¥t hiá»‡n (1..45) cho NÄƒm/ThÃ¡ng Ä‘Ã£ chá»n';
            infoBtn.style.padding = '8px 10px';
            infoBtn.style.borderRadius = '8px';
            infoBtn.style.border = '1px solid var(--border)';
            infoBtn.style.background = 'var(--card)';
            infoBtn.style.color = 'var(--text)';
            infoBtn.style.cursor = 'pointer';
            infoBtn.style.fontSize = '12px';
            infoBtn.style.marginLeft = '6px';

            controls.append("Sáº¯p xáº¿p:", sortSel, "NÄƒm:", yearSel, "ThÃ¡ng:", monthSel, infoBtn);
            body.appendChild(controls);

            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            // parse date string into sortable timestamp (reused by months/year builders)
            function parseDateSortable(s) {
                if (!s) return 0;
                s = String(s).trim();
                // dd/mm/yyyy or dd/mm/yy
                let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                if (m) {
                    let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                    if (yy < 100) yy += 2000;
                    const dt = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt)) return dt.getTime();
                }
                // digits only: ddmmyyyy or ddmmyy
                const digits = s.replace(/\D/g, '');
                if (/^\d+$/.test(digits)) {
                    if (digits.length === 8) {
                        const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                        const dt = new Date(yyyy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    const d6 = digits.padStart(6, '0');
                    const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                    const dt2 = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt2)) return dt2.getTime();
                }
                // fallback to Date parsing
                const dtf = new Date(s);
                if (!isNaN(dtf)) return dtf.getTime();
                return 0;
            }

            function populateYears() {
                const prev = yearSel.value;
                yearSel.innerHTML = '';
                const yearsSet = new Set();
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (s.length >= 4) yearsSet.add(s.slice(-4));
                });
                const years = Array.from(yearsSet).filter(Boolean).sort((a, b) => b - a);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Táº¥t cáº£'; yearSel.appendChild(oAll);
                years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; yearSel.appendChild(o); });
                // restore previous selection if still available, otherwise default to 'all'
                if (prev && Array.from(yearSel.options).some(o => o.value === prev)) {
                    yearSel.value = prev;
                } else {
                    yearSel.value = 'all';
                }
                // populate months for the (possibly restored) year selection
                // mark selected option visually
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                populateMonths();
            }

            function populateMonths() {
                const prev = monthSel.value;
                monthSel.innerHTML = '';
                const monthsSet = new Set();
                const selectedYear = yearSel.value;
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (!s) return;
                    // if filtering by year, only consider rows matching that year (by last-4)
                    if (selectedYear && selectedYear !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== selectedYear) return;
                    }
                    const ts = parseDateSortable(s);
                    if (ts) {
                        const dt = new Date(ts);
                        const m = dt.getMonth() + 1;
                        monthsSet.add(m);
                    }
                });
                const months = Array.from(monthsSet).sort((a, b) => a - b);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Táº¥t cáº£'; monthSel.appendChild(oAll);
                // if no months detected (e.g., non-parseable dates), include generic 1..12
                if (!months.length) {
                    for (let i = 1; i <= 12; i++) {
                        const o = document.createElement('option'); o.value = String(i).padStart(2, '0'); o.textContent = `ThÃ¡ng ${i}`; monthSel.appendChild(o);
                    }
                } else {
                    months.forEach(m => { const o = document.createElement('option'); o.value = String(m).padStart(2, '0'); o.textContent = `ThÃ¡ng ${m}`; monthSel.appendChild(o); });
                }
                if (prev && Array.from(monthSel.options).some(o => o.value === prev)) {
                    monthSel.value = prev;
                } else {
                    monthSel.value = 'all';
                }
                // mark selected option visually
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
            }

            // Create a floating popup for the info box (shared for all hovers)
            const infoPopup = document.createElement('div');
            // use fixed positioning so the popup stays aligned with sticky controls
            infoPopup.style.position = 'fixed';
            infoPopup.style.zIndex = 9999;
            infoPopup.style.minWidth = '220px';
            infoPopup.style.maxWidth = '480px';
            infoPopup.style.maxHeight = '320px';
            infoPopup.style.overflow = 'auto';
            infoPopup.style.padding = '10px';
            infoPopup.style.borderRadius = '8px';
            infoPopup.style.border = '1px solid var(--border)';
            infoPopup.style.background = 'var(--panel)';
            infoPopup.style.color = 'var(--text)';
            infoPopup.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
            infoPopup.style.display = 'none';
            document.body.appendChild(infoPopup);

            // Pre-compute global totals/rank (across all rows, full history)
            const globalCounts = new Array(46).fill(0);
            rows.forEach(r => {
                const nums = r.nums || [];
                nums.forEach(n => {
                    const v = Number(n);
                    if (v >= 1 && v <= 45) globalCounts[v]++;
                });
            });
            const globalItems = [];
            for (let i = 1; i <= 45; i++) globalItems.push({ n: i, c: globalCounts[i] });
            globalItems.sort((a, b) => b.c - a.c || a.n - b.n);
            const globalRankMap = {};
            globalItems.forEach((it, idx) => { globalRankMap[it.n] = idx + 1; });

            // Build counts for numbers 1..45 for currently selected year/month
            let infoSort = 'desc'; // 'default' | 'desc' | 'asc' â€” default to Giáº£m dáº§n
            function buildCountsHtml() {
                // filter rows by year/month similar to draw()
                const filtered = rows.filter(r => {
                    const s = String(r.date || '');
                    if (!s) return false;
                    if (yearSel.value && yearSel.value !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== yearSel.value) return false;
                    }
                    if (monthSel.value && monthSel.value !== 'all') {
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        if (m !== monthSel.value) return false;
                    }
                    return true;
                });

                const counts = new Array(46).fill(0);
                filtered.forEach(r => {
                    const nums = r.nums || [];
                    nums.forEach(n => {
                        const v = Number(n);
                        if (v >= 1 && v <= 45) counts[v]++;
                    });
                });

                // prepare items and apply sorting
                const items = [];
                for (let i = 1; i <= 45; i++) items.push({ n: i, c: counts[i] });
                if (infoSort === 'desc') items.sort((a, b) => b.c - a.c || a.n - b.n);
                else if (infoSort === 'asc') items.sort((a, b) => a.c - b.c || a.n - b.n);

                let html = `<div style="font-weight:700;margin-bottom:6px;">Thá»‘ng kÃª xuáº¥t hiá»‡n (NÄƒm: ${yearSel.value || 'Táº¥t cáº£'} Â· ThÃ¡ng: ${monthSel.value || 'Táº¥t cáº£'})</div>`;
                html += `<div style="margin-bottom:8px;"><select id="infoSortSel" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);"><option value="default">Máº·c Ä‘á»‹nh</option><option value="desc">Giáº£m dáº§n (sá»‘ láº§n)</option><option value="asc">TÄƒng dáº§n (sá»‘ láº§n)</option></select></div>`;
                html += '<table class="no-sticky" style="width:100%;font-size:12px;border-collapse:collapse;">';
                html += '<thead><tr><th style="width:28px;text-align:left;padding:6px;border-bottom:1px solid var(--border);">Háº¡ng</th><th class="num-header" style="width:36px;text-align:center;padding:6px;border-bottom:1px solid var(--border);">Sá»‘</th><th style="text-align:right;padding:6px;border-bottom:1px solid var(--border);">Sá»‘ láº§n</th></tr></thead>';
                html += '<tbody>';
                items.forEach(it => {
                    const rankNum = globalRankMap[it.n];
                    const displayRank = rankNum || '-';
                    let pillClass = 'euclid-pill';
                    if (typeof rankNum === 'number') {
                        let tier = Math.ceil(rankNum / 9); // 45 numbers â†’ 5 tiers of ~9 each
                        tier = Math.max(1, Math.min(5, tier));
                        pillClass += ' rank-tier-' + tier;
                    }
                    html += `<tr><td style="padding:4px 6px;"><span class="${pillClass}">${displayRank}</span></td><td class="num-cell" style="padding:4px 6px;text-align:center;"><span class="info-num-pill">${it.n}</span></td><td style="padding:4px 6px;text-align:right;">${it.c}</td></tr>`;
                });
                html += '</tbody></table>';
                html += `<div style="margin-top:8px;color:var(--muted);font-size:11px;">Tá»•ng ká»³: ${filtered.length}</div>`;
                return html;
            }

            // Show/hide logic with pointer interaction (keep open if moving between btn and popup)
            let hoverTimeout = null;
            function renderInfoPopup() {
                infoPopup.innerHTML = buildCountsHtml();
                // wire the sort select inside popup
                const sel = infoPopup.querySelector('#infoSortSel');
                if (sel) {
                    sel.value = infoSort;
                    sel.onchange = () => {
                        infoSort = sel.value; infoPopup.innerHTML = buildCountsHtml(); // re-wire recursively
                        const sel2 = infoPopup.querySelector('#infoSortSel'); if (sel2) sel2.onchange = () => { infoSort = sel2.value; renderInfoPopup(); }
                    };
                }
            }

            // Positioning and show/hide helpers so the popup stays anchored
            // under the sticky controls even while the page is scrolled.
            let __infoPopupPositionBound = false;
            function positionInfoPopup() {
                try {
                    const rect = infoBtn.getBoundingClientRect();
                    const top = rect.bottom + 8;
                    let left = rect.left;
                    // Use actual popup width when available; fallback to declared maxWidth
                    const popupRect = infoPopup.getBoundingClientRect();
                    const popupWidth = (popupRect && popupRect.width) ? popupRect.width : parseInt(infoPopup.style.maxWidth || 480, 10);
                    // keep popup within viewport with small padding
                    const maxLeft = Math.max(8, window.innerWidth - popupWidth - 12);
                    if (left > maxLeft) left = maxLeft;
                    if (left < 8) left = 8;
                    infoPopup.style.top = top + 'px';
                    infoPopup.style.left = left + 'px';
                } catch (e) { /* ignore positioning errors */ }
            }

            function bindPopupPositionListeners() {
                if (__infoPopupPositionBound) return;
                // capture scroll so reposition happens even when ancestor elements scroll
                window.addEventListener('scroll', positionInfoPopup, true);
                window.addEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = true;
            }

            function unbindPopupPositionListeners() {
                if (!__infoPopupPositionBound) return;
                window.removeEventListener('scroll', positionInfoPopup, true);
                window.removeEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = false;
            }

            function showInfoPopup() {
                // only show when the Cell5.5 section is active
                const cell5 = document.getElementById('cell5_5');
                if (cell5 && cell5.classList.contains('hidden')) return;
                clearTimeout(hoverTimeout);
                renderInfoPopup();
                // ensure popup is visible so we can measure and position it
                infoPopup.style.display = 'block';
                // position now and while scrolling/resizing
                positionInfoPopup();
                bindPopupPositionListeners();
            }

            function hideInfoPopupSoon() {
                clearTimeout(hoverTimeout);
                hoverTimeout = setTimeout(() => { hideInfoPopup(); }, 180);
            }

            // Click-to-toggle only: popup opens/closes when clicking the `infoBtn` itself.
            infoBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (infoPopup.style.display === 'block') hideInfoPopup();
                else showInfoPopup();
            });
            // make infoBtn focusable and allow keyboard toggle (Enter/Space)
            infoBtn.tabIndex = 0;
            infoBtn.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (infoPopup.style.display === 'block') hideInfoPopup();
                    else showInfoPopup();
                }
            });

            // immediate hide helper (used by click)
            function hideInfoPopup() {
                clearTimeout(hoverTimeout);
                infoPopup.style.display = 'none';
                try { unbindPopupPositionListeners(); } catch (e) { }
            }

            // Prevent outer page scrolling when the pointer is over the popup.
            // Wheel: stop propagation and prevent default when appropriate.
            infoPopup.addEventListener('wheel', function (ev) {
                // allow scrolling inside the popup but prevent page scroll
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!canScroll) {
                    ev.preventDefault(); ev.stopPropagation();
                    return;
                }
                const delta = ev.deltaY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if ((delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    // consume the wheel so page doesn't move while interacting with popup
                    ev.stopPropagation();
                }
            }, { passive: false });

            // Touch support: prevent overscroll from reaching page on mobile
            let __infoTouchStartY = 0;
            infoPopup.addEventListener('touchstart', function (ev) {
                if (ev.touches && ev.touches.length) __infoTouchStartY = ev.touches[0].clientY;
            }, { passive: true });
            infoPopup.addEventListener('touchmove', function (ev) {
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!ev.touches || !ev.touches.length) return;
                const curY = ev.touches[0].clientY;
                const delta = __infoTouchStartY - curY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if (!canScroll || (delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    ev.stopPropagation();
                }
            }, { passive: false });

            // hide the info popup whenever we switch to another section
            document.addEventListener('sectionchange', (ev) => {
                try {
                    if (!ev || !ev.detail) return;
                    if (ev.detail.id !== 'cell5_5') {
                        hideInfoPopup();
                    }
                } catch (e) { }
            });

            // Update popup if filters change while it's visible
            yearSel.addEventListener('change', () => {
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });
            monthSel.addEventListener('change', () => {
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                populateYears();
                // Build data with parsedDate (if available) and display date
                let data = rows.map(r => ({ date: r.date || '', parsedDate: r.parsedDate || null, nums: r.nums || [], label: r.label || '' }));
                if (yearSel.value && yearSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        return s.length >= 4 ? s.slice(-4) === yearSel.value : false;
                    });
                }
                // filter by month if selected
                if (monthSel.value && monthSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        return m === monthSel.value;
                    });
                }
                // Helper: parse common dd/mm/yyyy or dd/mm/yy or digit-only forms into timestamp
                function parseDateSortable(s) {
                    if (!s) return 0;
                    s = String(s).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                    if (m) {
                        let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                        if (yy < 100) yy += 2000;
                        const dt = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    // digits only: ddmmyyyy or ddmmyy
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                            const dt = new Date(yyyy, mm - 1, dd);
                            if (!isNaN(dt)) return dt.getTime();
                        }
                        const d6 = digits.padStart(6, '0');
                        const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                        const dt2 = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt2)) return dt2.getTime();
                    }
                    // fallback to Date parsing
                    const dtf = new Date(s);
                    if (!isNaN(dtf)) return dtf.getTime();
                    return 0;
                }

                data = data.slice().sort((a, b) => {
                    const ta = a.parsedDate ? a.parsedDate.getTime() : parseDateSortable(a.date);
                    const tb = b.parsedDate ? b.parsedDate.getTime() : parseDateSortable(b.date);
                    return sortSel.value === 'desc' ? tb - ta : ta - tb;
                });

                if (!data.length) { wrap.innerHTML = "<div class='loader'>KhÃ´ng cÃ³ dá»¯ liá»‡u cho lá»±a chá»n nÃ y</div>"; return; }

                const pageSize = 20;
                const pages = [];
                for (let i = 0; i < data.length; i += pageSize) pages.push(data.slice(i, i + pageSize));

                if (!pages.length) {
                    wrap.innerHTML = "<div class='loader'>KhÃ´ng cÃ³ dá»¯ liá»‡u cho lá»±a chá»n nÃ y</div>";
                    return;
                }

                // Build lightweight card placeholders and mount content lazily to avoid scroll jank
                wrap.innerHTML = '';
                const infoBar = document.createElement('div');
                infoBar.style.cssText = 'text-align:center;margin-bottom:10px;color:var(--muted);font-weight:700;';
                infoBar.textContent = `Hiá»ƒn thá»‹ ${data.length} má»¥c Â· ${pages.length} báº£ng (tá»‘i Ä‘a ${pageSize}/báº£ng)`;
                wrap.appendChild(infoBar);

                const container = document.createElement('div');
                container.className = 'grid-centered';
                container.style.alignItems = 'flex-start';
                wrap.appendChild(container);

                const htmlCache = new Map();
                const heightCache = new Map();
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 36; // allow more mounted cards like Cell6.5 for snappier scroll
                // background pre-cache queue: build page HTML off-main when browser is idle
                const preCacheQueue = [];
                let preCacheScheduled = false;
                function runPreCache() {
                    if (preCacheScheduled) return;
                    preCacheScheduled = true;
                    const process = (deadline) => {
                        let count = 0;
                        while (preCacheQueue.length && (deadline ? deadline.timeRemaining() > 0 : count < 6)) {
                            const idx = preCacheQueue.shift();
                            if (!htmlCache.has(idx)) {
                                try {
                                    const p = pages[idx];
                                    if (p) htmlCache.set(idx, buildPageHtml(p, idx));
                                } catch (e) { /* ignore build errors */ }
                            }
                            count++;
                        }
                        if (preCacheQueue.length) {
                            if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                            else setTimeout(() => process(null), 50);
                        } else {
                            preCacheScheduled = false;
                        }
                    };
                    if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                    else setTimeout(() => process(null), 50);
                }

                const buildPageHtml = (page, pIdx) => {
                    const start = pIdx * pageSize;
                    const firstDate = page[0] ? page[0].date : '';
                    const lastDate = page[page.length - 1] ? page[page.length - 1].date : '';
                    let table = `<table style="width:100%;"><thead><tr><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>NgÃ y</th><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>Káº¿t quáº£</th></tr></thead><tbody>`;
                    page.forEach((row, j) => {
                        const result = (row.nums || []).join(',');
                        const numsHtml = (row.nums || []).map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        table += `<tr data-result="${result}"><td style='padding:6px;text-align:left'>${row.date}</td><td style='padding:6px;text-align:left'>${numsHtml}</td></tr>`;
                    });
                    table += '</tbody></table>';
                    const header = `<div style="font-weight:700; padding:8px 12px; border-bottom:1px solid var(--border);">Báº£ng ${pIdx + 1} Â· ${page.length} má»¥c Â· ${firstDate} â†’ ${lastDate}</div>`;
                    return `<div>${header}<div style='padding:8px;'>${table}</div></div>`;
                };

                const mount = (card, page, idx) => {
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(idx)) return;
                    const body = card.querySelector('.card-body');
                    let inner = htmlCache.get(idx);
                    if (!inner) {
                        inner = buildPageHtml(page, idx);
                        htmlCache.set(idx, inner);
                    }
                    body.innerHTML = inner;
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table (same as Cell6.5)
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights until another record hover updates them.
                                return;
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(idx);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const page = pages[idx];
                        if (!page) return;
                        if (entry.isIntersecting) mount(entry.target, page, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // chunked creation
                const total = pages.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, total);
                    for (let i = created; i < end; i++) {
                        const page = pages[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.currentPage = '-1';
                        card.dataset.page = String(i);
                        card.innerHTML = `<div class='card-body' style='min-height:100px;padding:8px;'></div>`;
                        container.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                        // enqueue light-weight pre-build of this page's HTML
                        preCacheQueue.push(i);
                        runPreCache();
                    }
                    created = end;
                    if (created < total) requestAnimationFrame(createChunk);
                };
                createChunk();

                // after structure is ready, scroll viewport to 240px so controls sit under header
                // Use a small timeout + rAF to wait for layout/paint to settle (match Cell6.5 behavior)
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (er) { } }
                    });
                }, 160);
            }

            sortSel.onchange = yearSel.onchange = monthSel.onchange = draw;
            // If rows are already loaded, populate and draw; otherwise draw will handle once data present
            draw();
        }
        // Helpers for labels
        const labelOf = (nums) => nums.map(getCol).join("");
        const diffPositions = (a, b) => { const pos = []; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) pos.push(i); return pos; };

        // Cell6: group by label with max diff + consecutive
        function renderCell6() {
            const body = sectionShell("cell7", "Cell7 Â· NhÃ³m theo label", "max sai khÃ¡c & liá»n ká», chá»‰ nhÃ³m >=2 ká»³.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const diffSel = document.createElement("select");
            for (let i = 0; i <= 6; i++) { const o = document.createElement("option"); o.value = i; o.textContent = `Sai khÃ¡c ${i}`; diffSel.appendChild(o); } diffSel.value = "1";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liá»n ká»"));
            const sortSel = document.createElement("select");
            [["count_desc", "Giáº£m dáº§n (sá»‘ ká»³)"], ["count_asc", "TÄƒng dáº§n (sá»‘ ká»³)"], ["value_asc", "TÄƒng dáº§n (giÃ¡ trá»‹)"], ["value_desc", "Giáº£m dáº§n (giÃ¡ trá»‹)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement('select');[["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            controls.append("Sai khÃ¡c tá»‘i Ä‘a:", diffSel, consecLabel, "Sáº¯p xáº¿p:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }

                // Táº¡o key Ä‘á»ƒ kiá»ƒm tra cache
                const newCacheKey = `${diffSel.value}|${consec.checked}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroups(groupCache);
                    return;
                }

                wrap.innerHTML = "<div class='loader'>Äang xá»­ lÃ½...</div>";

                // DÃ¹ng requestIdleCallback Ä‘á»ƒ tÃ­nh toÃ¡n khi browser ráº£nh
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => computeAndRender());
                } else {
                    setTimeout(() => computeAndRender(), 0);
                }

                function computeAndRender() {
                    const labelRows = {};
                    rows.forEach(r => { const label = labelOf(r.nums); (labelRows[label] ||= []).push(r); });
                    const labels = Object.keys(labelRows).sort();
                    const used = new Set();
                    let groups = [];

                    // BÆ°á»›c 1: LuÃ´n nhÃ³m theo Ä‘iá»u kiá»‡n lá»ng nháº¥t (khÃ´ng liá»n ká»)
                    labels.forEach(base => {
                        if (used.has(base)) return;
                        used.add(base);
                        const gLabels = [base];
                        let gRows = [...labelRows[base]];

                        for (let j = 0; j < labels.length; j++) {
                            const other = labels[j];
                            if (used.has(other)) continue;
                            const pos = diffPositions(base, other);
                            // Chá»‰ kiá»ƒm tra sá»‘ vá»‹ trÃ­ khÃ¡c nhau, khÃ´ng kiá»ƒm tra liá»n ká»
                            if (pos.length > parseInt(diffSel.value, 10)) continue;
                            used.add(other); gLabels.push(other); gRows.push(...labelRows[other]);
                        }
                        if (gRows.length >= 2) groups.push({ base, labels: gLabels, rows: gRows });
                    });

                    // BÆ°á»›c 2: Náº¿u tick "Liá»n ká»", lá»c cÃ¡c labels khÃ´ng thoáº£ Ä‘iá»u kiá»‡n trong má»—i nhÃ³m
                    if (consec.checked) {
                        groups = groups.map(g => {
                            // Giá»¯ láº¡i chá»‰ nhá»¯ng labels thoáº£ Ä‘iá»u kiá»‡n liá»n ká» vá»›i base
                            const filteredLabels = g.labels.filter(label => {
                                const pos = diffPositions(g.base, label);
                                // Náº¿u chá»‰ khÃ¡c â‰¤1 vá»‹ trÃ­ thÃ¬ OK (khÃ´ng cáº§n kiá»ƒm tra liá»n ká»)
                                if (pos.length <= 1) return true;
                                // Náº¿u khÃ¡c â‰¥2 vá»‹ trÃ­, kiá»ƒm tra liá»n ká»
                                return pos.every((p, i) => i === 0 || p - pos[i - 1] === 1);
                            });
                            // TÃ­nh láº¡i rows dá»±a trÃªn filtered labels
                            const filteredRows = [];
                            filteredLabels.forEach(label => {
                                filteredRows.push(...labelRows[label]);
                            });
                            return { base: g.base, labels: filteredLabels, rows: filteredRows };
                        }).filter(g => g.rows.length >= 2); // Chá»‰ giá»¯ nhÃ³m â‰¥2 ká»³
                    }

                    groups.sort((a, b) => b.rows.length - a.rows.length);
                    groupCache = groups;
                    cacheKey = newCacheKey;
                    renderGroups(groups);
                }
            }

            function renderGroups(groups) {
                // Apply sorting based on sortSel value
                if (sortSel.value === 'count_desc') groups.sort((a, b) => b.rows.length - a.rows.length);
                else if (sortSel.value === 'count_asc') groups.sort((a, b) => a.rows.length - b.rows.length);
                else if (sortSel.value === 'value_asc') groups.sort((a, b) => compareKey(a.base, b.base));
                else if (sortSel.value === 'value_desc') groups.sort((a, b) => compareKey(b.base, a.base));

                // Summary + grid container
                wrap.innerHTML = `<div class='muted'>${groups.length} nhÃ³m Â· ${groups.reduce((s, g) => s + g.rows.length, 0)} ká»³</div>` +
                    `<div class='grid-centered' id='labelGroupGrid'></div>`;
                const grid = wrap.querySelector('#labelGroupGrid');

                // Caches for smoother back-scroll (per-page keys `${idx}|${page}`)
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = []; // maintain recency for limiting cache
                const MAX_CACHE = 160;
                const cardRefs = new Map(); // idx -> element
                const mountedSet = new Set(); // idx currently mounted
                const MAX_MOUNTED = 36; // limit live DOM to reduce churn

                const setCache = (key, html) => {
                    htmlCache.set(key, html);
                    lruQueue.push(key);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        const rmIdx = String(rm).split('|')[0];
                        if (!mountedSet.has(Number(rmIdx))) htmlCache.delete(rm);
                    }
                };

                const mount = (card, g, idx) => {
                    const body = card.querySelector('.card-body');
                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(g.rows.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;
                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const start = page * pageSizeRows;
                        const rowsToUse = (typeof recencySel !== 'undefined' && recencySel.value === 'desc') ? g.rows.slice().reverse() : g.rows.slice();
                        const slice = rowsToUse.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        inner += "<table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        slice.forEach(r => {
                            const label = labelOf(r.nums);
                            const labelHtml = label.split("").map((ch, i) => ch !== g.base[i]
                                ? `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>`
                                : `<span>${ch}</span>`).join(" ");
                            const nums = r.nums.map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        inner += "</tbody></table>";
                        if (g.rows.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${g.rows.length - (page + 1) * pageSizeRows} dÃ²ng ná»¯a</td></tr>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner);
                    }
                    body.style.minHeight = "";
                    body.innerHTML = inner;
                    // attach pagination handlers
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    // Measure and cache height after first mount
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = ""; // free DOM when offscreen
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    // Unmount farthest cards first
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const g = groups[idx];
                        if (!g) return;
                        if (entry.isIntersecting) {
                            mount(entry.target, g, idx);
                        } else {
                            unmount(entry.target, idx);
                        }
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Chunked creation of cards to avoid main-thread spikes
                const totalGroups = groups.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, groups.length);
                    for (let i = created; i < end; i++) {
                        const g = groups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // show rank/total to the left of the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>Base ${g.base}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${g.rows.length} ká»³</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < groups.length) requestAnimationFrame(createChunk);
                };
                createChunk();
                // After rendering group cards, ensure page scrolls to 240px
                // Use a small delay to allow layout to settle before scrolling
                try { setTimeout(() => { window.scrollTo({ top: 240, behavior: 'smooth' }); }, 50); } catch (e) { try { setTimeout(() => { window.scrollTo(0, 240); }, 50); } catch (er) { /* ignore */ } }
            }

            // DÃ¹ng debounce Ä‘á»ƒ trÃ¡nh tÃ­nh toÃ¡n quÃ¡ táº§n suáº¥t
            const debouncedGroup = createDebounce(group, 300);
            diffSel.onchange = consec.onchange = debouncedGroup;
            recencySel.onchange = debouncedGroup;
            sortSel.onchange = () => groupCache && renderGroups(groupCache);
            group();
        }

        // Helper: parse a comma/space separated string into six valid numbers (1-45), or return null
        function parseSixNumbersFromString(s) {
            if (!s || typeof s !== 'string') return null;
            // split on any non-digit characters
            const parts = s.split(/[^0-9]+/).map(p => p.trim()).filter(Boolean);
            if (parts.length !== 6) return null;
            const nums = parts.map(p => parseInt(p, 10));
            if (nums.some(n => !Number.isFinite(n) || n < 1 || n > 45)) return null;
            const uniq = new Set(nums);
            if (uniq.size !== 6) return null;
            return nums;
        }

        // Helper: apply an array of 6 numbers into the cell6_6 inputs (if present)
        function applySixToCell6_6(nums) {
            try {
                if (!Array.isArray(nums) || nums.length !== 6) return false;
                const sec = document.getElementById('cell6_6');
                if (!sec) return false;
                const inputs = Array.from(sec.querySelectorAll('.drag-input-container input'));
                if (!inputs || inputs.length < 6) return false;
                for (let i = 0; i < 6; i++) {
                    inputs[i].value = String(nums[i]);
                    inputs[i].dispatchEvent(new Event('input'));
                }
                // small visual feedback: pulse the first input container
                try {
                    const cont = inputs[0].parentElement;
                    if (cont) {
                        cont.animate([{ boxShadow: '0 0 0 6px rgba(56,239,125,0.18)' }, { boxShadow: '0 0 0 0 rgba(56,239,125,0)' }], { duration: 450 });
                    }
                } catch (e) { }
                return true;
            } catch (e) { return false; }
        }

        // Delegated dblclick behavior: read clipboard and, when a place-box or a cell6_6 input is double-clicked,
        // parse a 6-number string and apply it to the Cell6.6 inputs. Use document-level delegation so listeners
        // work regardless of render order.
        (function setupClipboardDoubleClickHandlersDelegated() {
            try {
                document.addEventListener('dblclick', async (ev) => {
                    // If the dblclick happened inside the number picker popup, let the
                    // popup-local handlers handle it (they run on the target). The
                    // global handler runs in capture mode and may cause unwanted
                    // focus/scroll behavior; ignore events originating inside the popup.
                    try {
                        const popup = document.getElementById('numberPickerPopup');
                        if (popup && popup.contains(ev.target)) return;
                    } catch (e) { }

                    // Only handle dblclick when user targets a place-box or one of the six input containers
                    const box = ev.target.closest('.place-box');
                    const inputContainer = ev.target.closest('.drag-input-container');
                    if (!box && !inputContainer) return;

                    let text = null;
                    // Try clipboard API first
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            text = await navigator.clipboard.readText();
                        }
                    } catch (err) {
                        // ignore and fall back to prompt
                        text = null;
                    }

                    // If clipboard API not available or returned empty, fall back to prompt
                    if (!text || String(text).trim() === '') {
                        try {
                            const promptStr = 'Paste 6 numbers (comma or space separated), e.g. 29,3,35,24,18,30';
                            const res = window.prompt(promptStr, '');
                            if (res && String(res).trim() !== '') text = res.trim();
                        } catch (e) { text = null; }
                    }

                    if (!text) return;

                    try {
                        const nums = parseSixNumbersFromString(text);
                        const targetElem = box || inputContainer || ev.target;
                        if (nums) {
                            applySixToCell6_6(nums);
                            try { if (targetElem) targetElem.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (e) { }
                        } else {
                            try { if (targetElem) targetElem.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (e) { }
                        }
                    } catch (err) { console.warn('clipboard parse/apply failed', err); }
                }, true);
            } catch (e) { }
        })();

        // Cell6.6: Má»• pattern â€” accept exactly 6 distinct numbers and list all combinations
        function renderCell6_6() {
            const body = sectionShell("cell6_6", "Cell6.6 Â· Má»• pattern", "Nháº­p Ä‘á»§ 6 sá»‘ (1-45) vÃ  chá»n kÃ­ch thÆ°á»›c tá»• há»£p Ä‘á»ƒ liá»‡t kÃª.");
            const controls = document.createElement("div"); controls.className = "controls";

            // six fixed number inputs with per-input +/- buttons and global left/right navigation
            const rawInputs = Array.from({ length: 6 }, (_, i) => {
                const inp = document.createElement('input');
                inp.type = 'number'; inp.min = 1; inp.max = 45; inp.placeholder = `#${i + 1}`;
                inp.style.width = '70px'; inp.style.boxSizing = 'border-box';
                return inp;
            });

            // create select controls
            const combSel = document.createElement('select');[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = `Bá»™ ${v}`; combSel.appendChild(o); }); combSel.value = '3';
            const sortSel = document.createElement('select');[["count_desc", "Giáº£m dáº§n (sá»‘ ká»³)"], ["count_asc", "TÄƒng dáº§n (sá»‘ ká»³)"], ["value_asc", "TÄƒng dáº§n (giÃ¡ trá»‹)"], ["value_desc", "Giáº£m dáº§n (giÃ¡ trá»‹)"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            // recency selector (Má»›i â†’ CÅ© / CÅ© â†’ Má»›i) â€” mirror Cell6.5 behavior
            const recencySel = document.createElement('select');
            [["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';

            // consecutive & order toggles (same behavior as Cell6/Cell6.5)
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liá»n ká»")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;

            // (no global nav buttons â€” per-input arrow buttons and keyboard arrows remain)

            const inputs = [];
            // create per-input container with up/down buttons (same behavior as Cell9)
            rawInputs.forEach((inp, idx) => {
                const container = document.createElement('div');
                container.className = 'drag-input-container';
                container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;vertical-align:middle;';
                container.draggable = false;

                // small left-side grip (visual) â€” kept but pointer-events managed by updateDraggable
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // reserve space on the right for buttons to match Cell9
                inp.style.position = 'relative'; inp.style.zIndex = '1'; inp.style.paddingRight = '40px'; inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = 'â–²'; up.title = 'TÄƒng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = 'â–¼'; down.title = 'Giáº£m 1'; down.style.cssText = arrowStyle;

                // clamp helper for numeric input
                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });

                btnGroup.appendChild(up); btnGroup.appendChild(down);
                container.appendChild(inp); container.appendChild(btnGroup); container.appendChild(dragHandle);
                container.dataset.index = idx;

                // visual/state update for draggable container
                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                // keyboard left/right move (wrap)
                inp.addEventListener('keydown', (ev) => {
                    if (ev.key === 'ArrowLeft') {
                        ev.preventDefault();
                        const prev = (idx - 1 + 6) % 6; rawInputs[prev].focus();
                    } else if (ev.key === 'ArrowRight') {
                        ev.preventDefault();
                        const next = (idx + 1) % 6; rawInputs[next].focus();
                    }
                });

                inp.addEventListener('input', () => { clampForNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampForNumber(); updateDraggable(); });
                updateDraggable();

                // drag/drop: allow dragging this input out to clear it, and swapping values with another input
                container.__dropHandled = false;
                container.__dragging = false;

                container.addEventListener('dragstart', (e) => {
                    container.__dragging = true;
                    container.__dropHandled = false;
                    container.style.opacity = '0.5';
                    try { window.__draggingDynamic = { type: 'cell6_6', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                    try { e.dataTransfer.setData('text/plain', String(inp.value ?? '')); } catch (er) { }
                    try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                });

                container.addEventListener('dragend', (e) => {
                    container.style.opacity = '';
                    try { window.__draggingDynamic = null; } catch (err) { }
                    if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                        draw();
                    }
                    container.__dragging = false;
                    container.__dropHandled = false;
                });

                container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(56, 239, 125, 0.04)'; });
                container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                container.addEventListener('drop', (e) => {
                    e.preventDefault(); container.style.backgroundColor = ''; container.__dropHandled = true;
                    const txt = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');
                    let value = null;
                    // If dragging from another dynamic input, swap values instead of replacing
                    try {
                        if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                            const srcInput = window.__draggingDynamic.input;
                            const srcVal = String(srcInput.value ?? '');
                            const tgtVal = String(inp.value ?? '');
                            // perform swap
                            srcInput.value = tgtVal;
                            srcInput.dispatchEvent(new Event('input'));
                            inp.value = srcVal;
                            inp.dispatchEvent(new Event('input'));
                            // mark both containers as handled to avoid clearing on dragend
                            try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                            container.__dropHandled = true;
                            try { window.__draggingDynamic = null; } catch (err) { }
                            draw();
                            return;
                        }
                    } catch (err) { }

                    if (placeIndexData) {
                        const idx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                    } else if (placeSetData) {
                        // If full place-set (6 values) is dropped, apply the entire 6-number state to the cell
                        try {
                            const arr = JSON.parse(placeSetData);
                            if (Array.isArray(arr) && arr.length === 6) {
                                try {
                                    // write all six inputs
                                    for (let k = 0; k < 6; k++) {
                                        const v = arr[k];
                                        if (v === null || v === undefined || String(v).trim() === '') {
                                            inputs[k].value = '';
                                        } else {
                                            let nn = parseInt(String(v).trim(), 10);
                                            if (!Number.isFinite(nn)) nn = '';
                                            else {
                                                if (nn < 1) nn = 1;
                                                if (nn > 45) nn = 45;
                                            }
                                            inputs[k].value = nn === '' ? '' : String(nn);
                                        }
                                        inputs[k].dispatchEvent(new Event('input'));
                                    }
                                    // mark all containers handled so they won't clear on dragend
                                    try { inputs.forEach(i => i.parentElement.__dropHandled = true); } catch (e) { }
                                    try { window.__draggingDynamic = null; } catch (e) { }
                                    draw();
                                    return;
                                } catch (err) { }
                            }
                            // fallback: pick first non-empty value in the set for this single input
                            if (Array.isArray(arr) && arr.length) {
                                for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } }
                            }
                        } catch (err) { }
                    } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                        value = txt;
                    } else if (labelData) { value = labelData; }

                    if (value !== null && value !== undefined) {
                        let n = parseInt(String(value).trim(), 10);
                        if (Number.isFinite(n)) {
                            if (n < 1) n = 1;
                            if (n > 45) n = 45;
                            inp.value = String(n);
                            inp.dispatchEvent(new Event('input'));
                            draw();
                        }
                    }
                });

                inputs.push(inp);
                controls.append(container);
            });

            controls.append('KÃ­ch thÆ°á»›c:', combSel, consecLabel, orderLabel, 'Sáº¯p xáº¿p:', sortSel, recencySel);
            body.appendChild(controls);

            const wrap = document.createElement('div'); wrap.className = 'card card-inner'; body.appendChild(wrap);

            function draw() {
                if (!rows || !rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                const vals = inputs.map(i => { const v = String(i.value ?? '').trim(); return v === '' ? NaN : parseInt(v, 10); });
                if (vals.some(v => !Number.isFinite(v))) { wrap.innerHTML = "<div class='muted'>Vui lÃ²ng nháº­p Ä‘á»§ 6 sá»‘ há»£p lá»‡</div>"; return; }
                const uniq = new Set(vals);
                if (uniq.size !== 6) { wrap.innerHTML = "<div class='error'>CÃ¡c sá»‘ pháº£i khÃ¡c nhau</div>"; return; }

                const m = parseInt(combSel.value, 10) || 1;

                // generate all combinations from the user-provided 6 numbers
                const combos = kCombinations(vals, m).map(c => c.slice().sort((a, b) => a - b));

                // compute global counts for all combos of size m across rows
                // respect consecutive/order toggles when counting
                const globalCounts = Object.create(null);
                const consecChecked = !!consec.checked;
                const orderChecked = !!order.checked;
                rows.forEach(r => {
                    if (!r.nums || !Array.isArray(r.nums)) return;
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            globalCounts[key] = (globalCounts[key] || 0) + 1;
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m).map(c => c.slice().sort((a, b) => a - b));
                        combosRow.forEach(c => { const k = c.join('-'); globalCounts[k] = (globalCounts[k] || 0) + 1; });
                    }
                });

                // build results for user's combos
                const results = combos.map(c => {
                    const key = c.join('-');
                    return { key, combo: c, cnt: globalCounts[key] || 0 };
                });

                // build ranking map over all global combos (use same baseline sort logic as other cells)
                const globalArr = Object.keys(globalCounts).map(k => ({ k, cnt: globalCounts[k] }));
                const baselineSort = sortSel.value;
                if (baselineSort === "value_asc") globalArr.sort((a, b) => compareKey(a.k, b.k));
                else if (baselineSort === "value_desc") globalArr.sort((a, b) => compareKey(b.k, a.k));
                else if (baselineSort === "count_asc") globalArr.sort((a, b) => a.cnt - b.cnt);
                else globalArr.sort((a, b) => b.cnt - a.cnt);
                const rankMap = Object.create(null);
                globalArr.forEach((it, idx) => { rankMap[it.k] = idx + 1; });

                // apply requested sort
                if (sortSel.value === 'value_asc') results.sort((a, b) => compareKey(a.key, b.key));
                else if (sortSel.value === 'value_desc') results.sort((a, b) => compareKey(b.key, a.key));
                else if (sortSel.value === 'count_asc') results.sort((a, b) => a.cnt - b.cnt);
                else results.sort((a, b) => b.cnt - a.cnt);

                // build groups for only the user's combos (map key -> rows array)
                const userKeys = new Set(results.map(r => r.key));
                const groups = new Map();
                rows.forEach(r => {
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            if (!userKeys.has(key)) continue;
                            if (!groups.has(key)) groups.set(key, []);
                            groups.get(key).push(r);
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m);
                        combosRow.forEach(c => {
                            const values = c.slice().sort((a, b) => a - b);
                            const k = values.join('-');
                            if (!userKeys.has(k)) return;
                            if (!groups.has(k)) groups.set(k, []);
                            groups.get(k).push(r);
                        });
                    }
                });

                // build array of [key, list] for user's combos
                // include combos with no records (empty list) so every user combo is shown
                let arrGroups = results.map(r => [r.key, groups.get(r.key) || []]);

                // build baseline over all global combos for ranking (same baseline sort logic)
                const globalArrFull = Object.keys(globalCounts).map(k => [k, []]);
                // populate counts into a map for baseline ordering
                const baselineArrAll = Object.keys(globalCounts).map(k => [k, new Array(globalCounts[k])]);
                // sort baseline keys according to baselineSort (reuse earlier `baselineSort`)
                if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => globalCounts[a[0]] - globalCounts[b[0]]);
                else baselineArrAll.sort((a, b) => globalCounts[b[0]] - globalCounts[a[0]]);

                // sort displayed groups according to user's sortSel
                if (sortSel.value === 'value_asc') arrGroups.sort((a, b) => compareKey(a[0], b[0]));
                else if (sortSel.value === 'value_desc') arrGroups.sort((a, b) => compareKey(b[0], a[0]));
                else if (sortSel.value === 'count_asc') arrGroups.sort((a, b) => a[1].length - b[1].length);
                else arrGroups.sort((a, b) => b[1].length - a[1].length);

                // render cards similar to Cell6: one card per combo showing rows
                // Create container and defer building full table HTML until a card is visible
                wrap.innerHTML = `<div class='muted'>${arrGroups.length} tá»• há»£p Â· hiá»ƒn thá»‹ tá»‘i Ä‘a ${arrGroups.length} báº£ng</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // caches and mount management
                const heightCache = new Map();
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 40;

                const mount = (card, idx) => {
                    if (card.dataset.mounted === '1') return;
                    const [key, list] = arrGroups[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');
                    const maxRows = 200;
                    // respect recency selector when choosing which rows to display
                    let displayList = list.slice();
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                    const slice = displayList.slice(0, maxRows);
                    const baselineTotal = baselineArrAll.length || arrGroups.length;
                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === key);
                    let rankDisplay = `${idx + 1}/${arrGroups.length}`;
                    let occDisplay = `${list.length} ká»³`;
                    if (idxInBaseline >= 0) {
                        rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                        occDisplay = `${globalCounts[key] || list.length} ká»³`;
                    }

                    let inner = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                        `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                        `<div style='display:flex;align-items:center;gap:8px'>` +
                        `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                        `<span class='badge'>${occDisplay}</span>` +
                        `</div>` +
                        `</div>`;
                    inner += `<table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                    const setValues = new Set(key.split('-').map(Number));
                    if (slice.length === 0) {
                        inner += `<tr><td colspan='4' class='muted'>KhÃ´ng cÃ³ káº¿t quáº£</td></tr>`;
                    } else {
                        slice.forEach(r => {
                            const orderedSeqForHighlight = (consecChecked && orderChecked) ? key.split('-').map(Number) : Array.from(setValues);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, m, consecChecked, orderedSeqForHighlight, orderChecked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    else euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                    }
                    if (list.length > maxRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - maxRows} dÃ²ng ná»¯a</td></tr>`;
                    inner += `</tbody></table>`;

                    body.innerHTML = inner;
                    card.dataset.mounted = '1';
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // create card shells in chunks to avoid blocking layout
                const totalGroups = arrGroups.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arrGroups.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arrGroups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        // Only create an empty card body here. The card header (div.flex)
                        // will be rendered inside the mounted body to avoid duplicate headers.
                        card.innerHTML = `<div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arrGroups.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                if (arrGroups.length === 1) wrap.classList.add('single-child');

                // After chunked creation completes, scroll viewport to keep controls visible
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } }
                    });
                }, 160);
            }

            // wire events: input changes trigger redraw
            inputs.forEach((i) => i.addEventListener('input', draw));
            combSel.addEventListener('change', draw);
            sortSel.addEventListener('change', draw);
            if (recencySel) recencySel.addEventListener('change', draw);
            // consec toggles enable/disable order and trigger redraw
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; draw(); };
            order.addEventListener('change', draw);
            draw();
        }
        // Cell6.5: Truy x - same grouping logic as Cell6 but filter groups to those containing a user-specified number x
        function renderCell6_5() {
            const body = sectionShell("cell6_5", "Cell6.5 Â· Truy x", "Chá»n sá»‘ x (1-45) vÃ  kÃ­ch thÆ°á»›c bá»™ Ä‘á»ƒ liá»‡t kÃª chá»‰ nhá»¯ng bá»™ liÃªn quan tá»›i x.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `Bá»™ ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            // remember previous comb so we only clear extras when shrinking the set
            let prevComb = parseInt(xSel.value, 10) || 1;
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liá»n ká»")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Giáº£m dáº§n (sá»‘ ká»³)"], ["count_asc", "TÄƒng dáº§n (sá»‘ ká»³)"], ["value_asc", "TÄƒng dáº§n (giÃ¡ trá»‹)"], ["value_desc", "Giáº£m dáº§n (giÃ¡ trá»‹)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement("select");
            [["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';
            const xFilter = document.createElement("input"); xFilter.type = "number"; xFilter.min = 1; xFilter.max = 45; xFilter.placeholder = "Sá»‘ x (1-45)"; xFilter.style.width = '88px';
            // Create +/- buttons styled and behaving like Cell9 arrows
            const xContainer = document.createElement('div');
            xContainer.style.cssText = 'position:relative;display:inline-block;vertical-align:middle;margin-right:8px;';
            xFilter.style.paddingRight = '40px';
            xFilter.style.boxSizing = 'border-box';
            const btnGroup = document.createElement('div');
            btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
            const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
            const upBtn = document.createElement('button'); upBtn.type = 'button'; upBtn.className = 'arrow-up'; upBtn.innerHTML = 'â–²'; upBtn.title = 'TÄƒng 1'; upBtn.style.cssText = arrowStyle;
            const downBtn = document.createElement('button'); downBtn.type = 'button'; downBtn.className = 'arrow-down'; downBtn.innerHTML = 'â–¼'; downBtn.title = 'Giáº£m 1'; downBtn.style.cssText = arrowStyle;

            upBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n + 1;
                if (n > 45) n = 1; // wrap like cell9
                if (n < 1) n = 1;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            downBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n - 1;
                if (n < 1) n = 45; // wrap like cell9
                if (n > 45) n = 45;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            btnGroup.appendChild(upBtn);
            btnGroup.appendChild(downBtn);
            xContainer.appendChild(xFilter);
            xContainer.appendChild(btnGroup);

            // Make the input container draggable like Cell9 inputs: allow dragging-out to clear value
            xContainer.__dropHandled = false;
            let draggedX = false;

            const updateXDraggable = () => {
                const v = String(xFilter.value ?? '').trim();
                const has = v !== '';
                xContainer.draggable = has;
                xContainer.style.cursor = has ? 'grab' : 'default';
                xContainer.style.opacity = has ? '' : '';
            };
            updateXDraggable();
            xFilter.addEventListener('input', () => {
                updateXDraggable();
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            xContainer.addEventListener('dragstart', (e) => {
                draggedX = true;
                xContainer.__dropHandled = false;
                // expose global dragging source so other dynamic drops can swap values
                try { window.__draggingDynamic = { type: 'xFilter', input: xFilter, container: xContainer, value: String(xFilter.value ?? '') }; } catch (err) { }
                xContainer.style.opacity = '0.5';
                try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                e.dataTransfer.setData('text/plain', String(xFilter.value ?? ''));
                // include full place set for richer drops
                try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
            });

            xContainer.addEventListener('dragend', (e) => {
                xContainer.style.opacity = '';
                // If drag ended without a handled drop, clear the input (like Cell9 behavior)
                try { window.__draggingDynamic = null; } catch (err) { }
                if (!xContainer.__dropHandled && draggedX && String(xFilter.value ?? '').trim() !== '') {
                    xFilter.value = '';
                    xFilter.dispatchEvent(new Event('input'));
                    if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                }
                draggedX = false;
                xContainer.__dropHandled = false;
            });

            // Accept drags from number picker popup (single number, place index or place set)
            xContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { }
                xContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
            });
            xContainer.addEventListener('dragleave', () => {
                xContainer.style.backgroundColor = '';
            });
            xContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                xContainer.style.backgroundColor = '';
                xContainer.__dropHandled = true;
                const txt = e.dataTransfer.getData('text/plain');
                const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                const placeSetData = e.dataTransfer.getData('application/x-place-set');
                const labelData = e.dataTransfer.getData('application/x-label');
                let value = null;
                // If dragging from another dynamic input, swap values instead of replacing
                try {
                    if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== xFilter) {
                        const srcInput = window.__draggingDynamic.input;
                        const srcVal = String(srcInput.value ?? '');
                        const tgtVal = String(xFilter.value ?? '');
                        // perform swap
                        srcInput.value = tgtVal;
                        srcInput.dispatchEvent(new Event('input'));
                        xFilter.value = srcVal;
                        xFilter.dispatchEvent(new Event('input'));
                        // mark both containers as handled to avoid clearing on dragend
                        try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                        xContainer.__dropHandled = true;
                        // conclude drop handling
                        try { window.__draggingDynamic = null; } catch (err) { }
                        return;
                    }
                } catch (err) { }
                if (placeIndexData) {
                    const idx = parseInt(placeIndexData, 10);
                    const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                    if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                    // Prefer simple text/plain payloads (single number) over place-set JSON
                    value = txt;
                } else if (placeSetData) {
                    try {
                        const arr = JSON.parse(placeSetData);
                        if (Array.isArray(arr) && arr.length) {
                            // pick first numeric value in the set
                            for (const v of arr) {
                                if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; }
                            }
                        }
                    } catch (err) { }
                } else if (labelData) {
                    value = labelData;
                }

                if (value !== null && value !== undefined) {
                    let n = parseInt(String(value).trim(), 10);
                    if (Number.isFinite(n)) {
                        if (n < 1) n = 1;
                        if (n > 45) n = 45;
                        xFilter.value = String(n);
                        xFilter.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    }
                }
            });

            // Container for extra combo inputs (comb - 1) shown when user selects comb > 1
            const comboExtras = document.createElement('div');
            comboExtras.style.cssText = 'display:flex;gap:6px;align-items:center;margin-left:6px;flex-wrap:wrap;';

            // Build or rebuild the (comb - 1) extra inputs based on xSel
            function rebuildComboExtras(prefill = []) {
                comboExtras.innerHTML = '';
                const comb = parseInt(xSel.value, 10) || 1;
                const count = Math.max(0, comb - 1);
                for (let i = 0; i < count; i++) {
                    // container mimics Cell9 input container with drag handle and up/down buttons
                    const container = document.createElement('div');
                    container.className = 'combo-extra-container';
                    container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;padding:2px;border-radius:8px;border:2px solid #f8f333;background:rgba(248,243,180,0.04);';

                    const inp = document.createElement('input');
                    inp.type = 'number';
                    inp.min = 1; inp.max = 45;
                    inp.placeholder = `v${i + 1}`;
                    inp.className = 'combo-extra';
                    inp.style.cssText = 'width:64px;padding:8px;border-radius:6px;border:0;background:transparent;color:var(--text);box-sizing:border-box;';
                    // prefill if value for this index was provided (preserve when increasing comb)
                    if (prefill && prefill[i] !== undefined && String(prefill[i]).trim() !== '') {
                        const parsed = parseInt(String(prefill[i]).trim(), 10);
                        if (Number.isFinite(parsed)) {
                            const clamped = Math.max(1, Math.min(45, parsed));
                            inp.value = String(clamped);
                        }
                    }

                    // right-side up/down buttons
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = 'â–²'; up.title = 'TÄƒng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = 'â–¼'; down.title = 'Giáº£m 1'; down.style.cssText = arrowStyle;
                    btnGroup.appendChild(up); btnGroup.appendChild(down);

                    // drag handle (visual)
                    const dragHandle = document.createElement('div');
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);pointer-events:none;`;

                    // attach behaviors
                    container.__dropHandled = false;
                    container.__dragging = false;

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const has = v !== '';
                        container.draggable = has;
                        dragHandle.style.pointerEvents = has ? 'auto' : 'none';
                        dragHandle.style.cursor = has ? 'grab' : 'default';
                        // Always show yellow border even when empty
                        container.style.borderColor = '#f8f333';
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1; if (n > 45) n = 1; if (n < 1) n = 1;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1; if (n < 1) n = 45; if (n > 45) n = 45;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.addEventListener('dragstart', (e) => {
                        container.__dragging = true; container.__dropHandled = false;
                        container.style.opacity = '0.5';
                        try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                        e.dataTransfer.setData('text/plain', String(inp.value ?? ''));
                        try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                        // expose global dragging source so other dynamic drops can swap values
                        try { window.__draggingDynamic = { type: 'combo-extra', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    });
                    container.addEventListener('dragend', () => {
                        container.style.opacity = '';
                        try { window.__draggingDynamic = null; } catch (err) { }
                        if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                            inp.value = '';
                            inp.dispatchEvent(new Event('input'));
                            if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                        }
                        container.__dragging = false; container.__dropHandled = false; updateDraggable();
                    });

                    container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(248,243,180,0.06)'; });
                    container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                    container.addEventListener('drop', (e) => {
                        e.preventDefault(); container.style.backgroundColor = '';
                        container.__dropHandled = true;
                        const txt = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        let value = null;
                        // If dragging from another dynamic input, swap values instead of replacing
                        try {
                            if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                                const srcInput = window.__draggingDynamic.input;
                                const srcVal = String(srcInput.value ?? '');
                                const tgtVal = String(inp.value ?? '');
                                // perform swap
                                srcInput.value = tgtVal;
                                srcInput.dispatchEvent(new Event('input'));
                                inp.value = srcVal;
                                inp.dispatchEvent(new Event('input'));
                                // mark both containers as handled to avoid clearing on dragend
                                try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                                container.__dropHandled = true;
                                try { window.__draggingDynamic = null; } catch (err) { }
                                return;
                            }
                        } catch (err) { }

                        if (placeIndexData) {
                            const idx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                        } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                            value = txt;
                        } else if (placeSetData) {
                            try { const arr = JSON.parse(placeSetData); if (Array.isArray(arr) && arr.length) { for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } } } } catch (err) { }
                        } else if (labelData) { value = labelData; }

                        if (value !== null && value !== undefined) {
                            let n = parseInt(String(value).trim(), 10);
                            if (Number.isFinite(n)) {
                                if (n < 1) n = 1; if (n > 45) n = 45;
                                inp.value = String(n); inp.dispatchEvent(new Event('input'));
                                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                            }
                        }
                    });

                    inp.addEventListener('input', () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') { updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        if (n < 1) n = 1; if (n > 45) n = 45; inp.value = String(n);
                        updateDraggable();
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = String(i);
                    comboExtras.appendChild(container);
                    updateDraggable();
                }

                // attach left/right arrow navigation matching Cell9
                const containersList = Array.from(comboExtras.querySelectorAll('.combo-extra-container'));
                const navOrder = containersList.map(c => parseInt(c.dataset.index, 10));
                const inputsList = Array.from(comboExtras.querySelectorAll('input.combo-extra'));
                inputsList.forEach((inp, logicalIdx) => {
                    inp.onkeydown = (e) => {
                        if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                        e.preventDefault();
                        const pos = navOrder.indexOf(logicalIdx);
                        if (pos === -1) return;
                        const nextPos = e.key === 'ArrowLeft'
                            ? (pos > 0 ? pos - 1 : navOrder.length - 1)
                            : (pos < navOrder.length - 1 ? pos + 1 : 0);
                        const targetIdx = navOrder[nextPos];
                        inputsList[targetIdx]?.focus();
                    };
                });
            }

            // rebuild extras when comb selection changes
            xSel.addEventListener('change', () => {
                const newComb = parseInt(xSel.value, 10) || 1;
                const oldCount = Math.max(0, prevComb - 1);
                const newCount = Math.max(0, newComb - 1);
                if (newCount >= oldCount) {
                    // preserve existing values when increasing or same size
                    const existing = Array.from(comboExtras.querySelectorAll('input[type="number"].combo-extra')).map(i => i.value ?? '');
                    rebuildComboExtras(existing);
                    // dispatch input for preserved values to trigger any UI updates
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => { if ((inp.value ?? '').trim() !== '') inp.dispatchEvent(new Event('input')); });
                } else {
                    // shrinking: rebuild and clear extras
                    rebuildComboExtras([]);
                }
                prevComb = newComb;
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            // initial build
            rebuildComboExtras();

            controls.append("Sá»‘ x:", xContainer, comboExtras, "Bá»™ sá»‘:", xSel, consecLabel, orderLabel, "Sáº¯p xáº¿p:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            // baseline (unfiltered) groups for current comb/settings
            let baselineArrAll = null;
            let isComputing = false;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }

                // include extra combo inputs values in cache key so changing them invalidates cache
                const extraValsKey = (() => {
                    const inputs = comboExtras.querySelectorAll('input[type="number"].combo-extra');
                    return Array.from(inputs).map(i => (i.value ?? '').trim()).join(',');
                })();
                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${xFilter.value}|${extraValsKey}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return;
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>Äang xá»­ lÃ½ (trÃªn background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    // apply main x filter first (if provided) so baseline is the set of combos containing x
                    const mainX = parseInt(xFilter.value, 10);
                    if (!Number.isNaN(mainX)) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            return nums.includes(mainX);
                        });
                    }

                    // capture baseline (after main x filter, before dynamic extras)
                    baselineArrAll = arr.slice();
                    // sort baseline according to current sortSel so rank/sum are stable
                    const baselineSort = sortSel.value;
                    if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                    else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                    else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                    else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                    // now apply dynamic extra filters (extras besides mainX)
                    const extras = [];
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                        const v = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isNaN(v)) extras.push(v);
                    });
                    if (extras.length > 0) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            for (const f of extras) if (!nums.includes(f)) return false;
                            return true;
                        });
                    }

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        let arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);
                        // apply main x filter first so baseline reflects combos that include x
                        const mainXw = parseInt(xFilter.value, 10);
                        if (!Number.isNaN(mainXw)) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                return nums.includes(mainXw);
                            });
                        }

                        // capture baseline before applying dynamic extras and sort it the same way
                        baselineArrAll = arr.slice();
                        const baselineSortW = sortSel.value;
                        if (baselineSortW === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                        else if (baselineSortW === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                        else if (baselineSortW === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                        else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                        // now apply dynamic extras (excluding mainX)
                        const extrasW = [];
                        comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                            const v = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isNaN(v)) extrasW.push(v);
                        });
                        if (extrasW.length > 0) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                for (const f of extrasW) if (!nums.includes(f)) return false;
                                return true;
                            });
                        }

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                // Use baselineArrAll (unfiltered) for totals/rank while grid shows filtered arr
                const baselineTotal = (typeof baselineArrAll !== 'undefined' && baselineArrAll && Array.isArray(baselineArrAll)) ? baselineArrAll.length : arr.length;
                // build a readable filter text from xFilter + extras
                const fs = [];
                const mx = parseInt(xFilter.value, 10);
                if (!Number.isNaN(mx)) fs.push(String(mx));
                comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                    const v = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isNaN(v)) fs.push(String(v));
                });
                const filterText = fs.length ? ` â€” lá»c theo Sá»‘ x: {<span class="label-chip highlight">${fs.join(',')}</span>}` : ' â€” lá»c theo Sá»‘ x';

                // determine baseline rank/occ for the first displayed group
                let rankText = '';
                if (arr.length > 0 && baselineArrAll && baselineArrAll.length > 0) {
                    const firstKey = arr[0][0];
                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === firstKey);
                    if (idxInBaseline >= 0) {
                        const occ = baselineArrAll[idxInBaseline][1].length;
                        rankText = ` â€” vá»‹ trÃ­ ${idxInBaseline + 1}/${baselineArrAll.length} (\u00A0${occ} ká»³)`;
                    }
                }

                wrap.innerHTML = `<div class='muted header-summary' style='flex-basis:100%;margin-bottom:8px'>${baselineTotal} nhÃ³m (>=2 ká»³)${filterText}${rankText}</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');
                const headerEl = wrap.querySelector('.header-summary');
                // number of rows per page used by each group's table
                const pageSizeRows = 15;
                const updateHeaderCount = () => {
                    try {
                        // Count one table per group (even if a group's table would paginate)
                        const totalTables = Array.isArray(arr) ? arr.length : 0;
                        // Simplified display: only show group count, filter and total tables
                        headerEl.innerHTML = `${baselineTotal} nhÃ³m (>=2 ká»³)${filterText} â€” Sá»‘ báº£ng (toÃ n bá»™): <span class="euclid-total-pill">${totalTables}</span>`;
                    } catch (e) { /* ignore */ }
                };

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160;
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    // build a display list that respects recency selection; default is 'asc' (old->new)
                    let displayList = (list && list.slice) ? list.slice() : [];
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                    const totalPages = Math.max(1, Math.ceil(displayList.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        inner += `<table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        slice.forEach(r => {
                            const orderedSeq = key.split('-').map(Number);
                            const requireOrder = !!(consec.checked && order && order.checked);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    else euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        if (displayList.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${displayList.length - (page + 1) * pageSizeRows} dÃ²ng ná»¯a</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                // remove braces and split on non-digits
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    // remember current highlights so regenerating the popup can reapply
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        // store the card element that produced these highlights so
                                        // we can clear them when the user hovers a different record
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights even when the mouse leaves the tbody.
                                // Previously we cleared highlights here which made the orange
                                // outline disappear as soon as the cursor left the popup.
                                // Now we keep `window.__popupHighlights` set so highlights
                                // remain until another record hover updates them.
                                // No-op.
                                return;
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    try { updateHeaderCount(); } catch (e) { }
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    try { updateHeaderCount(); } catch (e) { }
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // Prefer baseline values for rank/occurrence when baselineArrAll is available
                        let rankDisplay = `${i + 1}/${totalGroups}`;
                        let occDisplay = `${list.length} ká»³`;
                        if (baselineArrAll && Array.isArray(baselineArrAll)) {
                            const baselineTotal = baselineArrAll.length;
                            const idxInBaseline = baselineArrAll.findIndex(([k]) => k === key);
                            if (idxInBaseline >= 0) {
                                rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                                occDisplay = `${baselineArrAll[idxInBaseline][1].length} ká»³`;
                            } else {
                                // If not found in baseline (unlikely), fall back to filtered values
                                rankDisplay = `${i + 1}/${totalGroups}`;
                                occDisplay = `${list.length} ká»³`;
                            }
                        }

                        // Add rank indicator (baselineRank/baselineTotal) next to the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                            `<span class='badge'>${occDisplay}</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    // refresh header count after building a new chunk
                    try { updateHeaderCount(); } catch (e) { }
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                // After chunked creation completes, scroll viewport to 240px so
                // the `.controls` area and new results are visible. Use a small
                // timeout + rAF to wait for layout/paint to settle.
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try {
                            window.scrollTo({ top: 240, behavior: 'auto' });
                        } catch (e) {
                            try { document.scrollingElement.scrollTop = 240; } catch (err) { }
                        }
                    });
                }, 160);

            }

            const debouncedGroup = createDebounce(group, 300);
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; debouncedGroup(); };
            xSel.onchange = sortSel.onchange = order.onchange = recencySel.onchange = debouncedGroup;
            xFilter.onchange = debouncedGroup;
            if (recencySel) recencySel.onchange = debouncedGroup;
            group();
        }

        // Cell7: reverse query by label pattern (6 chars, _ wildcard)
        function renderCell7() {
            const body = sectionShell("cell8", "Cell8 Â· TÃ¬m kiáº¿m theo Label", "Nháº­p 6 kÃ½ tá»± label (1-6 hoáº·c _) Ä‘á»ƒ tÃ¬m cÃ¡c ká»³ cÃ³ label khá»›p. CÃ³ thá»ƒ kÃ©o tháº£ giá»¯a cÃ¡c vá»‹ trÃ­.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs and add small up/down arrows inside the input on the right
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                // container sized to the input; buttons will be absolutely positioned inside it
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                // small left-side grip so it doesn't cover the whole input and block typing
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // keep input as text to allow wildcard '_', but visually reserve space for buttons
                inp.type = 'text';
                inp.maxLength = 1;
                inp.placeholder = '_';
                inp.size = 1;
                inp.style.width = '70px';
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';
                inp.style.position = 'relative';
                inp.style.zIndex = '1';

                // small vertical arrow buttons inside the input, right-aligned
                const btnGroup = document.createElement('div');
                // absolutely position the buttons so they sit inside the input's right edge
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';

                // make arrows compact so they don't overflow the input border
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';

                const up = document.createElement('button');
                up.type = 'button';
                up.className = 'arrow-up';
                up.innerHTML = 'â–²';
                up.title = 'TÄƒng 1';
                up.style.cssText = arrowStyle;

                const down = document.createElement('button');
                down.type = 'button';
                down.className = 'arrow-down';
                down.innerHTML = 'â–¼';
                down.title = 'Giáº£m 1';
                down.style.cssText = arrowStyle;

                // clamp helper: allow '' and '_' as wildcard, otherwise clamp to [1,6]
                const clampValue = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '' || raw === '_') return;
                    const n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: after 6 -> 1
                    n = n + 1;
                    if (n > 6) n = 1;
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: before 1 -> 6
                    n = n - 1;
                    if (n < 1) n = 6;
                    if (n > 6) n = 6;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '' && v !== '_';
                    container.draggable = hasValue;
                    // only enable pointer events on the small grip (left) so the input remains editable
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    // keep padding and border radius constant so container height doesn't jump
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    // use transparent border when empty to preserve box size, and accent border when filled
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampValue(); updateDraggable(); });
                inp.addEventListener('change', () => { clampValue(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // KÃ©o tá»« báº£ng label C1-C6 trá»±c tiáº¿p tá»« popup
                    if (labelData) {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run();
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                        return;
                    }

                    // Swap vá»›i 1 place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                            const incomingRaw = placeVals[srcIdx];
                            const incoming = incomingRaw && popupMode === 'number' ? getCol(parseInt(incomingRaw, 10)) : incomingRaw;
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Náº¿u kÃ©o cáº£ bá»™ place (6 giÃ¡ trá»‹)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                                for (let i = 0; i < 6; i++) {
                                    const val = values[i];
                                    let col = '';
                                    if (val) {
                                        const numVal = parseInt(val, 10);
                                        col = popupMode === 'number' ? getCol(numVal) : numVal;
                                    }
                                    inputs[i].value = col || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                run();
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                draggedIndex = null;
                                return;
                            }
                        } catch (err) { }
                    }
                    // KÃ©o sá»‘ trá»±c tiáº¿p tá»« popup â†’ chuyá»ƒn sang cá»™t (chá»‰ náº¿u khÃ´ng pháº£i internal drag)
                    if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                        const numVal = parseInt(draggedData, 10);
                        if (numVal >= 1 && numVal <= 45) {
                            const col = getCol(numVal);
                            inputs[idx].value = col || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // HoÃ¡n Ä‘á»•i ná»™i bá»™
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const wrapInputs = document.createElement("div"); wrapInputs.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Label:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            wrapInputs.appendChild(labelText);
            containers.forEach(c => wrapInputs.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', run);
            body.appendChild(wrapInputs);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "XÃ³a"; clearBtn.className = "clear-btn"; wrapInputs.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            wrapInputs.appendChild(hint);
            try { wrapInputs.appendChild(recencySel); } catch (e) { }

            function run() {
                const pattern = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : "_"; }).join("");
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                if (pattern.length !== 6) { wrap.innerHTML = "<div class='error'>Cáº§n 6 kÃ½ tá»±</div>"; return; }
                const records = rows.filter(r => {
                    const label = r.label;
                    for (let i = 0; i < 6; i++) if (pattern[i] !== "_" && pattern[i] !== label[i]) return false;
                    return true;
                });
                if (!records.length) { wrap.innerHTML = "<div class='error'>KhÃ´ng cÃ³ ká»³ nÃ o khá»›p pattern</div>"; return; }
                let display = records.slice();
                if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                let html = `<div class='muted'>${records.length} ká»³</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < display.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>NgÃ y</th><th>Káº¿t quáº£</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    display.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_"
                            ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                            : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
                        ).join(" ");
                        const labelHtml = r.label.split("").map((ch, idx) => pattern[idx] === "_" ? `<span>${ch}</span>` : `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`).join(" ");
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
                // scroll to 240px so the controls sit under header consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        // Cell8: group by same number set size x
        function renderCell8() {
            const body = sectionShell("cell6", "Cell6 Â· Cáº·p phá»• biáº¿n", "Chá»n kÃ­ch thÆ°á»›c bá»™ sá»‘ (1-6), tÃ¹y chá»n liá»n ká», sáº¯p xáº¿p.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `Bá»™ ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liá»n ká»")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Giáº£m dáº§n (sá»‘ ká»³)"], ["count_asc", "TÄƒng dáº§n (sá»‘ ká»³)"], ["value_asc", "TÄƒng dáº§n (giÃ¡ trá»‹)"], ["value_desc", "Giáº£m dáº§n (giÃ¡ trá»‹)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement("select");[["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';
            controls.append("Bá»™ sá»‘:", xSel, consecLabel, orderLabel, "Sáº¯p xáº¿p:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            let isComputing = false;

            // If recency selection changes, clear caches and recompute groups
            if (recencySel) recencySel.addEventListener('change', () => {
                try { cacheKey = null; groupCache = null; } catch (e) { }
                try { group(); } catch (e) { }
            });

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }

                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return; // TrÃ¡nh multiple requests
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>Äang xá»­ lÃ½ (trÃªn background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                // Náº¿u x <= 2 hoáº·c consec=true, tÃ­nh nhanh trÃªn main thread
                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    // Náº¿u x > 2 vÃ  consec=false, dÃ¹ng worker
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        const arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                wrap.innerHTML = `<div class='muted'>${arr.length} nhÃ³m (>=2 ká»³)</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160; // increase because we store per-page
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        // only drop if not currently mounted
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                // Lazy mount/unmount per-card table using viewport observation
                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(list.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        // build a display list that respects recency selection; default is 'asc' (old->new)
                        let displayList = (list && list.slice) ? list.slice() : [];
                        try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        inner += `<table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        slice.forEach(r => {
                            const orderedSeq = key.split('-').map(Number);
                            const requireOrder = !!(consec.checked && order && order.checked);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                // ignore euclid errors, leave parts empty
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            // Let CSS handle centering and fixed width; avoid left-padding with NBSPs
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} dÃ²ng ná»¯a</td></tr>`;
                        inner += `</tbody></table>`;
                        // duplicate pagination controls under the table so users can navigate from bottom
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>â—€</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>â–¶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights until another record hover updates them.
                                return;
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    // attach pagination handlers (attach to both top and bottom controls)
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${list.length} ká»³</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                // scroll to 240px after chunked creation (wait for layout)
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } }
                    });
                }, 160);
            }

            const debouncedGroup = createDebounce(group, 300);
            // enable/disable order checkbox depending on consec
            consec.onchange = () => {
                order.disabled = !consec.checked;
                if (!consec.checked) order.checked = false;
                debouncedGroup();
            };
            xSel.onchange = sortSel.onchange = order.onchange = debouncedGroup;
            group();
        }
        function compareKey(a, b) {
            const pa = a.split("-").map(Number); const pb = b.split("-").map(Number);
            for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; }
            return pa.length - pb.length;
        }
        function findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            if (requireConsecutive) {
                for (let i = 0; i <= nums.length - blockSize; i++) {
                    const block = nums.slice(i, i + blockSize);
                    if (block.length !== blockSize) continue;
                    if (requireOrder && Array.isArray(orderedSeq) && orderedSeq.length === blockSize) {
                        let matches = true;
                        for (let k = 0; k < blockSize; k++) {
                            if (block[k] !== orderedSeq[k]) { matches = false; break; }
                        }
                        if (matches) return Array.from({ length: blockSize }, (_, k) => i + k);
                    } else {
                        if (block.every(v => setValues.has(v)) && new Set(block).size === setValues.size) {
                            return Array.from({ length: blockSize }, (_, k) => i + k);
                        }
                    }
                }
            }
            const positions = [];
            nums.forEach((v, idx) => { if (setValues.has(v)) positions.push(idx); });
            return positions;
        }
        function renderHighlightedNums(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            const positions = findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder);
            const posSet = new Set(positions);
            const html = nums.map((v, idx) => posSet.has(idx)
                ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
            ).join(" ");
            return { html, positions };
        }
        function renderHighlightedLabel(labelStr, highlightPositions) {
            const posSet = new Set(highlightPositions);
            return labelStr.split("").map((ch, idx) => posSet.has(idx)
                ? `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`
                : `<span>${ch}</span>`
            ).join(" ");
        }

        // Helper for main thread combos (same algorithm available inside worker)
        function kCombinations(set, k) {
            const combs = [];
            const n = set.length;
            function pick(start, acc) {
                if (acc.length === k) { combs.push(acc.slice()); return; }
                for (let i = start; i < n; i++) { acc.push(set[i]); pick(i + 1, acc); acc.pop(); }
            }
            pick(0, []);
            return combs;
        }

        // Cell9: draws containing user set
        function renderCell9() {
            const body = sectionShell("cell9", "Cell9 Â· Tá»• há»£p chá»©a bá»™ sá»‘ hoáº·c label", "Chá»n tÃ¬m theo bá»™ sá»‘ (1-45) hoáº·c label (1-6). CÃ³ thá»ƒ kÃ©o tháº£ giá»¯a cÃ¡c vá»‹ trÃ­.");

            // Mode toggle integrated with Number Picker
            const getNumberPickerMode = window.getNumberPickerMode || (() => "number");
            const setNumberPickerMode = window.setNumberPickerMode || (() => { });
            const onNumberPickerModeChange = window.onNumberPickerModeChange || (() => () => { });
            let cell9ModeState = getNumberPickerMode();
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell9ModeState === 'number' ? 'Bá»™ sá»‘ (1-45)' : 'Label (1-6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === "number") {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });
                }
            };

            let inputs = createInputs(cell9ModeState);

            // Create draggable containers for inputs â€” add in-input up/down buttons and consistent sizing
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                    container.draggable = false;

                    // small left-side grip so it doesn't cover the whole input and block typing
                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                    // reserve space on the right for buttons
                    inp.style.position = "relative";
                    inp.style.zIndex = "1";
                    inp.style.paddingRight = '40px';
                    inp.style.boxSizing = 'border-box';

                    // button group inside input, right-aligned
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = 'â–²'; up.title = 'TÄƒng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = 'â–¼'; down.title = 'Giáº£m 1'; down.style.cssText = arrowStyle;

                    // helpers per mode
                    const clampForNumberMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 45) inp.value = '45';
                        else inp.value = String(n);
                    };

                    const clampForLabelMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '' || raw === '_') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 6) inp.value = '6';
                        else inp.value = String(n);
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 45) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 6) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 45; // wrap
                            if (n > 45) n = 45;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 6; // wrap
                            if (n > 6) n = 6;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });

                    btnGroup.appendChild(up);
                    btnGroup.appendChild(down);

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const hasValue = inp.type === 'number' ? v !== '' : (v !== '' && v !== '_');
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                        dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                        container.style.borderRadius = '10px';
                        container.style.padding = '2px';
                        container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                        container.style.opacity = hasValue ? '1' : '0.85';
                    };

                    // attach input handlers depending on mode
                    inp.addEventListener('input', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    inp.addEventListener('change', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    updateDraggable();

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    return container;
                });
            };
            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;


            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    // Track drag-over state to avoid redundant style updates
                    let isDragOverThis = false;

                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        dropHandled = false;
                        container.style.opacity = "0.4";
                        container.style.cursor = "grabbing";
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        container.style.cursor = "grab";
                        // If drop didn't happen (dragged outside), delete the value
                        if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                            inputs[idx].value = "";
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                        }
                        draggedIndex = null;
                        dropHandled = false;
                        isDragOverThis = false;
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";

                        // Only update styles if not already in drag-over state
                        if (!isDragOverThis) {
                            isDragOverThis = true;
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        isDragOverThis = false;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        dropHandled = true;
                        const draggedData = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        isDragOverThis = false;

                        // Swap with a single place box
                        if (placeIndexData !== null && placeIndexData !== '') {
                            const srcIdx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                                const incoming = placeVals[srcIdx];
                                const outgoing = inputs[idx].value;
                                inputs[idx].value = incoming || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                placeVals[srcIdx] = outgoing || '';
                                if (window.setPlaceValues) window.setPlaceValues(placeVals);
                                if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                                if (run) run();
                                draggedIndex = null;
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                return;
                            }
                        }
                        // Accept place set (6 numbers)
                        if (placeSetData) {
                            try {
                                let values = JSON.parse(placeSetData);
                                if (Array.isArray(values) && values.length === 6) {
                                    // In label mode, reverse values to match reversed display
                                    if (cell9ModeState === 'label') {
                                        values = values.reverse();
                                    }
                                    for (let i = 0; i < 6; i++) {
                                        inputs[i].value = values[i] || '';
                                        inputs[i].dispatchEvent(new Event("input"));
                                    }
                                    if (run) run();
                                }
                            } catch (err) { }
                        }
                        // KÃ©o sá»‘/label trá»±c tiáº¿p tá»« popup (chá»‰ náº¿u khÃ´ng pháº£i internal drag)
                        else if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                            const numVal = parseInt(draggedData, 10);
                            if (cell9ModeState === 'number' && numVal >= 1 && numVal <= 45) {
                                inputs[idx].value = numVal;
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            } else if (cell9ModeState === 'label') {
                                const col = getCol(numVal);
                                inputs[idx].value = col || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            }
                        }
                        // KÃ©o label tá»« header popup khi mode = label
                        else if (draggedIndex === null && labelData && cell9ModeState === 'label') {
                            inputs[idx].value = labelData.replace('C', '');
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                            draggedIndex = null;
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            return;
                        }
                        // Otherwise swap
                        else if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            if (run) run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liá»n ká»"));
            const controls = document.createElement("div"); controls.className = "controls";

            // Add mode toggle button
            controls.appendChild(modeBtn);

            const inputLabel = document.createElement("span"); inputLabel.textContent = cell9ModeState === "number" ? "Bá»™ sá»‘:" : "Label:"; inputLabel.style.fontWeight = "700"; inputLabel.style.fontSize = "14px"; inputLabel.style.marginLeft = "12px";
            controls.appendChild(inputLabel);

            // For label mode, reverse the containers for proper left-to-right display
            const containersToAdd = cell9ModeState === "label" ? [...containers].reverse() : containers;
            containersToAdd.forEach(c => controls.appendChild(c));
            controls.append(consecLabel);
            const recencySel = document.createElement('select');[["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "XÃ³a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            try { controls.appendChild(recencySel); } catch (e) { }

            function run() {
                const mode = cell9ModeState;

                if (mode === "number") {
                    const vals = inputs.map(i => parseInt(i.value, 10)).filter(v => !isNaN(v) && v >= 1 && v <= 45);
                    if (!vals.length) { wrap.innerHTML = "<div class='loader'>Äiá»n Ã­t nháº¥t 1 sá»‘...</div>"; return; }
                    const inputFreq = {};
                    vals.forEach(v => { inputFreq[v] = (inputFreq[v] || 0) + 1; });
                    const setVals = new Set(vals);
                    const records = rows.filter(r => {
                        const rowFreq = {};
                        r.nums.forEach(v => { rowFreq[v] = (rowFreq[v] || 0) + 1; });
                        for (const num in inputFreq) {
                            if ((rowFreq[num] || 0) < inputFreq[num]) return false;
                        }
                        if (consec.checked) return hasConsecutiveBlock(r.nums, setVals);
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>KhÃ´ng cÃ³ ká»³ nÃ o phÃ¹ há»£p</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} ká»³</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setVals, setVals.size, consec.checked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                } else {
                    const labels = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : null; }).filter(v => v !== null);
                    if (!labels.length) { wrap.innerHTML = "<div class='loader'>Äiá»n Ã­t nháº¥t 1 kÃ½ tá»±...</div>"; return; }
                    const inputFreq = {};
                    labels.forEach(ch => { inputFreq[ch] = (inputFreq[ch] || 0) + 1; });
                    const totalCount = labels.length;
                    const inputKeys = Object.keys(inputFreq);
                    const keySet = new Set(inputKeys);

                    const records = rows.filter(r => {
                        const labelStr = r.label;
                        const rowFreq = {};
                        for (const ch of labelStr) rowFreq[ch] = (rowFreq[ch] || 0) + 1;
                        for (const ch of inputKeys) {
                            if ((rowFreq[ch] || 0) < inputFreq[ch]) return false;
                        }
                        if (consec.checked) {
                            for (let i = 0; i <= labelStr.length - totalCount; i++) {
                                const block = labelStr.slice(i, i + totalCount);
                                const blockFreq = {};
                                for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                let ok = true;
                                for (const ch of inputKeys) {
                                    if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                }
                                if (ok) return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>KhÃ´ng cÃ³ ká»³ nÃ o phÃ¹ há»£p</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} ká»³</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const labelStr = r.label;
                            let highlightPos = [];
                            if (consec.checked) {
                                let start = -1;
                                for (let s = 0; s <= labelStr.length - totalCount && start === -1; s++) {
                                    const block = labelStr.slice(s, s + totalCount);
                                    const blockFreq = {};
                                    for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                    let ok = true;
                                    for (const ch of inputKeys) {
                                        if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                    }
                                    if (ok) start = s;
                                }
                                if (start !== -1) {
                                    highlightPos = Array.from({ length: totalCount }, (_, k) => start + k);
                                }
                            }
                            if (!highlightPos.length) {
                                for (let pos = 0; pos < labelStr.length; pos++) {
                                    if (keySet.has(labelStr[pos])) highlightPos.push(pos);
                                }
                            }
                            // Create a set of highlighted column numbers from label chars
                            const highlightedLabelChars = new Set(highlightPos.map(pos => labelStr[pos]));
                            // Convert column chars to numbers 1-45 that belong to those columns
                            const highlightedNums = new Set();
                            for (let num = 1; num <= 45; num++) {
                                if (highlightedLabelChars.has(String(getCol(num)))) {
                                    highlightedNums.add(num);
                                }
                            }
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, highlightedNums, totalCount, consec.checked);
                            const labelHtml = renderHighlightedLabel(labelStr, highlightPos);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                }
            }

            const applyCell9Mode = (mode, { notify = true } = {}) => {
                if (mode !== 'number' && mode !== 'label') return;
                if (!notify && cell9ModeState === mode) return;

                cell9ModeState = mode;
                modeBtn.textContent = cell9ModeState === 'number' ? 'Bá»™ sá»‘ (1-45)' : 'Label (1-6)';

                // Clear old drag listeners by removing and recreating containers
                document.querySelectorAll(".drag-input-container").forEach(c => {
                    c.style.opacity = "1";
                    c.style.transform = "";
                });

                inputs = createInputs(mode);
                containers = createContainers(inputs);

                // Reset draggedIndex to prevent stale references
                draggedIndex = null;

                setupDragListeners(containers);
                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                inputLabel.textContent = mode === "number" ? "Bá»™ sá»‘:" : "Label:";

                // Insert containers in visual order (avoid accidental reversal)
                const containersToAdd = mode === "label" ? [...containers].reverse() : containers;
                let anchor = inputLabel;
                containersToAdd.forEach(c => {
                    anchor.parentNode.insertBefore(c, anchor.nextSibling);
                    anchor = c;
                });

                // Navigation based on visual order (containersToAdd defines on-screen order)
                const navOrder = containersToAdd.map(c => parseInt(c.dataset.index, 10));
                const attachKeyHandlers = () => {
                    inputs.forEach((inp, logicalIdx) => {
                        inp.oninput = run;
                        inp.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const pos = navOrder.indexOf(logicalIdx);
                            if (pos === -1) return;
                            const nextPos = e.key === 'ArrowLeft'
                                ? (pos > 0 ? pos - 1 : navOrder.length - 1)
                                : (pos < navOrder.length - 1 ? pos + 1 : 0);
                            const targetIdx = navOrder[nextPos];
                            inputs[targetIdx]?.focus();
                        };
                    });
                };
                attachKeyHandlers();

                if (notify) setNumberPickerMode(mode);
                run();
            };

            // Toggle button click to switch modes and notify popup
            modeBtn.addEventListener('click', () => {
                const next = cell9ModeState === 'number' ? 'label' : 'number';
                applyCell9Mode(next, { notify: false });
            });

            // Initial handlers for first render: use current visual order
            const initialContainers = cell9ModeState === "label" ? [...containers].reverse() : containers;
            const initialNavOrder = initialContainers.map(c => parseInt(c.dataset.index, 10));
            inputs.forEach((inp, logicalIdx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                    e.preventDefault();
                    const pos = initialNavOrder.indexOf(logicalIdx);
                    if (pos === -1) return;
                    const nextPos = e.key === 'ArrowLeft'
                        ? (pos > 0 ? pos - 1 : initialNavOrder.length - 1)
                        : (pos < initialNavOrder.length - 1 ? pos + 1 : 0);
                    const targetIdx = initialNavOrder[nextPos];
                    inputs[targetIdx]?.focus();
                };
            });
            consec.onchange = run; clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function setValsIsSubset(setVals, arr) { for (const v of setVals) if (!arr.includes(v)) return false; return true; }
        function hasConsecutiveBlock(nums, setVals) {
            const k = setVals.size;
            for (let i = 0; i <= nums.length - k; i++) {
                const block = nums.slice(i, i + k);
                if (block.length === k && setValsIsSubset(setVals, block) && new Set(block).size === setVals.size) return true;
            }
            return false;
        }

        // Cell10: analyze other positions given value at order
        function renderCell10() {
            const body = sectionShell("cell10", "Cell10 Â· PhÃ¢n tÃ­ch cÃ¡c vá»‹ trÃ­ khÃ¡c", "Äiá»n 1 giÃ¡ trá»‹ vÃ o 1 Ã´ Ä‘á»ƒ xem phÃ¢n bá»‘ á»Ÿ 5 vá»‹ trÃ­ cÃ²n láº¡i. CÃ³ thá»ƒ kÃ©o tháº£ giá»¯a cÃ¡c vá»‹ trÃ­.");
            // Mode toggle: Number (1â€“45) vs Column (1â€“6)
            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : "number";
            let cell10ModeState = popupMode === "label" ? "column" : "number";
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell10ModeState === 'number' ? 'Sá»‘ (1â€“45)' : 'Cá»™t (1â€“6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // per-input scroll memory and last active index for cell10
            window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
            window._cell10LastIndex = window._cell10LastIndex ?? null;

            // Create draggable containers for inputs â€” add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = 'â–²'; up.title = 'TÄƒng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = 'â–¼'; down.title = 'Giáº£m 1'; down.style.cssText = arrowStyle;

                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };
                const clampForColumn = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 45) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 6) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 45;
                        if (n > 45) n = 45;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 6;
                        if (n > 6) n = 6;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                inp.addEventListener('change', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            if (run) run(idx);
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run(0);
                            }
                        } catch (err) { }
                    }
                    // KÃ©o sá»‘ trá»±c tiáº¿p tá»« popup (chá»‰ náº¿u khÃ´ng pháº£i internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (cell10ModeState === 'number' && num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        } else if (cell10ModeState === 'column' && num >= 1 && num <= 45) {
                            const col = getCol(num);
                            inputs[idx].value = col;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // KÃ©o label tá»« header popup khi mode = column
                    else if (draggedIndex === null && labelData && cell10ModeState === 'column') {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run(idx);
                        draggedIndex = null;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        return;
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        if (run) run(idx);
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            // Add mode toggle button
            controls.append(modeBtn);
            containers.forEach(c => controls.appendChild(c)); body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "XÃ³a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run(changeIdx) {
                const prevScroll = window.scrollY;
                try {
                    if (changeIdx !== undefined && changeIdx !== null) {
                        window._cell10LastIndex = changeIdx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(changeIdx, prevScroll);
                    }
                } catch (e) { }

                const filled = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).filter(x => !isNaN(x.val));
                if (filled.length > 1 && changeIdx !== undefined) {
                    filled.filter(f => f.idx !== changeIdx).forEach(f => {
                        inputs[f.idx].value = "";
                        // Refresh drag visuals when value is cleared programmatically
                        inputs[f.idx].dispatchEvent(new Event("input"));
                    });
                }
                const single = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).find(x => !isNaN(x.val));
                if (!single) {
                    wrap.innerHTML = cell10ModeState === "number"
                        ? "<div class='loader'>Äiá»n 1 sá»‘ (1â€“45) vÃ o 1 Ã´...</div>"
                        : "<div class='loader'>Äiá»n 1 cá»™t (1â€“6) vÃ o 1 Ã´...</div>";
                    // restore scroll for same-input edits
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const order = single.idx + 1; const value = single.val;
                const posCols = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] }; const posMaps = { 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {} };
                let total = 0, hit = 0;
                const selectedPosNumbers = []; // Collect numbers at selected position for column mode
                rows.forEach(r => {
                    if (r.nums.length !== 6) return; total++;
                    const matched = (cell10ModeState === "number") ? (r.nums[order - 1] === value) : (getCol(r.nums[order - 1]) === value);
                    if (!matched) return; hit++;
                    if (cell10ModeState === "column") selectedPosNumbers.push(r.nums[order - 1]);
                    for (let pos = 1; pos <= 6; pos++) { if (pos === order) continue; const v = r.nums[pos - 1]; const c = getCol(v); posCols[pos].push(c); (posMaps[pos][c] ||= []).push(v); }
                });
                if (!hit) {
                    const what = cell10ModeState === "number" ? value : `cá»™t ${value}`;
                    wrap.innerHTML = `<div class='error'>KhÃ´ng cÃ³ ká»³ nÃ o vá»›i ${what} á»Ÿ vá»‹ trÃ­ ${order}</div>`;
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const pattern = Array(6).fill("_"); pattern[order - 1] = (cell10ModeState === "number") ? value : `C${value}`;
                let html = `<div class='muted'>${hit}/${total} ká»³ (${(hit / total * 100).toFixed(2)}%) Â· Pattern: ${pattern.join(',')}</div>`;

                // Show numbers at selected position for column mode
                if (cell10ModeState === "column" && selectedPosNumbers.length > 0) {
                    const numCounts = countMap(selectedPosNumbers);
                    const numsHtml = Object.entries(numCounts).sort((a, b) => b[1] - a[1]).map(([num, count]) =>
                        `<strong>${num}</strong><span style='font-weight:400'>(${count})</span>`
                    ).join(', ');
                    html += `<div style='margin-top:8px;font-weight:700;color:var(--text-strong);'>${numsHtml}</div>`;
                }

                const positionsBefore = [1, 2, 3, 4, 5, 6].filter(p => p < order);
                const positionsAfter = [1, 2, 3, 4, 5, 6].filter(p => p > order);
                const renderPosTable = (pos) => {
                    const counts = countMap(posCols[pos]);
                    let rowsHtml = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([c, n]) => {
                        const vals = countMap(posMaps[pos][c] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        return `<tr><td style='font-weight:700'>Cá»™t ${c}</td><td style='text-align:right;font-weight:700'>${n}</td><td style='text-align:right;font-weight:700'>${fmtPct(n / posCols[pos].length)}</td><td style='font-weight:700'>${valsHtml || 'â€”'}</td></tr>`;
                    }).join("");
                    return `<div class='card'><h4>Vá»‹ trÃ­ ${pos}</h4><table><thead><tr><th>Cá»™t</th><th>Sá»‘ láº§n</th><th>Tá»· lá»‡</th><th>Sá»‘ hay Ä‘i cÃ¹ng</th></tr></thead><tbody>${rowsHtml}</tbody></table></div>`;
                };
                // Column-mode: compact 4-column table (Column | Count | Percentage | Numbers), 6 rows ranked
                const renderPosTableColumn = (pos) => {
                    const counts = countMap(posCols[pos]);
                    const totalPos = posCols[pos].length || 1;
                    const items = [1, 2, 3, 4, 5, 6].map(c => ({ col: c, count: counts[c] || 0, pct: (counts[c] || 0) / totalPos }));
                    items.sort((a, b) => b.count - a.count || a.col - b.col);
                    // Ensure each card is at most 1/3 of the row and centered
                    let t = `<div class='card' style='flex:0 1 calc(33.333% - 10px);'><h4 style='margin:0 0 8px;'>Vá»‹ trÃ­ ${pos}</h4><table><thead><tr><th>Cá»™t</th><th>Sá»‘ láº§n</th><th>Tá»· lá»‡</th><th>Sá»‘ hay xuáº¥t hiá»‡n</th></tr></thead><tbody>`;
                    items.forEach((it, idx) => {
                        const vals = countMap(posMaps[pos][it.col] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        t += `<tr><td style='font-weight:700'>${it.col}</td><td style='text-align:right;font-weight:700'>${it.count}</td><td style='text-align:right;font-weight:700'>${fmtPct(it.pct)}</td><td style='font-weight:700'>${valsHtml || 'â€”'}</td></tr>`;
                    });
                    t += "</tbody></table></div>";
                    return t;
                };
                if (positionsBefore.length) html += `<h4>Vá»‹ trÃ­ trÆ°á»›c</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsBefore.map(renderPosTable) : positionsBefore.map(renderPosTableColumn)).join('')}</div>`;
                if (positionsAfter.length) html += `<h4>Vá»‹ trÃ­ sau</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsAfter.map(renderPosTable) : positionsAfter.map(renderPosTableColumn)).join('')}</div>`;
                wrap.innerHTML = html;
                // restore scroll for same-input edits (prevent jump-to-top)
                if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                    // small timeout to let layout settle
                    setTimeout(() => window.scrollTo(0, prevScroll), 0);
                }
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
                inp.addEventListener('focus', () => {
                    try {
                        window._cell10LastIndex = idx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(idx, window.scrollY);
                    } catch (e) { }
                });
            });
            clearBtn.onclick = () => {
                inputs.forEach(i => {
                    i.value = "";
                    // Refresh drag visuals after clear
                    i.dispatchEvent(new Event("input"));
                });
                run();
            };
            // Toggle button: adjust constraints, notify popup, clear values, rerun
            modeBtn.addEventListener('click', () => {
                cell10ModeState = cell10ModeState === 'number' ? 'column' : 'number';
                modeBtn.textContent = cell10ModeState === 'number' ? 'Sá»‘ (1â€“45)' : 'Cá»™t (1â€“6)';
                const newPopupMode = cell10ModeState === 'column' ? 'label' : 'number';
                if (window.setNumberPickerMode) window.setNumberPickerMode(newPopupMode);
                inputs.forEach(inp => {
                    if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                    else { inp.min = 1; inp.max = 6; inp.placeholder = '1â€“6'; }
                    inp.value = '';
                    inp.dispatchEvent(new Event('input'));
                });
                run();
            });
            // Subscribe to external mode changes
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    cell10ModeState = mode === 'label' ? 'column' : 'number';
                    modeBtn.textContent = cell10ModeState === 'number' ? 'Sá»‘ (1â€“45)' : 'Cá»™t (1â€“6)';
                    inputs.forEach(inp => {
                        if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                        else { inp.min = 1; inp.max = 6; inp.placeholder = '1â€“6'; }
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                    });
                    run();
                });
            }
            run();
        }
        function countMap(arr) { const m = {}; arr.forEach(v => m[v] = (m[v] || 0) + 1); return m; }

        // Cell11: pattern search 6 positions with commas, _ wildcard
        function renderCell11() {
            const body = sectionShell("cell11", "Cell11 Â· TÃ¬m ká»³ theo Pattern sá»‘", "Nháº­p sá»‘ (1-45) vÃ o tá»«ng vá»‹ trÃ­ Ä‘á»ƒ tÃ¬m ká»³ khá»›p. CÃ³ thá»ƒ kÃ©o tháº£ sá»‘ giá»¯a cÃ¡c vá»‹ trÃ­ báº±ng chuá»™t. Bá» trá»‘ng vá»‹ trÃ­ nÃ o thÃ¬ vá»‹ trÃ­ Ä‘Ã³ cháº¥p nháº­n sá»‘ báº¥t ká»³.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs â€” add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                // small left-side grip so it doesn't cover the whole input and block typing
                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = 'â–²'; up.title = 'TÄƒng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = 'â–¼'; down.title = 'Giáº£m 1'; down.style.cssText = arrowStyle;

                // clamp to [1,45]
                const clampNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    if (n > 45) n = 45;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampNumber(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run();
                            }
                        } catch (err) { }
                    }
                    // KÃ©o sá»‘ trá»±c tiáº¿p tá»« popup (chá»‰ náº¿u khÃ´ng pháº£i internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Pattern:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            controls.appendChild(labelText);
            containers.forEach(c => controls.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Má»›i â†’ CÅ©"], ["asc", "CÅ© â†’ Má»›i"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });
            body.appendChild(controls);

            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "XÃ³a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            // Add hint text
            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            // place recency select at end of controls
            controls.appendChild(recencySel);

            function run(changeIdx) {
                const pattern = inputs.map(inp => {
                    const v = inp.value.trim();
                    if (!v) return "_";
                    const n = parseInt(v, 10);
                    return (n >= 1 && n <= 45) ? String(n) : "_";
                });
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>ChÆ°a cÃ³ dá»¯ liá»‡u</div>"; return; }
                if (pattern.every(p => p === "_")) { wrap.innerHTML = "<div class='loader'>Nháº­p vÃ o 1 Ã´ Ä‘á»ƒ tÃ¬m kiáº¿m...</div>"; return; }
                const results = rows.filter(r => pattern.every((p, i) => p === "_" || r.nums[i] === Number(p)));
                if (!results.length) { wrap.innerHTML = "<div class='error'>KhÃ´ng cÃ³ ká»³ nÃ o khá»›p pattern</div>"; return; }
                const patternStr = pattern.join(',');
                let display = results.slice();
                if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                let html = `<div class='muted'>${results.length} ká»³ Â· pattern ${patternStr}</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < display.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>NgÃ y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    display.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_" ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        const highlightPositions = pattern.map((p, i) => p === "_" ? -1 : i).filter(i => i >= 0);
                        const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        async function bootstrap() {
            // Number picker popup
            const htmlBadge = document.getElementById('htmlBadge');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');
            const placesGrid = document.getElementById('placesGrid');
            let isPopupVisible = false;

            // Place state: [value1, value2, value3, value4, value5, value6]
            const placeValues = ['', '', '', '', '', ''];
            let draggedNumber = null;
            let draggedPlaceIndex = null;
            let draggedPlaceValue = null;
            let lastDropInsidePlace = false; // track if a place drag was dropped back into place
            let currentMode = 'number'; // 'number' or 'label'
            const modeListeners = new Set();

            const notifyModeChange = (mode, source) => {
                modeListeners.forEach(fn => fn(mode, source));
            };

            const setNumberPickerMode = (mode, source = 'picker') => {
                if (mode !== 'number' && mode !== 'label') return;
                if (currentMode === mode) return;
                currentMode = mode;
                modeSelector.value = mode;
                // Clear place values when switching mode
                placeValues.fill('');
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                notifyModeChange(mode, source);

                // Update connection toggle state when mode changes
                if (window.updateConnectionToggleState) {
                    window.updateConnectionToggleState();
                }

                // Update label cell styling based on new mode and place values
                updateLabelCellStyles();
            };

            window.setNumberPickerMode = (mode) => setNumberPickerMode(mode, 'external');
            window.getNumberPickerMode = () => currentMode;
            window.onNumberPickerModeChange = (cb) => {
                modeListeners.add(cb);
                return () => modeListeners.delete(cb);
            };

            // Quick-place toggle: two modes -> 'normal' (default) and 'hover' (hover a record to fill places)
            const quickPlaceToggleEl = document.getElementById('quickPlaceToggle');
            let quickPlaceMode = localStorage.getItem('quickPlaceMode') || 'normal';
            const setQuickPlaceMode = (mode) => {
                quickPlaceMode = mode === 'hover' ? 'hover' : 'normal';
                if (quickPlaceToggleEl) {
                    quickPlaceToggleEl.textContent = quickPlaceMode === 'normal' ? 'Normal' : 'Hover';
                    quickPlaceToggleEl.title = quickPlaceMode === 'normal'
                        ? "Normal: dblclick copies record to clipboard (existing behavior)"
                        : "Hover: hovering a record fills the place boxes (dblclick-copy disabled)";
                }
                localStorage.setItem('quickPlaceMode', quickPlaceMode);
            };
            window.getQuickPlaceMode = () => quickPlaceMode;
            // initialize
            setQuickPlaceMode(quickPlaceMode);
            if (quickPlaceToggleEl) {
                quickPlaceToggleEl.addEventListener('click', () => {
                    setQuickPlaceMode(quickPlaceMode === 'normal' ? 'hover' : 'normal');
                });
            }

            // Hover handler: when in 'hover' mode, moving mouse over any record row (tr[data-result])
            // will populate the placeValues and refresh place boxes. Throttled to avoid excessive updates.
            const hoverToPlaceHandler = createThrottle((e) => {
                try {
                    if (quickPlaceMode !== 'hover') return;
                    const tr = e.target.closest && e.target.closest('tr[data-result]');
                    if (!tr) return;
                    const text = tr.dataset.result;
                    if (!text) return;
                    const arr = text.split(',').map(s => (s || '').trim());
                    if (arr.length !== 6) return;

                    // Normalize and compare to avoid unnecessary work
                    let identical = true;
                    for (let i = 0; i < 6; i++) {
                        const v = arr[i] || '';
                        if ((placeValues[i] || '') !== v) { identical = false; break; }
                    }
                    if (identical) return;

                    // Clear previous visual highlights and overlays first to avoid stale backgrounds
                    try {
                        if (numberPickerTable) {
                            const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                            prev.forEach(p => p.classList.remove('selected-number'));
                            const disabledCells = numberPickerTable.querySelectorAll('td.number-cell.disabled');
                            disabledCells.forEach(c => c.classList.remove('selected-number'));
                        }
                        const existingOverlays = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                        existingOverlays.forEach(n => n.remove());
                        const placeBoxes = placesGrid.querySelectorAll('.place-box');
                        placeBoxes.forEach(pb => {
                            pb.classList.remove('filled');
                            const val = pb.querySelector('.place-box-value');
                            if (val) val.textContent = '_';
                            pb.style.removeProperty('backgroundColor');
                            pb.style.removeProperty('borderColor');
                        });
                    } catch (err) { /* ignore visual cleanup errors */ }

                    // Apply hovered values (replace all previous values)
                    for (let i = 0; i < 6; i++) placeValues[i] = arr[i] || '';

                    // Re-render and sync highlights/connections
                    generateNumberPickerTable();
                    generatePlaceBoxes();
                    try { if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights(); } catch (e) { }
                    drawConnections();
                } catch (err) { /* ignore */ }
            }, 80);
            document.addEventListener('mousemove', hoverToPlaceHandler, true);

            // Popup scale state
            const popupScaleState = { scale: 1.0 };

            const savePopupScale = () => {
                localStorage.setItem('popupScale', JSON.stringify(popupScaleState.scale));
            };

            const loadPopupScale = () => {
                const saved = localStorage.getItem('popupScale');
                if (saved) {
                    popupScaleState.scale = parseFloat(saved);
                }
            };

            const applyPopupScale = () => {
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
            };

            const applyPopupScaleInstant = () => {
                // Apply scale instantly without transition animation
                const oldTransition = numberPickerPopup.style.transition;
                numberPickerPopup.style.transition = 'none';
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
                // Force browser to process the change
                void numberPickerPopup.offsetHeight;
                numberPickerPopup.style.transition = oldTransition;
            };

            const addPopupScaleHandle = () => {
                let handle = numberPickerPopup.querySelector('.popup-scale-handle');
                if (handle) handle.remove();

                handle = document.createElement('div');
                handle.className = 'popup-scale-handle';

                let isScaling = false;
                let startX = 0;
                let startScale = popupScaleState.scale;

                handle.addEventListener('mousedown', (e) => {
                    isScaling = true;
                    startX = e.clientX;
                    startScale = popupScaleState.scale;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScaling) return;
                    const diff = e.clientX - startX;
                    const newScale = Math.max(0.5, Math.min(2, startScale + diff * 0.0025));
                    popupScaleState.scale = parseFloat(newScale.toFixed(3));
                    applyPopupScale();
                });

                document.addEventListener('mouseup', () => {
                    if (isScaling) {
                        isScaling = false;
                        savePopupScale();
                    }
                });

                numberPickerPopup.appendChild(handle);
            };

            loadPopupScale();

            // Generate number picker table (rotated 90Â° counter-clockwise)
            function generateNumberPickerTable() {
                const numbersInPlace = currentMode === 'number'
                    ? new Set(placeValues.filter(v => v && v.trim() && !isNaN(v)))
                    : new Set();

                const numbersByCol = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
                for (let i = 1; i <= 45; i++) {
                    const col = getCol(i);
                    numbersByCol[col].push(i);
                }

                const tbodyDisabled = currentMode === 'label' ? ' class="disabled"' : '';
                const tfootDisabled = currentMode === 'number' ? ' class="disabled"' : '';

                let html = `<tbody${tbodyDisabled}>`;
                for (let row = 7; row >= 0; row--) {
                    html += '<tr>';
                    for (let col = 1; col <= 6; col++) {
                        const nums = numbersByCol[col];
                        const num = nums[row] || '_';
                        if (num === '_') {
                            html += `<td style="color:var(--muted);opacity:0.5;">_</td>`;
                        } else {
                            const isDisabled = numbersInPlace.has(String(num));
                            const disabledClass = isDisabled ? ' disabled' : '';
                            const draggable = (isDisabled || currentMode === 'label') ? 'false' : 'true';
                            // Check rank toggle; when enabled, show [#x] inside the same cell, left-aligned,
                            // while keeping the number centered.
                            const rankToggleEl = document.getElementById('rankToggle');
                            const rankEnabled = !!rankToggleEl && rankToggleEl.textContent.trim() === 'rank';
                            if (rankEnabled) {
                                const rankMap = window.rankByTotal || {};
                                const r = rankMap[num] ?? '';
                                // Only render badge when we have a rank value
                                let badgeHtml = '';
                                if (r !== '' && r !== null && r !== undefined) {
                                    const rankNum = Number(r);
                                    let color = 'var(--muted)';
                                    if (!isNaN(rankNum)) {
                                        if (rankNum >= 1 && rankNum <= 9) color = '#08eb56';
                                        else if (rankNum >= 10 && rankNum <= 18) color = '#00E5FF';
                                        else if (rankNum >= 19 && rankNum <= 27) color = '#1a62ea';
                                        else if (rankNum >= 28 && rankNum <= 36) color = '#ea3ade';
                                        else if (rankNum >= 37 && rankNum <= 45) color = '#ea0313';
                                    }
                                    badgeHtml = `<span class="rank-in-cell" style="position:absolute;left:6px;top:50%;transform:translateY(-50%);font-size:0.92em;font-weight:900;color:${color};background:transparent;opacity:1;z-index:2;-webkit-text-stroke:0.4px rgba(0,0,0,0.6);text-shadow:0 0 1px rgba(0,0,0,0.22);letter-spacing:0.6px;">#${rankNum}</span>`;
                                }
                                html += `<td class="number-cell${disabledClass}" draggable="${draggable}" data-number="${num}" style="position:relative;min-height:44px;">` +
                                    `${badgeHtml}` +
                                    `<span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span>` +
                                    `</td>`;
                            } else {
                                html += `<td class="number-cell${disabledClass}" draggable="${draggable}" data-number="${num}"><span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span></td>`;
                            }
                        }
                    }
                    html += '</tr>';
                }
                html += '</tbody>';

                html += `<tfoot${tfootDisabled}><tr>`;
                for (let col = 1; col <= 6; col++) {
                    html += `<th class="label-cell" data-label="C${col}" draggable="true" style="cursor: grab;">C${col}</th>`;
                }
                html += '</tr></tfoot>';

                numberPickerTable.innerHTML = html;
                // If there is an active hover-driven highlight set, reapply after regeneration
                try {
                    if (window.__popupHighlights && Array.isArray(window.__popupHighlights) && window.__popupHighlights.length) {
                        applyPopupHighlights(window.__popupHighlights);
                    }
                } catch (e) { /* ignore */ }

                // Draw connections after table is rendered
                requestAnimationFrame(() => drawConnections());
            }

            // Draw connections between consecutive numbers in place boxes
            function drawConnections() {
                const connectionToggle = document.getElementById('connectionToggle');
                const connectionsEnabled = !!connectionToggle && connectionToggle.textContent.trim() === 'Hiá»‡n';
                const euclidToggle = document.getElementById('euclidToggle');
                const euclidEnabled = !!euclidToggle && euclidToggle.textContent.trim() === 'Hiá»‡n';
                // Only draw in number mode and when connections are enabled
                if (currentMode !== 'number' || !connectionsEnabled) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Find consecutive pairs in placeValues
                const pairs = [];
                for (let i = 0; i < placeValues.length - 1; i++) {
                    const curr = placeValues[i];
                    const next = placeValues[i + 1];
                    if (curr && curr.trim() && !isNaN(curr) && next && next.trim() && !isNaN(next)) {
                        pairs.push([parseInt(curr, 10), parseInt(next, 10)]);
                    }
                }

                if (pairs.length === 0) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Get or create canvas
                let canvas = document.getElementById('connectionCanvas');
                const wrapper = numberPickerTable.parentElement;

                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.id = 'connectionCanvas';
                    canvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:1';
                    wrapper.appendChild(canvas);
                }

                const tableRect = numberPickerTable.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();

                // Get current popup scale
                const scale = popupScaleState.scale;

                // Get device pixel ratio for sharp rendering
                const dpr = window.devicePixelRatio || 1;

                // Canvas should match unscaled table size (divide by scale)
                const canvasWidth = tableRect.width / scale;
                const canvasHeight = tableRect.height / scale;

                // Set canvas display size (CSS pixels, unscaled)
                canvas.style.width = canvasWidth + 'px';
                canvas.style.height = canvasHeight + 'px';

                // Set canvas actual size (device pixels)
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;

                // Position canvas to align with table within wrapper (unscaled coordinates)
                canvas.style.left = '0px';
                canvas.style.top = '0px';

                const ctx = canvas.getContext('2d');
                // Scale context to match device pixel ratio
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Store circle centers for line drawing
                const circleCenters = {};
                const circleRadius = 9;

                // Theme-aware colors
                const cssVars = getComputedStyle(document.documentElement);
                const lineColor = (cssVars.getPropertyValue('--connection-line-color') || '#00cc00').trim();
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const circleColor = currentTheme === 'light' ? lineColor : '#667eea';

                // Draw circles around all numbers in placeValues
                const allNumbers = placeValues
                    .filter(v => v && v.trim() && !isNaN(v))
                    .map(v => parseInt(v, 10));

                allNumbers.forEach(num => {
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (!cell) return;

                    const cellRect = cell.getBoundingClientRect();

                    // Apply scale factor to coordinates
                    const x = (cellRect.left - tableRect.left) / scale + (cellRect.width / scale) / 2;
                    const y = (cellRect.top - tableRect.top) / scale + (cellRect.height / scale) / 2;

                    // Store center for line drawing
                    circleCenters[num] = { x, y };

                    // Draw circle (stroke, not fill)
                    ctx.strokeStyle = circleColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                // Draw lines between consecutive pairs, starting from circle edge
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);

                pairs.forEach(([num1, num2]) => {
                    const center1 = circleCenters[num1];
                    const center2 = circleCenters[num2];
                    if (!center1 || !center2) return;

                    const x1 = center1.x;
                    const y1 = center1.y;
                    const x2 = center2.x;
                    const y2 = center2.y;

                    // Calculate angle from center1 to center2
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    // Start line from the edge of circle1, pointing toward circle2
                    const startX = x1 + circleRadius * Math.cos(angle);
                    const startY = y1 + circleRadius * Math.sin(angle);

                    // End line at the edge of circle2, pointing back toward circle1
                    const endX = x2 - circleRadius * Math.cos(angle);
                    const endY = y2 - circleRadius * Math.sin(angle);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // --- Draw Euclidean distance (in grid cell units) near the middle of the line ---
                    try {
                        // Find grid row/col indices by inspecting tbody rows and cell positions
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${num1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${num2}"]`);
                        if (cell1 && cell2 && tbodyRows.length > 0) {
                            const rowElem1 = cell1.parentElement;
                            const rowElem2 = cell2.parentElement;
                            const rowIdx1 = tbodyRows.indexOf(rowElem1); // 0..n-1 (top -> bottom)
                            const rowIdx2 = tbodyRows.indexOf(rowElem2);

                            // In generator rows are created from row=7 down to 0, so logicalRow = 7 - rowIndex
                            const logicalRow1 = 7 - rowIdx1;
                            const logicalRow2 = 7 - rowIdx2;

                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1); // 0..5 left->right
                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);

                            const dx = colIdx2 - colIdx1;
                            const dy = logicalRow2 - logicalRow1;
                            const gridDistance = Math.sqrt(dx * dx + dy * dy);

                            // Midpoint of drawn segment
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;

                            // Place label directly on the line midpoint (overlay the connection)
                            const labelX = midX;
                            const labelY = midY;

                            // Draw label background for readability (only when euclid toggle enabled)
                            if (euclidEnabled) {
                                const labelText = gridDistance.toFixed(2);
                                ctx.save();
                                ctx.setLineDash([]);
                                ctx.font = '12px Inter, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                // measure
                                const metrics = ctx.measureText(labelText);
                                const paddingX = 6;
                                const paddingY = 3;
                                const rectW = metrics.width + paddingX * 2;
                                const rectH = 12 + paddingY * 2;

                                // Semi-transparent background
                                ctx.fillStyle = currentTheme === 'light' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.7)';
                                ctx.beginPath();
                                ctx.roundRect
                                    ? ctx.roundRect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH, 4)
                                    : ctx.rect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH);
                                ctx.fill();

                                // Draw text
                                ctx.fillStyle = currentTheme === 'light' ? '#000' : '#fff';
                                ctx.fillText(labelText, labelX, labelY);
                                ctx.restore();
                            }
                        }
                    } catch (e) {
                        // ignore label drawing errors to avoid breaking connections
                    }
                });
            }

            // Generate place boxes - 6 individual boxes
            function generatePlaceBoxes() {
                placesGrid.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const placeBox = document.createElement('div');
                    placeBox.className = `place-box ${placeValues[i] ? 'filled' : ''}`;
                    placeBox.dataset.placeIndex = i;
                    // Always allow dragging so an empty slot can receive a swapped value
                    placeBox.draggable = true;

                    // Dblclick to paste clipboard into all 6 slots (number mode only)
                    placeBox.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        pasteClipboardToPlaces();
                    });

                    const value = document.createElement('div');
                    value.className = 'place-box-value';
                    value.textContent = placeValues[i] || '_';
                    placeBox.appendChild(value);

                    placeBox.addEventListener('dragstart', (e) => {
                        draggedPlaceIndex = i;
                        draggedPlaceValue = placeValues[i];
                        lastDropInsidePlace = false;
                        e.dataTransfer.effectAllowed = 'copyMove';
                        e.dataTransfer.setData('text/plain', placeValues[i] || '');
                        e.dataTransfer.setData('application/x-place-index', String(i));
                        e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    });

                    placeBox.addEventListener('dragend', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        if (!lastDropInsidePlace && draggedPlaceValue) {
                            placeValues[draggedPlaceIndex] = '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                        draggedPlaceIndex = null;
                        draggedPlaceValue = null;
                    });

                    placeBox.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                        placeBox.style.borderColor = 'var(--accent-2)';
                        placeBox.style.backgroundColor = 'rgba(102, 126, 234, 0.25)';
                    });

                    placeBox.addEventListener('dragleave', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';
                    });

                    placeBox.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        lastDropInsidePlace = true;
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';

                        if (draggedPlaceIndex !== null && draggedPlaceIndex !== i) {
                            const tmp = placeValues[i];
                            placeValues[i] = draggedPlaceValue || '';
                            placeValues[draggedPlaceIndex] = tmp || '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            document.querySelectorAll('.place-box').forEach(box => {
                                box.style.removeProperty('borderColor');
                                box.style.removeProperty('backgroundColor');
                                box.style.removeProperty('opacity');
                            });
                            const placeContainer = numberPickerPopup.querySelector('.place-container');
                            if (placeContainer) {
                                placeContainer.style.removeProperty('borderColor');
                                placeContainer.style.removeProperty('backgroundColor');
                                placeContainer.style.removeProperty('opacity');
                            }
                            return;
                        }

                        let data = e.dataTransfer.getData('application/x-place-set');
                        if (data) {
                            try {
                                const values = JSON.parse(data);
                                for (let j = 0; j < 6; j++) {
                                    placeValues[j] = values[j] || '';
                                }
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                                return;
                            } catch (err) { }
                        }

                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData && currentMode === 'label') {
                            const colNum = labelData.replace('C', '');
                            placeValues[i] = colNum;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                            return;
                        }

                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num) && currentMode === 'number') {
                            placeValues[i] = num;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                    });

                    placesGrid.appendChild(placeBox);
                }
                // remove old overlays if any
                const existing = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                existing.forEach(n => n.remove());

                // helper: compute grid distance like drawConnections does
                function computeGridDistance(n1, n2) {
                    try {
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${n1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${n2}"]`);
                        if (!cell1 || !cell2 || tbodyRows.length === 0) return null;
                        const rowElem1 = cell1.parentElement;
                        const rowElem2 = cell2.parentElement;
                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                        const logicalRow1 = 7 - rowIdx1;
                        const logicalRow2 = 7 - rowIdx2;
                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                        const dx = colIdx2 - colIdx1;
                        const dy = logicalRow2 - logicalRow1;
                        return Math.sqrt(dx * dx + dy * dy);
                    } catch (e) { return null; }
                }

                // For each adjacent pair, if both filled and euclid enabled, create overlay
                const boxes = placesGrid.querySelectorAll('.place-box');
                // position overlays relative to the places grid so they sit centered
                // between the .place-box elements even when the popup is scrolled
                const containerRect = placesGrid.getBoundingClientRect();
                for (let i = 0; i < boxes.length - 1; i++) {
                    const a = placeValues[i];
                    const b = placeValues[i + 1];
                    if (currentMode === 'number' && euclidState && a && b && !isNaN(a) && !isNaN(b)) {
                        const boxA = boxes[i];
                        const boxB = boxes[i + 1];
                        if (!boxA || !boxB) continue;
                        // compute centers relative to placesGrid using offset values
                        const aCenterX = boxA.offsetLeft + boxA.offsetWidth / 2;
                        const bCenterX = boxB.offsetLeft + boxB.offsetWidth / 2;
                        const aCenterY = boxA.offsetTop + boxA.offsetHeight / 2;
                        const bCenterY = boxB.offsetTop + boxB.offsetHeight / 2;
                        const midX = (aCenterX + bCenterX) / 2;
                        const midY = (aCenterY + bCenterY) / 2;
                        const overlay = document.createElement('div');
                        overlay.className = 'place-distance-overlay';
                        const dist = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                        overlay.textContent = dist === null ? '' : dist.toFixed(2);
                        // set position inside placesGrid (no viewport -> container conversion needed)
                        overlay.style.left = midX + 'px';
                        overlay.style.top = midY + 'px';
                        placesGrid.appendChild(overlay);
                    }
                }
                // Compute total Euclidean distance for adjacent pairs and update display
                try {
                    const euclidTotalEl = document.getElementById('euclidTotal');
                    let total = 0;
                    for (let j = 0; j < boxes.length - 1; j++) {
                        const a = placeValues[j];
                        const b = placeValues[j + 1];
                        if (currentMode === 'number' && a && b && !isNaN(a) && !isNaN(b)) {
                            const d = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                            if (d !== null) total += d;
                        }
                    }
                    if (euclidTotalEl) {
                        // update nested value span if present
                        const valEl = document.getElementById('euclidTotalValue');
                        if (valEl) {
                            valEl.textContent = total.toFixed(2);
                            // ensure accent green emphasis remains
                            valEl.style.color = '#38ef7d';
                        } else {
                            euclidTotalEl.textContent = `Î£: ${total.toFixed(2)}`;
                        }
                        euclidTotalEl.style.opacity = (euclidState && currentMode === 'number') ? '1' : '0.5';
                    }
                } catch (e) { /* ignore */ }
                // Sync label and number highlights and redraw connections
                try {
                    updateLabelCellStyles();
                } catch (e) { /* ignore */ }
                try {
                    if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights();
                } catch (e) { /* ignore */ }
                try { drawConnections(); } catch (e) { /* ignore */ }
            }

            function setupPlaceContainerListeners() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                placeContainer.draggable = true;

                placeContainer.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.dataTransfer.setData('text/plain', JSON.stringify(placeValues));
                    e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    placeContainer.style.opacity = '0.6';
                });

                placeContainer.addEventListener('dragend', () => {
                    placeContainer.style.opacity = '1';
                });

                placeContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                });

                placeContainer.addEventListener('dragleave', (e) => {
                    if (e.target === placeContainer) {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }
                });

                placeContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    lastDropInsidePlace = true;
                    placeContainer.style.borderColor = 'var(--accent)';
                    placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';

                    if (currentMode === 'number') {
                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num)) {
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = num;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                            }
                        }
                    } else if (currentMode === 'label') {
                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData) {
                            const colNum = labelData.replace('C', '');
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = colNum;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                            }
                        }
                    }
                });
            }

            function setupNumberCellDragDrop() {
                // Use event delegation on the table to ensure handlers work
                // after the table is re-rendered and to avoid duplicate listeners.
                if (!numberPickerTable) return;
                if (numberPickerTable.dataset.dragDelegation === 'true') return;
                numberPickerTable.dataset.dragDelegation = 'true';

                numberPickerTable.addEventListener('dragstart', (e) => {
                    const cell = e.target.closest('.number-cell');
                    if (!cell) return;
                    // Respect explicit draggable attribute set on cells
                    const draggableAttr = cell.getAttribute('draggable');
                    if (draggableAttr === 'false') return;
                    draggedNumber = cell.dataset.number;
                    try {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', draggedNumber);
                    } catch (err) {
                        // Some environments may restrict dataTransfer; fail silently
                    }
                });

                numberPickerTable.addEventListener('dragend', () => {
                    draggedNumber = null;
                });
            }

            function setupLabelCellDragDrop() {
                if (!numberPickerTable) return;
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    // Skip if already setup (has data attribute)
                    if (cell.dataset.dragSetup === 'true') return;

                    // Clone to remove all old event listeners
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    // Explicitly set draggable to ensure it works after cloneNode
                    newCell.draggable = true;
                    newCell.dataset.dragSetup = 'true';

                    newCell.addEventListener('dragstart', (e) => {
                        const label = newCell.dataset.label;
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('application/x-label', label);
                        newCell.style.opacity = '0.5';
                    });

                    newCell.addEventListener('dragend', () => {
                        newCell.style.opacity = '1';
                    });
                });
            }

            // Update label cell styling based on place values
            function updateLabelCellStyles() {
                if (!numberPickerTable) return;
                const tfoot = numberPickerTable.tFoot;

                if (currentMode !== 'number') {
                    // In label mode, make all label cells bright and draggable (only inside popup)
                    const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                    labelCells.forEach(cell => cell.classList.add('with-values'));
                    if (tfoot) tfoot.classList.remove('disabled');
                    return;
                }

                // In number mode, determine which columns have values in placeValues
                const columnsWithValues = new Set();
                placeValues.forEach(val => {
                    if (val && val.trim() && !isNaN(val)) {
                        const num = parseInt(val, 10);
                        const col = getCol(num); // Use existing getCol helper
                        columnsWithValues.add(col);
                    }
                });

                // If any columns have values, remove disabled class from tfoot to show labels bright
                if (columnsWithValues.size > 0) {
                    if (tfoot) tfoot.classList.remove('disabled');
                } else {
                    if (tfoot) tfoot.classList.add('disabled');
                }

                // Update label cell styling
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    const label = cell.dataset.label; // e.g., "C1", "C2", ...
                    const colNum = parseInt(label.substring(1), 10); // Extract column number
                    if (columnsWithValues.has(colNum)) {
                        cell.classList.add('with-values');
                    } else {
                        cell.classList.remove('with-values');
                    }
                });
            }

            // Update number-cell highlights to match placeValues
            function updateNumberCellHighlights() {
                if (!numberPickerTable) return;
                // remove previous highlights
                const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                prev.forEach(p => p.classList.remove('selected-number'));

                if (currentMode !== 'number') return;

                // add highlight for each placed number
                placeValues.forEach(v => {
                    if (!v || v === '' || isNaN(v)) return;
                    const num = String(parseInt(v, 10));
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (cell) cell.classList.add('selected-number');
                });
            }

            const modeSelector = document.getElementById('modeSelector');
            let modeState = 'number';
            modeSelector.addEventListener('click', () => {
                modeState = modeState === 'number' ? 'label' : 'number';
                modeSelector.textContent = modeState === 'number' ? 'Sá»‘ (1-45)' : 'Label (C1-C6)';
                setNumberPickerMode(modeState, 'picker');
            });

            const modeRows = document.getElementById('modeRows');
            // Sync mode button when mode changes from external sources (cell9/10)
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    modeState = mode;
                    modeSelector.textContent = mode === 'number' ? 'Sá»‘ (1-45)' : 'Label (C1-C6)';
                });
            }

            // Connection toggle
            const connectionToggle = document.getElementById('connectionToggle');
            const connectionToggleLabel = document.getElementById('connectionToggleLabel');
            const euclidToggle = document.getElementById('euclidToggle');
            const euclidToggleLabel = document.getElementById('euclidToggleLabel');

            const updateConnectionToggleState = () => {
                const isNumberMode = currentMode === 'number';
                connectionToggle.disabled = !isNumberMode;
                if (connectionToggleLabel) {
                    connectionToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                }
                connectionToggle.style.opacity = isNumberMode ? '1' : '0.5';
                connectionToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Euclid toggle should follow same availability rules as connection toggle
                if (euclidToggle) euclidToggle.disabled = !isNumberMode;
                if (euclidToggleLabel) euclidToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Update Euclid total display availability
                const euclidTotalEl = document.getElementById('euclidTotal');
                if (euclidTotalEl) euclidTotalEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';
                // also dim the numeric value if present
                const euclidValEl = document.getElementById('euclidTotalValue');
                if (euclidValEl) euclidValEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';

                // Redraw when toggled
                drawConnections();
            };

            // Expose globally for mode change callback
            window.updateConnectionToggleState = updateConnectionToggleState;

            let connectionState = true;
            connectionToggle.addEventListener('click', () => {
                connectionState = !connectionState;
                connectionToggle.textContent = connectionState ? 'Hiá»‡n' : 'áº¨n';
                drawConnections();
            });

            // Euclid toggle state and handler
            let euclidState = true; // default visible
            if (euclidToggle) {
                euclidToggle.textContent = euclidState ? 'Hiá»‡n' : 'áº¨n';
                euclidToggle.addEventListener('click', () => {
                    euclidState = !euclidState;
                    euclidToggle.textContent = euclidState ? 'Hiá»‡n' : 'áº¨n';
                    drawConnections();
                    // Refresh place overlays and Euclid total display
                    try { generatePlaceBoxes(); } catch (e) { /* ignore if not ready */ }
                });
            }

            // Initialize connection toggle state
            updateConnectionToggleState();

            // Paste clipboard into place (dblclick on any place box) when in number mode
            async function pasteClipboardToPlaces() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                const flashFail = (reason) => {
                    console.log('Paste failed:', reason);
                    if (!placeContainer) return;
                    placeContainer.style.borderColor = '#ef4444';
                    placeContainer.style.backgroundColor = 'rgba(239, 68, 68, 0.14)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 450);
                };

                if (currentMode !== 'number') {
                    flashFail('wrong mode: ' + currentMode);
                    return;
                }

                const readClipboard = async () => {
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        return navigator.clipboard.readText();
                    }
                    if (window.clipboardData && window.clipboardData.getData) {
                        return window.clipboardData.getData('Text');
                    }
                    return null;
                };

                let txt = null;
                try {
                    txt = await readClipboard();
                    console.log('Raw clipboard result:', JSON.stringify(txt));
                } catch (err) {
                    console.error('Clipboard read error:', err);
                    flashFail('clipboard error: ' + err.message);
                    return;
                }

                if (txt === null || txt === undefined) {
                    console.error('Clipboard returned null - API blocked or not available');
                    flashFail('clipboard blocked (cháº¡y qua http:// thay vÃ¬ file://)');
                    return;
                }

                txt = txt.trim();
                if (!txt) {
                    flashFail('clipboard empty');
                    return;
                }

                const parts = txt.split(',').map(s => s.trim());
                console.log('Parts after split:', parts, 'length:', parts.length);
                if (parts.length !== 6) {
                    flashFail(`expected 6 parts, got ${parts.length}`);
                    return;
                }
                const next = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i];
                    if (p === '' || p === '_') { next.push(''); continue; }
                    const n = parseInt(p, 10);
                    console.log(`Part ${i}: "${p}" -> ${n}, valid: ${Number.isFinite(n) && n >= 1 && n <= 45}`);
                    if (!Number.isFinite(n) || n < 1 || n > 45) {
                        flashFail(`invalid number at position ${i + 1}: "${p}"`);
                        return;
                    }
                    next.push(String(n));
                }

                console.log('Paste successful:', next);
                for (let i = 0; i < 6; i++) placeValues[i] = next[i] || '';
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
                if (placeContainer) {
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 400);
                }
            }

            const clearPlaceBtn = document.getElementById('clearPlaceBtn');
            clearPlaceBtn.addEventListener('click', () => {
                for (let i = 0; i < placeValues.length; i++) {
                    placeValues[i] = '';
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
            });

            // Optional color picker (removed from UI) â€” attach listener only if element exists
            const cellColorPicker = document.getElementById('cellColorPicker');
            if (cellColorPicker) {
                cellColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    // Update CSS variable instead of inline style to preserve hover effects
                    document.documentElement.style.setProperty('--cell-bg-color', color);
                });
            }

            // Wrap table in a relative-positioned container
            const tableWrapper = document.createElement('div');
            tableWrapper.style.position = 'relative';
            numberPickerTable.parentElement.insertBefore(tableWrapper, numberPickerTable);
            tableWrapper.appendChild(numberPickerTable);

            generateNumberPickerTable();
            generatePlaceBoxes();
            setupPlaceContainerListeners();
            setupNumberCellDragDrop();
            setupLabelCellDragDrop();

            // Rank toggle handler: toggles between 'unnank' and 'rank' and re-renders the table
            const rankToggleBtn = document.getElementById('rankToggle');
            if (rankToggleBtn) {
                rankToggleBtn.addEventListener('click', () => {
                    const cur = rankToggleBtn.textContent.trim();
                    const next = cur === 'rank' ? 'unnank' : 'rank';
                    rankToggleBtn.textContent = next;
                    // Re-generate table to show/hide ranks
                    try { generateNumberPickerTable(); setupNumberCellDragDrop(); } catch (e) { console.warn(e); }
                });
            }

            // Apply saved scale and add scale handle
            applyPopupScale();
            addPopupScaleHandle();

            // Helper: desired popup alpha based on inline slider (preserve across open/close)
            const __POPUP_MIN_ALPHA = 0.15;
            function __desiredPopupAlpha() {
                try {
                    const el = document.getElementById('popupOpacityRangeInline');
                    if (!el) return 1;
                    const pct = Number(el.value || 0);
                    if (pct === 0) return 1;
                    return 1 - (pct / 100) * (1 - __POPUP_MIN_ALPHA);
                } catch (e) { return 1; }
            }

            // Close button
            const closeNumberPickerBtn = document.getElementById('closeNumberPickerBtn');
            closeNumberPickerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                isPopupVisible = false;
                numberPickerPopup.style.opacity = '0';
                setTimeout(() => {
                    numberPickerPopup.style.display = 'none';
                }, 300);
                // Hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.remove('visible');
                }
            });

            // Toggle popup on click
            htmlBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                isPopupVisible = !isPopupVisible;

                if (isPopupVisible) {
                    // Apply scale BEFORE showing to prevent flash
                    applyPopupScaleInstant();

                    const savedPos = localStorage.getItem('popupPosition');
                    if (savedPos) {
                        const { top, left } = JSON.parse(savedPos);
                        numberPickerPopup.style.top = `${top}px`;
                        numberPickerPopup.style.left = `${left}px`;
                    } else {
                        const rect = htmlBadge.getBoundingClientRect();
                        numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                        numberPickerPopup.style.left = `${rect.left}px`;
                    }

                    // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                    numberPickerPopup.style.display = 'block';
                    numberPickerPopup.style.opacity = '0';

                    requestAnimationFrame(() => {
                        numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                    });
                } else {
                    numberPickerPopup.style.opacity = '0';
                    setTimeout(() => {
                        numberPickerPopup.style.display = 'none';
                    }, 300);
                }

                // Show/hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.toggle('visible', isPopupVisible);
                }
            });

            // Toggle popup with Ctrl
            let ctrlPressed = false;
            let ctrlWithOtherKey = false;
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control' && !e.repeat) {
                    ctrlPressed = true;
                    ctrlWithOtherKey = false;
                } else if (ctrlPressed && e.key !== 'Control') {
                    ctrlWithOtherKey = true;
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control' && ctrlPressed && !ctrlWithOtherKey) {
                    isPopupVisible = !isPopupVisible;
                    if (isPopupVisible) {
                        // Apply scale BEFORE showing
                        applyPopupScaleInstant();

                        const savedPos = localStorage.getItem('popupPosition');
                        if (savedPos) {
                            const { top, left } = JSON.parse(savedPos);
                            numberPickerPopup.style.top = `${top}px`;
                            numberPickerPopup.style.left = `${left}px`;
                        } else {
                            const rect = htmlBadge.getBoundingClientRect();
                            numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                            numberPickerPopup.style.left = `${rect.left}px`;
                        }

                        // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                        numberPickerPopup.style.display = 'block';
                        numberPickerPopup.style.opacity = '0';

                        requestAnimationFrame(() => {
                            numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                        });
                    } else {
                        numberPickerPopup.style.opacity = '0';
                        setTimeout(() => {
                            numberPickerPopup.style.display = 'none';
                        }, 300);
                    }

                    // Show/hide scale handle
                    const handle = document.querySelector('.popup-scale-handle');
                    if (handle) {
                        handle.classList.toggle('visible', isPopupVisible);
                    }
                }
                if (e.key === 'Control') {
                    ctrlPressed = false;
                    ctrlWithOtherKey = false;
                }
            });

            // Make popup draggable by background
            let popupOffsetX = 0, popupOffsetY = 0, isDraggingPopup = false;
            numberPickerPopup.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on close button
                if (e.target.closest('.number-picker-close-btn')) {
                    return;
                }
                if (e.target === numberPickerPopup) {
                    isDraggingPopup = true;
                    const rect = numberPickerPopup.getBoundingClientRect();
                    popupOffsetX = e.clientX - rect.left;
                    popupOffsetY = e.clientY - rect.top;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (isDraggingPopup) {
                    const newLeft = e.clientX - popupOffsetX;
                    const newTop = e.clientY - popupOffsetY;
                    numberPickerPopup.style.left = newLeft + 'px';
                    numberPickerPopup.style.top = newTop + 'px';
                    localStorage.setItem('popupPosition', JSON.stringify({ top: newTop, left: newLeft }));
                }
            });
            document.addEventListener('mouseup', () => { isDraggingPopup = false; });

            // Expose placeValues globally
            window.getPlaceValues = () => placeValues;
            window.markPlaceDropHandled = () => { lastDropInsidePlace = true; };
            window.setPlaceValues = (values) => {
                if (Array.isArray(values)) {
                    for (let i = 0; i < 6; i++) {
                        const v = values[i];
                        placeValues[i] = (v === undefined || v === null) ? '' : v;
                    }
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
            };
            window.applyPlaceValuesToInputs = (inputArray) => {
                if (inputArray && inputArray.length >= 6) {
                    for (let i = 0; i < 6; i++) {
                        const val = placeValues[i];
                        if (val && !isNaN(val)) {
                            inputArray[i].value = val;
                            inputArray[i].dispatchEvent(new Event('input'));
                        }
                    }
                }
            };

            // Scroll to top button
            const scrollBtn = document.getElementById('scrollToTop');
            scrollBtn.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'flex';
                    scrollBtn.style.alignItems = 'center';
                    scrollBtn.style.justifyContent = 'center';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });

            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            const root = document.documentElement;
            const savedTheme = localStorage.getItem('theme') || 'light';
            root.setAttribute('data-theme', savedTheme);
            themeToggle.onclick = () => {
                const current = root.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                // Redraw connection lines to apply theme-specific colors
                try { drawConnections(); } catch { }
            };

            // Táº£i dá»¯ liá»‡u TRÆ¯á»šC khi render cÃ¡c cell
            await loadData();

            // Compute global rank (by total count) so popup can show ranks
            try {
                const totalCounts = Array(46).fill(0);
                rows.forEach(r => { if (r.nums && r.nums.length === 6) r.nums.forEach(v => { totalCounts[v] = (totalCounts[v] || 0) + 1; }); });
                const ranked = [];
                for (let v = 1; v <= 45; v++) ranked.push({ v, cnt: totalCounts[v] || 0 });
                ranked.sort((a, b) => b.cnt - a.cnt || a.v - b.v);
                const rankByTotal = {};
                ranked.forEach((r, idx) => { rankByTotal[r.v] = idx + 1; });
                window.rankByTotal = rankByTotal;
                // Regenerate the number picker table now that ranks are available
                try { if (typeof generateNumberPickerTable === 'function') generateNumberPickerTable(); } catch (e) { console.warn('regen number picker after rank compute', e); }
            } catch (e) { window.rankByTotal = {}; }

            const showSection = createSectionSwitcher();
            // Renderer map for lazy section mounting
            const renderers = {
                cell4: renderCell4,
                cell5: renderCell5,
                cell5_5: renderCell5_5,
                // Note: mismatched creators â€“ keep ids aligned with sections created inside
                cell6: renderCell8, // PhÃ¢n nhÃ³m theo bá»™ sá»‘
                cell6_5: renderCell6_5, // Truy x (lá»c theo sá»‘ x)
                cell6_6: renderCell6_6, // Má»• pattern (6 sá»‘ cá»‘ Ä‘á»‹nh)
                cell7: renderCell6, // NhÃ³m theo label
                cell8: renderCell7, // TÃ¬m kiáº¿m theo Label
                cell9: renderCell9,
                cell10: renderCell10,
                cell11: renderCell11,
            };

            // Expose ensureRendered globally for nav handlers
            window.ensureRendered = function ensureRendered(id) {
                if (!document.getElementById(id)) {
                    const fn = renderers[id];
                    if (typeof fn === 'function') fn();
                }
            };

            buildNav(showSection);
            // Hiá»ƒn thá»‹ section theo hash (náº¿u há»£p lá»‡), máº·c Ä‘á»‹nh cell4
            const initial = (location.hash || "#cell4").replace("#", "");
            // Lazy mount only the initial section
            window.ensureRendered(initial || "cell4");
            showSection(initial || "cell4");
            window.addEventListener("hashchange", () => {
                const id = (location.hash || "#cell4").replace("#", "");
                window.ensureRendered(id || "cell4");
                showSection(id || "cell4");
            });
        }

        // Tag nested cards inside `.card.card-inner` with `card-inner-child`.
        (function markInnerChildCards() {
            function mark() {
                document.querySelectorAll('.card.card-inner').forEach(wrapper => {
                    wrapper.querySelectorAll('.card').forEach(child => {
                        if (!child.classList.contains('card-inner-child')) child.classList.add('card-inner-child');
                    });
                    // If the wrapper contains exactly one descendant marked as card-inner-child,
                    // mark the wrapper with `single-child` so CSS can target descendant-only cases.
                    try {
                        const innerChildren = wrapper.querySelectorAll('.card-inner-child');
                        if (innerChildren.length === 1) wrapper.classList.add('single-child');
                        else wrapper.classList.remove('single-child');
                    } catch (e) { /* ignore */ }
                });
            }
            // initial pass
            try { mark(); } catch (e) { }
            // watch for future additions
            try {
                const mo = new MutationObserver(mark);
                mo.observe(document.body, { childList: true, subtree: true });
                // expose for debugging if needed
                window.__markInnerChildObserver = mo;
            } catch (e) { }
        })();

        // Setup inline opacity slider next to Î£ and bind it to popup background alpha
        (function setupInlineOpacityControl() {
            const euclidTotal = document.getElementById('euclidTotal');
            const popup = document.getElementById('numberPickerPopup');
            if (!euclidTotal) return;

            // create container next to Î£ if not exists
            if (!document.getElementById('popupOpacityRangeInline')) {
                const container = document.createElement('span');
                container.className = 'inline-opacity-container';
                container.innerHTML = `
                    <input id="popupOpacityRangeInline" type="range" min="0" max="100" value="0">
                    <div class="inline-percent" id="popupOpacityInlineValue">0%</div>
                `;
                euclidTotal.parentNode.insertBefore(container, euclidTotal.nextSibling);

                const range = container.querySelector('#popupOpacityRangeInline');
                const label = container.querySelector('#popupOpacityInlineValue');

                function parseRGB(str) {
                    const m = String(str).match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                    if (m) return [m[1], m[2], m[3]];
                    return [255, 255, 255];
                }

                function updateAlpha(v) {
                    label.textContent = `${v}%`;
                    const pct = Number(v);
                    if (!popup) return;

                    // Prevent fully transparent popup: reserve a minimum visible alpha.
                    const MIN_ALPHA = 0.15; // keep at least 15% opacity so popup never fully hides

                    // 0% should preserve the original visuals exactly (no inline overrides)
                    if (pct === 0) {
                        popup.style.backgroundColor = '';
                        popup.style.borderColor = '';
                        popup.style.boxShadow = '';
                        // If popup is currently displayed, ensure it remains visible (opacity 1).
                        // Otherwise clear inline opacity so it falls back to CSS when hidden.
                        try {
                            const csDisp = getComputedStyle(popup).display;
                            if (csDisp && csDisp !== 'none') {
                                popup.style.opacity = '1';
                            } else {
                                popup.style.opacity = '';
                            }
                        } catch (e) {
                            popup.style.opacity = '';
                        }
                        return;
                    }

                    // Map slider 0..100 -> alpha 1..MIN_ALPHA (linear)
                    const alpha = 1 - (pct / 100) * (1 - MIN_ALPHA);

                    const cs = getComputedStyle(popup);
                    const bg = cs.backgroundColor || 'rgb(255,255,255)';
                    const [r, g, b] = parseRGB(bg);

                    // Apply opacity to the whole popup so all children fade together
                    popup.style.opacity = String(alpha);
                    // Also set background rgba to preserve backdrop color when semi-transparent
                    popup.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    // Soften border and shadow proportionally (keep a minimum subtle border)
                    try {
                        const bc = cs.borderColor || 'rgb(0,0,0)';
                        const [br, bg2, bb] = parseRGB(bc);
                        const borderAlpha = Math.max(0.08, alpha * 0.9);
                        popup.style.borderColor = `rgba(${br}, ${bg2}, ${bb}, ${borderAlpha})`;
                    } catch (e) { }

                    try {
                        const shadowAlpha = 0.28 * alpha + 0.02;
                        popup.style.boxShadow = `0 8px 24px rgba(0,0,0,${shadowAlpha})`;
                    } catch (e) { }
                }

                // initialize
                updateAlpha(range.value);
                range.addEventListener('input', (e) => updateAlpha(e.target.value));
            }
        })();

        // Run bootstrap then enable sticky fallback for multiple sections
        bootstrap().then(() => {
            (function enableStickyFallbackForSections() {
                const SECTIONS = ['cell6_5', 'cell6_6', 'cell8', 'cell9', 'cell10', 'cell11'];
                const HEADER_OFFSET = 64; // matches CSS top

                SECTIONS.forEach(sectionId => {
                    const sec = document.getElementById(sectionId);
                    if (!sec) return;
                    const controls = sec.querySelector('.controls');
                    if (!controls) return;

                    let placeholder = null;

                    function update() {
                        const secRect = sec.getBoundingClientRect();
                        const ctrlRect = controls.getBoundingClientRect();
                        const shouldPin = secRect.top < HEADER_OFFSET && (secRect.bottom > (HEADER_OFFSET + ctrlRect.height));

                        if (shouldPin && !controls.classList.contains('stuck')) {
                            // create placeholder to preserve layout
                            placeholder = document.createElement('div');
                            placeholder.style.height = ctrlRect.height + 'px';
                            controls.parentNode.insertBefore(placeholder, controls);

                            controls.classList.add('stuck');
                            controls.style.position = 'fixed';
                            controls.style.top = HEADER_OFFSET + 'px';
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                            controls.style.zIndex = 1100;
                        } else if (!shouldPin && controls.classList.contains('stuck')) {
                            controls.classList.remove('stuck');
                            controls.style.position = '';
                            controls.style.top = '';
                            controls.style.left = '';
                            controls.style.width = '';
                            controls.style.zIndex = '';
                            if (placeholder) { placeholder.remove(); placeholder = null; }
                        }
                    }

                    // listeners
                    window.addEventListener('scroll', update, { passive: true });
                    window.addEventListener('resize', () => {
                        if (controls.classList.contains('stuck')) {
                            const secRect = sec.getBoundingClientRect();
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                        }
                    });

                    // mutation observer to handle dynamic content
                    const mo = new MutationObserver(() => setTimeout(update, 50));
                    mo.observe(sec, { childList: true, subtree: true });

                    // initial check
                    setTimeout(update, 120);
                });
            })();
        });
    </script>
    <script>
        // JS shim: add a compatibility class for `td:has(.pill)` so older editors/linters
        // won't complain and dynamic tables get the same behavior.
        (function markTdHasPill() {
            function markAll() {
                document.querySelectorAll('td').forEach(td => {
                    try {
                        if (td.querySelector && td.querySelector('.pill')) td.classList.add('td-has-pill');
                        else td.classList.remove('td-has-pill');
                    } catch (e) { /* ignore */ }
                });
            }
            // Initial pass
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', markAll);
            else markAll();
            // Watch for DOM changes (tables regenerated dynamically)
            const mo = new MutationObserver(() => { markAll(); });
            mo.observe(document.body, { childList: true, subtree: true });
        })();
    </script>
</body>

</html>
