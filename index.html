<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life Notebook ‚Üí Web</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #94a3b8;
            --accent: #38ef7d;
            --accent-2: #667eea;
            --border: #1e293b;
            --card: #0b1220;
            --text: #e2e8f0;
            --text-strong: #fff;
            --highlight-bg: #4CAF50;
            --highlight-text: #0b1220;
        }

        [data-theme="light"] {
            --bg: #f8f9ff;
            --panel: #ffffff;
            --muted: #666;
            --accent: #38ef7d;
            --accent-2: #11998e;
            --border: #eee;
            --card: #fafafa;
            --text: #333;
            --text-strong: #000;
            --highlight-bg: #4CAF50;
            --highlight-text: #fff;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        [data-theme="dark"] body {
            background: radial-gradient(circle at 20% 20%, rgba(56, 239, 125, 0.08), transparent 35%),
                radial-gradient(circle at 80% 10%, rgba(102, 126, 234, 0.12), transparent 40%),
                var(--bg);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }

        [data-theme="light"] header {
            background: rgba(248, 250, 252, 0.9);
        }

        .theme-toggle {
            margin-left: auto;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .topbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand span {
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border-radius: 8px;
            font-size: 12px;
            color: var(--highlight-text);
            font-weight: 900;
            cursor: pointer;
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }

        .brand span:hover {
            transform: scale(1.05);
        }

        .image-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
        }

        [data-theme="dark"] .image-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .image-popup.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        .image-popup img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            border-radius: 8px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .image-popup img {
                max-width: 200px;
                max-height: 200px;
            }
        }

        nav {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .nav-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn.active {
            border-color: var(--accent);
            color: var(--highlight-text);
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            font-weight: 800;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
        }

        section h2 {
            margin: 0 0 12px;
            color: var(--text-strong);
            letter-spacing: 0.3px;
        }

        section p.lead {
            margin: 6px 0 16px;
            color: var(--muted);
        }

        .card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .card {
            background: var(--card);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 14px;
        }

        select,
        input,
        button {
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            font-size: 13px;
        }

        select:focus,
        input:focus {
            outline: 1px solid var(--accent);
        }

        /* Hide number input spinner arrows */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100());
            border: none;
            color: var(--highlight-text);
            font-weight: 700;
            cursor: pointer;
        }

        button.ghost {
            background: var(--card);
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        [data-theme="dark"] table {
            background: var(--panel);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            z-index: 1;
        }

        th {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        th:last-child {
            border-right: none;
        }

        td {
            padding: 5px 6px;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        [data-theme="dark"] td {
            border-color: var(--border);
        }

        td:last-child {
            border-right: none;
        }

        tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        tbody tr:nth-child(odd) {
            background: white;
        }

        [data-theme="dark"] tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        [data-theme="dark"] tbody tr:nth-child(odd) {
            background: transparent;
        }

        tbody tr:hover {
            background: #ffe6b3 !important;
        }

        [data-theme="dark"] tbody tr:hover {
            background: rgba(255, 230, 179, 0.2) !important;
        }

        /* Top rank colors from notebook */
        tbody tr:first-child {
            background: #c8e6c9 !important;
        }

        tbody tr:nth-child(2) {
            background: #fff9c4 !important;
        }

        tbody tr:nth-child(3) {
            background: #b3e5fc !important;
        }

        /* Keep text legible on light rank backgrounds, especially in dark theme */
        tbody tr:nth-child(-n+3) td {
            color: #0f172a;
            font-weight: 700;
        }

        [data-theme="dark"] tbody tr:nth-child(-n+3) td {
            color: #0b1220;
        }

        /* Keep top ranks in Cell4 readable on dark theme */
        [data-theme="dark"] #cell4 tbody tr.rank-top td {
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr.rank-top .pill {
            background: #fffbea;
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr:nth-child(n+4) td[style*="background:linear-gradient"] {
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.15) 0%, rgba(56, 239, 125, 0.25) 100%) !important;
            color: #fff !important;
        }

        .pill {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: #e6f4ea;
            color: #0b8a60;
            white-space: nowrap;
            margin: 1px;
            font-family: monospace;
        }

        .label-chip {
            display: inline-block;
            min-width: 18px;
            padding: 2px 5px;
            margin: 1px 2px 1px 0;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-weight: 700;
            background: transparent;
            color: inherit;
        }

        .label-chip.highlight {
            background: var(--highlight-bg);
            color: var(--highlight-text);
        }

        [data-theme="dark"] .pill {
            background: rgba(56, 239, 125, 0.15);
            color: #38ef7d;
        }

        /* Prevent pill containers from wrapping */
        td:has(.pill) {
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .pill {
                font-size: 10px;
                padding: 2px 5px;
                margin: 1px;
            }

            th,
            td {
                padding: 4px 6px;
                font-size: 11px;
            }
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid>* {
            flex: 1 1 350px;
            min-width: 0;
        }

        .grid-centered {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .grid-centered>* {
            flex: 0 1 calc(33.333% - 10px);
            max-width: 600px;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            .grid>* {
                flex: 1 1 100%;
            }

            .grid-centered>* {
                flex: 1 1 100%;
                max-width: none;
            }
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            padding: 3px 8px;
            border-radius: 8px;
            background: var(--accent-2);
            color: white;
            font-weight: 700;
            font-size: 12px;
            opacity: 0.9;
        }

        main {
            padding: 16px 12px 32px;
        }

        section {
            margin: 20px 0;
            padding: 16px;
        }

        @media (min-width: 768px) {
            main {
                padding: 24px 18px 48px;
            }

            section {
                margin: 32px 0;
                padding: 22px;
            }
        }

        .error {
            color: #fca5a5;
            font-weight: 600;
        }

        .success {
            color: #34d399;
            font-weight: 700;
        }

        .loader {
            text-align: center;
            color: var(--muted);
            padding: 16px 0;
        }

        .flex {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        a.anchor {
            color: inherit;
            text-decoration: none;
        }

        .hidden {
            display: none;
        }

        /* Floating scroll-to-top button */
        #scrollToTop {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToTop:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToTop:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #scrollToTop {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="topbar">
            <div class="brand">Life Notebook
                <span id="htmlBadge">HTML</span>
            </div>
            <nav id="nav"></nav>
            <button class="theme-toggle" id="themeToggle" title="Chuy·ªÉn giao di·ªán">üåì</button>
        </div>
    </header>
    <div class="image-popup" id="imagePopup">
        <img src="anh.png" alt="Preview">
    </div>
    <button id="scrollToTop" title="Quay v·ªÅ ƒë·∫ßu trang">‚Üë</button>
    <main>
        <div id="status" class="card" style="margin-bottom:18px;">ƒêang t·∫£i d·ªØ li·ªáu...</div>
        <!-- Sections injected by JS -->
    </main>

    <script>
        // ===== Helpers from notebook =====
        const COL_MAP = { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 2, 10: 2, 11: 2, 12: 2, 13: 2, 14: 2, 15: 2, 16: 2, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 3, 23: 3, 24: 3, 25: 4, 26: 4, 27: 4, 28: 4, 29: 4, 30: 4, 31: 4, 32: 5, 33: 5, 34: 5, 35: 5, 36: 5, 37: 5, 38: 5, 39: 6, 40: 6, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6 };
        const getCol = (v) => COL_MAP[v] ?? 0;

        // ===== Data Loading =====
        let rows = [];
        async function loadData() {
            const status = document.getElementById("status");
            try {
                // Expect data.json in format: [{"date": "2024-01-01", "Result": "1,2,3,4,5,6"}, ...]
                const res = await fetch("data.json");
                if (!res.ok) throw new Error("Kh√¥ng t√¨m th·∫•y data.json. H√£y xu·∫•t t·ª´ Excel tr∆∞·ªõc.");
                const raw = await res.json();
                rows = raw
                    .map(r => {
                        if (!r.Result || typeof r.Result !== "string") return null;
                        const nums = r.Result.split(",").map(x => parseInt(x.trim(), 10)).filter(Number.isInteger);
                        if (nums.length !== 6) return null;
                        return { date: r.date ?? "", nums, label: nums.map(getCol).join("") };
                    })
                    .filter(Boolean);
                status.innerHTML = `<span class="success">ƒê√£ t·∫£i ${rows.length} d√≤ng</span> ¬∑ file: data.json`;
            } catch (err) {
                status.innerHTML = `<span class="error">${err.message}</span><br/><span class="muted">T·∫°o file data.json t·ª´ Excel b·∫±ng script python: <code>python - <<'PY'\nimport pandas as pd, json\ndf = pd.read_excel('data.xlsx')\nout = df[['date','Result']]\nout.to_json('data.json', orient='records', force_ascii=False, indent=2)\nPY</code></span>`;
            }
        }

        // ===== Utilities =====
        let decimalPlaces = 2; // default decimal places for percentage
        const fmtPct = (v) => `${(v * 100).toFixed(decimalPlaces)}%`;
        const fmtPctCustom = (v, decimals) => `${(v * 100).toFixed(decimals)}%`;
        const MATCH_STYLE = "background:#2e7d32;color:#fff;"; // dark green with white text for matched values
        const anchorNav = [
            { id: "cell4", label: "Cell4 ¬∑ T·ª∑ l·ªá theo v·ªã tr√≠" },
            { id: "cell5", label: "Cell5 ¬∑ X·∫øp h·∫°ng v·ªã tr√≠" },
            { id: "cell6", label: "Cell6 ¬∑ Nh√≥m label" },
            { id: "cell7", label: "Cell7 ¬∑ T√¨m label" },
            { id: "cell8", label: "Cell8 ¬∑ Nh√≥m b·ªô s·ªë" },
            { id: "cell9", label: "Cell9 ¬∑ B·ªô s·ªë t√πy ch·ªçn" },
            { id: "cell10", label: "Cell10 ¬∑ Ph√¢n t√≠ch v·ªã tr√≠" },
            { id: "cell11", label: "Cell11 ¬∑ Pattern s·ªë" },
        ];

        function buildNav(showSection) {
            const nav = document.getElementById("nav");
            anchorNav.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "nav-btn";
                btn.textContent = item.label;
                btn.dataset.target = item.id;
                btn.onclick = () => {
                    showSection(item.id);
                    history.replaceState(null, "", `#${item.id}`);
                };
                nav.appendChild(btn);
            });
        }

        // ===== Renderers =====
        function sectionShell(id, title, lead = "") {
            const sec = document.createElement("section");
            sec.id = id;
            sec.dataset.section = id;
            const h2 = document.createElement("h2");
            h2.textContent = title;
            sec.appendChild(h2);
            if (lead) {
                const p = document.createElement("p");
                p.className = "lead";
                p.textContent = lead;
                sec.appendChild(p);
            }
            const body = document.createElement("div");
            sec.appendChild(body);
            document.querySelector("main").appendChild(sec);
            return body;
        }

        // Qu·∫£n l√Ω hi·ªÉn th·ªã t·ª´ng "trang" (section) m√† kh√¥ng m·∫•t state
        function createSectionSwitcher() {
            const main = document.querySelector("main");
            const buttons = () => Array.from(document.querySelectorAll(".nav-btn"));
            const sections = () => Array.from(main.querySelectorAll("section"));
            const scrollPositions = new Map(); // L∆∞u v·ªã tr√≠ scroll cho t·ª´ng section

            function setActive(id) {
                // L∆∞u v·ªã tr√≠ scroll hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn
                const currentSection = sections().find(sec => !sec.classList.contains("hidden"));
                if (currentSection) {
                    scrollPositions.set(currentSection.id, window.scrollY);
                }

                buttons().forEach(btn => {
                    const active = btn.dataset.target === id;
                    btn.classList.toggle("active", active);
                });
                sections().forEach(sec => {
                    sec.classList.toggle("hidden", sec.id !== id);
                });

                // Restore v·ªã tr√≠ scroll c·ªßa section m·ªõi
                requestAnimationFrame(() => {
                    const savedPosition = scrollPositions.get(id);
                    if (savedPosition !== undefined) {
                        window.scrollTo(0, savedPosition);
                    } else {
                        window.scrollTo(0, 0); // Scroll v·ªÅ ƒë·∫ßu n·∫øu ch∆∞a c√≥ l·ªãch s·ª≠
                    }
                });
            }

            function showSection(id) {
                const target = sections().find(sec => sec.id === id);
                const fallback = "cell4";
                const finalId = target ? id : fallback;
                setActive(finalId);
            }

            return showSection;
        }

        // Cell4: t·ª∑ l·ªá theo v·ªã tr√≠
        function renderCell4() {
            const body = sectionShell("cell4", "Cell4 ¬∑ T·ª∑ l·ªá theo v·ªã tr√≠ (home)", "Top/Sort t∆∞∆°ng t·ª± notebook: hi·ªÉn th·ªã t·ª∑ l·ªá t·ª´ng s·ªë theo 6 v·ªã tr√≠.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[10, "Top 10"], [20, "Top 20"], [30, "Top 30"], [45, "T·∫•t c·∫£ (45)"]].forEach(([v, l]) => {
                const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o);
            });
            topSel.value = "45";
            const sortSel = document.createElement("select");
            [["default", "M·∫∑c ƒë·ªãnh (1‚Üí45)"], ["total_desc", "Theo t·ªïng % gi·∫£m d·∫ßn"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const decimalSel = document.createElement("select");
            [[0, "0 ch·ªØ s·ªë"], [1, "1 ch·ªØ s·ªë"], [2, "2 ch·ªØ s·ªë"], [3, "3 ch·ªØ s·ªë"], [4, "4 ch·ªØ s·ªë"], [5, "5 ch·ªØ s·ªë"], [6, "6 ch·ªØ s·ªë"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hi·ªÉn th·ªã:", topSel, "S·∫Øp x·∫øp:", sortSel, "ƒê·ªô ch√≠nh x√°c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const counts = Array.from({ length: 46 }, () => Array(6).fill(0));
                let total = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return;
                    total++;
                    r.nums.forEach((v, i) => { counts[v][i]++; });
                });
                let data = [];
                for (let v = 1; v <= 45; v++) {
                    const pcts = counts[v].map(c => total ? c / total : 0);
                    data.push({ v, pcts, sum: pcts.reduce((a, b) => a + b, 0) });
                }
                if (sortSel.value === "total_desc") data.sort((a, b) => b.sum - a.sum); else data.sort((a, b) => a.v - b.v);
                data = data.slice(0, parseInt(topSel.value, 10));

                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr>" +
                    "<th>Rank</th><th>S·ªë</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>T·ªïng %</th></tr></thead><tbody>";
                data.forEach((row, idx) => {
                    const bg = idx === 0 ? "#134e4a" : idx === 1 ? "#422006" : idx === 2 ? "#0f172a" : (idx % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.05)");
                    const rankClass = idx < 3 ? "rank-top" : "";
                    html += `<tr class="${rankClass}" style="background:${bg};">` +
                        `<td>#${idx + 1}</td><td><span class='pill'>${row.v}</span></td>` +
                        row.pcts.map(p => `<td>${fmtPctCustom(p, decimals)}</td>`).join("") +
                        `<td style="background:linear-gradient(135deg, rgba(56, 239, 125, 0.2) 0%, rgba(56, 239, 125, 0.35) 100%);color:#0f172a;font-weight:700;"><strong>${fmtPctCustom(row.sum, decimals)}</strong></td></tr>`;
                });
                html += "</tbody></table></div>";
                wrap.innerHTML = html;
            }
            topSel.onchange = sortSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5: x·∫øp h·∫°ng theo v·ªã tr√≠
        function renderCell5() {
            const body = sectionShell("cell5", "Cell5 ¬∑ X·∫øp h·∫°ng theo v·ªã tr√≠", "Ch·ªçn top v√† t√¥ ƒë·∫≠m theo notebook.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[3, "Top 3"], [5, "Top 5"], [10, "Top 10"], [45, "T·∫•t c·∫£ (45)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o); });
            topSel.value = "45";
            const hiSel = document.createElement("select");
            [[0, "Kh√¥ng"], [1, "Top 1"], [3, "Top 3"], [5, "Top 5"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; hiSel.appendChild(o); });
            hiSel.value = "3";
            const decimalSel = document.createElement("select");
            [[0, "0 ch·ªØ s·ªë"], [1, "1 ch·ªØ s·ªë"], [2, "2 ch·ªØ s·ªë"], [3, "3 ch·ªØ s·ªë"], [4, "4 ch·ªØ s·ªë"], [5, "5 ch·ªØ s·ªë"], [6, "6 ch·ªØ s·ªë"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hi·ªÉn th·ªã:", topSel, "T√¥ ƒë·∫≠m:", hiSel, "ƒê·ªô ch√≠nh x√°c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const count = Array.from({ length: 6 }, () => Array(46).fill(0));
                rows.forEach(r => { r.nums.forEach((v, i) => { count[i][v]++; }); });
                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                const topN = parseInt(topSel.value, 10);
                for (let rank = 0; rank < topN; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        const arr = [...Array(45).keys()].map(i => i + 1).map(v => [v, count[pos][v]]).sort((a, b) => b[1] - a[1]);
                        const [v, c] = arr[rank];
                        const pct = rows.length ? (c / rows.length) : 0;
                        const col = getCol(v);
                        cells.push(`<td><div><strong>${v}</strong> <span class='muted'>[C${col}]</span></div><div class='muted'>${fmtPctCustom(pct, decimals)}</div></td>`);
                    }
                    const bg = rank < hiSel.value ? (rank === 0 ? "#134e4a" : rank === 1 ? "#42340a" : "#0f1b2d") : (rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)");
                    html += `<tr style="background:${bg};"><td>#${rank + 1}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                // Th√™m b·∫£ng m·ªõi: X·∫øp h·∫°ng c·ªôt theo v·ªã tr√≠ (6x6)
                html += "<h3 style='margin-top: 24px; margin-bottom: 12px;'>X·∫øp h·∫°ng c·ªôt theo v·ªã tr√≠</h3>";
                html += "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";

                // T√≠nh to√°n: v·ªõi m·ªói v·ªã tr√≠, x·∫øp h·∫°ng c√°c c·ªôt (1-6) theo s·ªë l·∫ßn xu·∫•t hi·ªán
                for (let rank = 1; rank <= 6; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        // ƒê·∫øm m·ªói c·ªôt (1-6) xu·∫•t hi·ªán ·ªü v·ªã tr√≠ n√†y
                        const colCounts = {};
                        for (let col = 1; col <= 6; col++) colCounts[col] = 0;

                        rows.forEach(r => {
                            const v = r.nums[pos];
                            const col = getCol(v);
                            colCounts[col]++;
                        });

                        // S·∫Øp x·∫øp c√°c c·ªôt theo s·ªë l·∫ßn xu·∫•t hi·ªán (gi·∫£m d·∫ßn)
                        const sortedCols = Object.entries(colCounts)
                            .map(([col, count]) => ({ col: parseInt(col), count }))
                            .sort((a, b) => b.count - a.count);

                        // L·∫•y c·ªôt ·ªü rank n√†y (rank - 1 v√¨ rank b·∫Øt ƒë·∫ßu t·ª´ 1)
                        const { col: topCol, count: topCount } = sortedCols[rank - 1];
                        const pct = rows.length ? (topCount / rows.length) : 0;
                        cells.push(`<td><div><strong>C${topCol}</strong></div><div class='muted'>${fmtPctCustom(pct, parseInt(decimalSel.value, 10))}</div></td>`);
                    }
                    const bg = rank <= 3 ? (rank === 1 ? "#134e4a" : rank === 2 ? "#42340a" : "#0f1b2d") : (rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)");
                    html += `<tr style="background:${bg};"><td>#${rank}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                wrap.innerHTML = html;
            }
            topSel.onchange = hiSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Helpers for labels
        const labelOf = (nums) => nums.map(getCol).join("");
        const diffPositions = (a, b) => { const pos = []; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) pos.push(i); return pos; };

        // Cell6: group by label with max diff + consecutive
        function renderCell6() {
            const body = sectionShell("cell6", "Cell6 ¬∑ Nh√≥m theo label", "max sai kh√°c & li·ªÅn k·ªÅ, ch·ªâ nh√≥m >=2 k·ª≥.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const diffSel = document.createElement("select");
            for (let i = 0; i <= 6; i++) { const o = document.createElement("option"); o.value = i; o.textContent = `Sai kh√°c ${i}`; diffSel.appendChild(o); } diffSel.value = "1";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ"));
            controls.append("Sai kh√°c t·ªëi ƒëa:", diffSel, consecLabel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const labelRows = {};
                rows.forEach(r => { const label = labelOf(r.nums); (labelRows[label] ||= []).push(r); });
                const labels = Object.keys(labelRows).sort();
                const used = new Set();
                const groups = [];
                labels.forEach(base => {
                    if (used.has(base)) return;
                    used.add(base);
                    const gLabels = [base];
                    let gRows = [...labelRows[base]];
                    labels.forEach(other => {
                        if (used.has(other)) return;
                        const pos = diffPositions(base, other);
                        if (pos.length > diffSel.value) return;
                        if (consec.checked && pos.length > 1 && !pos.every((p, i) => i === 0 || p - pos[i - 1] === 1)) return;
                        used.add(other); gLabels.push(other); gRows.push(...labelRows[other]);
                    });
                    if (gRows.length >= 2) groups.push({ base, labels: gLabels, rows: gRows });
                });
                groups.sort((a, b) => b.rows.length - a.rows.length);
                let html = `<div class='muted'>${groups.length} nh√≥m ¬∑ ${groups.reduce((s, g) => s + g.rows.length, 0)} k·ª≥</div><div class='grid-centered'>`;
                groups.forEach((g, idx) => {
                    html += `<div class='card'><div class='flex' style='justify-content:space-between'><strong>Base ${g.base}</strong><span class='badge'>${g.rows.length} k·ª≥</span></div>`;
                    html += "<table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                    g.rows.slice(0, 20).forEach(r => {
                        const label = labelOf(r.nums);
                        const labelHtml = label.split("").map((ch, i) => ch !== g.base[i] ? `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>` : `<span>${ch}</span>`).join(" ");
                        const nums = r.nums.map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        html += `<tr><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                    });
                    html += "</tbody></table>";
                    if (g.rows.length > 20) html += `<div class='muted'>... ${g.rows.length - 20} d√≤ng n·ªØa</div>`;
                    html += "</div>";
                });
                html += "</div>";
                wrap.innerHTML = html;
            }
            diffSel.onchange = consec.onchange = group;
            group();
        }

        // Cell7: reverse query by label pattern (6 chars, _ wildcard)
        function renderCell7() {
            const body = sectionShell("cell7", "Cell7 ¬∑ T√¨m ki·∫øm theo Label", "Nh·∫≠p 6 k√Ω t·ª± label (1-6 ho·∫∑c _) ƒë·ªÉ t√¨m c√°c k·ª≥ c√≥ label kh·ªõp. C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; return inp; });

            // Create draggable containers for inputs
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;top:0;left:0;right:0;bottom:0;cursor:move;z-index:1;pointer-events:none;`;

                inp.style.position = "relative";
                inp.style.zIndex = "2";

                container.appendChild(inp);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                const updateDraggable = () => {
                    const hasValue = inp.value.trim() !== "" && inp.value.trim() !== "_";
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? "auto" : "none";
                    container.style.opacity = hasValue ? "1" : "0.7";
                    if (hasValue) {
                        container.style.border = "2px solid var(--accent)";
                        container.style.borderRadius = "10px";
                        container.style.padding = "2px";
                    } else {
                        container.style.border = "none";
                        container.style.padding = "0";
                    }
                };

                inp.addEventListener("input", updateDraggable);
                updateDraggable();

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    container.style.opacity = "0.4";
                    e.dataTransfer.effectAllowed = "move";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const wrapInputs = document.createElement("div"); wrapInputs.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Label:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            wrapInputs.appendChild(labelText);
            containers.forEach(c => wrapInputs.appendChild(c)); body.appendChild(wrapInputs);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "ghost"; wrapInputs.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            hint.innerHTML = "üí° M·∫πo: K√©o th·∫£ gi·ªØa c√°c √¥ ƒë·ªÉ s·∫Øp x·∫øp l·∫°i. D√πng ph√≠m ‚Üê ‚Üí ƒë·ªÉ di chuy·ªÉn.";
            wrapInputs.appendChild(hint);

            function run() {
                const pattern = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : "_"; }).join("");
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                if (pattern.length !== 6) { wrap.innerHTML = "<div class='error'>C·∫ßn 6 k√Ω t·ª±</div>"; return; }
                const records = rows.filter(r => {
                    const label = r.label;
                    for (let i = 0; i < 6; i++) if (pattern[i] !== "_" && pattern[i] !== label[i]) return false;
                    return true;
                });
                if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o kh·ªõp pattern</div>"; return; }
                let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < records.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>K·∫øt qu·∫£</th><th>Label</th></tr></thead><tbody>";
                    records.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_"
                            ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                            : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
                        ).join(" ");
                        const labelHtml = r.label.split("").map((ch, idx) => pattern[idx] === "_" ? `<span>${ch}</span>` : `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`).join(" ");
                        html += `<tr><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        // Cell8: group by same number set size x
        function renderCell8() {
            const body = sectionShell("cell8", "Cell8 ¬∑ Ph√¢n nh√≥m theo b·ªô s·ªë", "Ch·ªçn k√≠ch th∆∞·ªõc b·ªô s·ªë (1-6), t√πy ch·ªçn li·ªÅn k·ªÅ, s·∫Øp x·∫øp.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `B·ªô ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ")); consec.checked = true;
            const sortSel = document.createElement("select");[["count_desc", "Gi·∫£m d·∫ßn (s·ªë k·ª≥)"], ["count_asc", "TƒÉng d·∫ßn (s·ªë k·ª≥)"], ["value_asc", "TƒÉng d·∫ßn (gi√° tr·ªã)"], ["value_desc", "Gi·∫£m d·∫ßn (gi√° tr·ªã)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            controls.append("B·ªô s·ªë:", xSel, consecLabel, "S·∫Øp x·∫øp:", sortSel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const x = parseInt(xSel.value, 10);
                const groups = new Map();
                rows.forEach((r, rowIndex) => {
                    const nums = r.nums;
                    if (consec.checked) {
                        // Khi ch·ªçn li·ªÅn k·ªÅ, ch·ªâ duy·ªát c√°c block li√™n ti·∫øp thay v√¨ m·ªçi t·ªï h·ª£p ‚Üí nhanh h∆°n
                        for (let i = 0; i <= nums.length - x; i++) {
                            const slice = nums.slice(i, i + x).slice();
                            const key = slice.sort((a, b) => a - b).join("-");
                            if (!groups.has(key)) groups.set(key, new Set());
                            groups.get(key).add(rowIndex); // D√πng Set ƒë·ªÉ tr√°nh tr√πng l·∫∑p
                        }
                    } else {
                        const indexed = nums.map((v, i) => [i, v]);
                        const combos = kCombinations(indexed, x);
                        combos.forEach(combo => {
                            const values = combo.map(c => c[1]).sort((a, b) => a - b);
                            const key = values.join("-");
                            if (!groups.has(key)) groups.set(key, new Set());
                            groups.get(key).add(rowIndex); // D√πng Set ƒë·ªÉ tr√°nh tr√πng l·∫∑p
                        });
                    }
                });
                let arr = [...groups.entries()].map(([key, indices]) => [key, [...indices].map(i => rows[i])]).filter(([, list]) => list.length >= 2);
                const sort = sortSel.value;
                if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                else arr.sort((a, b) => b[1].length - a[1].length);

                let html = `<div class='muted'>${arr.length} nh√≥m (>=2 k·ª≥)</div><div class='grid-centered'>`;
                arr.forEach(([key, list]) => {
                    html += `<div class='card'><div class='flex' style='justify-content:space-between'><strong>{${key.replace(/-/g, ',')}}</strong><span class='badge'>${list.length} k·ª≥</span></div>`;
                    html += "<div><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                    list.slice(0, 20).forEach(r => {
                        const setValues = new Set(key.split("-").map(Number));
                        const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked);
                        const labelHtml = renderHighlightedLabel(r.label, positions);
                        html += `<tr><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                    });
                    if (list.length > 20) html += `<tr><td colspan='3' class='muted'>... ${list.length - 20} d√≤ng n·ªØa</td></tr>`;
                    html += "</tbody></table></div></div>";
                });
                html += "</div>";
                wrap.innerHTML = html;
            }
            xSel.onchange = consec.onchange = sortSel.onchange = group;
            group();
        }

        // helpers
        function kCombinations(set, k) {
            const combs = [];
            const recur = (start, combo) => {
                if (combo.length === k) { combs.push(combo.slice()); return; }
                for (let i = start; i < set.length; i++) { combo.push(set[i]); recur(i + 1, combo); combo.pop(); }
            };
            recur(0, []); return combs;
        }
        function compareKey(a, b) {
            const pa = a.split("-").map(Number); const pb = b.split("-").map(Number);
            for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; }
            return pa.length - pb.length;
        }
        function findHighlightPositions(nums, setValues, blockSize, requireConsecutive) {
            if (requireConsecutive) {
                for (let i = 0; i <= nums.length - blockSize; i++) {
                    const block = nums.slice(i, i + blockSize);
                    if (block.length === blockSize && block.every(v => setValues.has(v)) && new Set(block).size === setValues.size) {
                        return Array.from({ length: blockSize }, (_, k) => i + k);
                    }
                }
            }
            const positions = [];
            nums.forEach((v, idx) => { if (setValues.has(v)) positions.push(idx); });
            return positions;
        }
        function renderHighlightedNums(nums, setValues, blockSize, requireConsecutive) {
            const positions = findHighlightPositions(nums, setValues, blockSize, requireConsecutive);
            const posSet = new Set(positions);
            const html = nums.map((v, idx) => posSet.has(idx)
                ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
            ).join(" ");
            return { html, positions };
        }
        function renderHighlightedLabel(labelStr, highlightPositions) {
            const posSet = new Set(highlightPositions);
            return labelStr.split("").map((ch, idx) => posSet.has(idx)
                ? `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`
                : `<span>${ch}</span>`
            ).join(" ");
        }

        // Cell9: draws containing user set
        function renderCell9() {
            const body = sectionShell("cell9", "Cell9 ¬∑ T√¨m k·ª≥ ch·ª©a b·ªô s·ªë ho·∫∑c label", "Ch·ªçn t√¨m theo b·ªô s·ªë (1-45) ho·∫∑c label (1-6). C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");

            // Mode selector
            const modeSel = document.createElement("select");
            [["number", "B·ªô s·ªë (1-45)"], ["label", "Label (1-6)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; modeSel.appendChild(o); });
            modeSel.value = "number";

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === "number") {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "40px"; return inp; });
                }
            };

            let inputs = createInputs(modeSel.value);

            // Create draggable containers for inputs
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;";
                    container.draggable = false;

                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;top:0;left:0;right:0;bottom:0;cursor:move;z-index:1;pointer-events:none;`;

                    inp.style.position = "relative";
                    inp.style.zIndex = "2";

                    container.appendChild(inp);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    const updateDraggable = () => {
                        const hasValue = inp.type === "number" ? inp.value.trim() !== "" : (inp.value.trim() !== "" && inp.value.trim() !== "_");
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? "auto" : "none";
                        container.style.opacity = hasValue ? "1" : "0.7";
                        if (hasValue) {
                            container.style.border = "2px solid var(--accent)";
                            container.style.borderRadius = "10px";
                            container.style.padding = "2px";
                        } else {
                            container.style.border = "none";
                            container.style.padding = "0";
                        }
                    };

                    inp.addEventListener("input", updateDraggable);
                    updateDraggable();

                    return container;
                });
            };

            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;

            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        container.style.opacity = "0.4";
                        e.dataTransfer.effectAllowed = "move";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = "move";
                        if (draggedIndex !== null && draggedIndex !== idx) {
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ"));
            const controls = document.createElement("div"); controls.className = "controls";

            // Add mode selector
            controls.appendChild(modeSel);

            const inputLabel = document.createElement("span"); inputLabel.textContent = modeSel.value === "number" ? "B·ªô s·ªë:" : "Label:"; inputLabel.style.fontWeight = "700"; inputLabel.style.fontSize = "14px"; inputLabel.style.marginLeft = "12px";
            controls.appendChild(inputLabel);

            // For label mode, reverse the containers for proper left-to-right display
            const containersToAdd = modeSel.value === "label" ? [...containers].reverse() : containers;
            containersToAdd.forEach(c => controls.appendChild(c));
            controls.append(consecLabel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "ghost"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            hint.innerHTML = "üí° M·∫πo: K√©o th·∫£ gi·ªØa c√°c √¥ ƒë·ªÉ s·∫Øp x·∫øp l·∫°i. D√πng ph√≠m ‚Üê ‚Üí ƒë·ªÉ di chuy·ªÉn.";
            controls.appendChild(hint);

            function run() {
                const mode = modeSel.value;

                if (mode === "number") {
                    // Mode: T√¨m b·ªô s·ªë
                    const vals = inputs.map(i => parseInt(i.value, 10)).filter(v => !isNaN(v) && v >= 1 && v <= 45);
                    if (!vals.length) { wrap.innerHTML = "<div class='loader'>ƒêi·ªÅn √≠t nh·∫•t 1 s·ªë...</div>"; return; }
                    // Count frequency of each number in input
                    const inputFreq = {};
                    vals.forEach(v => { inputFreq[v] = (inputFreq[v] || 0) + 1; });
                    const setVals = new Set(vals);
                    const records = rows.filter(r => {
                        // Count frequency of numbers in row
                        const rowFreq = {};
                        r.nums.forEach(v => { rowFreq[v] = (rowFreq[v] || 0) + 1; });
                        // Check if row has at least the frequency we need for each number
                        for (const num in inputFreq) {
                            if ((rowFreq[num] || 0) < inputFreq[num]) return false;
                        }
                        if (consec.checked) return hasConsecutiveBlock(r.nums, setVals);
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o ph√π h·ª£p</div>"; return; }
                    let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < records.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                        records.slice(i, i + chunk).forEach(r => {
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setVals, setVals.size, consec.checked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            html += `<tr><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                } else {
                    // Mode: T√¨m label - d√πng t·∫ßn su·∫•t (list), h·ªó tr·ª£ Li·ªÅn k·ªÅ theo c·ª≠a s·ªï li√™n ti·∫øp
                    const labels = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : null; }).filter(v => v !== null);
                    if (!labels.length) { wrap.innerHTML = "<div class='loader'>ƒêi·ªÅn √≠t nh·∫•t 1 k√Ω t·ª±...</div>"; return; }
                    // ƒê·∫øm t·∫ßn su·∫•t k√Ω t·ª± trong input
                    const inputFreq = {};
                    labels.forEach(ch => { inputFreq[ch] = (inputFreq[ch] || 0) + 1; });
                    const totalCount = labels.length;
                    const inputKeys = Object.keys(inputFreq);
                    const keySet = new Set(inputKeys);

                    const records = rows.filter(r => {
                        const labelStr = r.label;
                        // Ki·ªÉm tra t·∫ßn su·∫•t to√†n chu·ªói: m·ªói k√Ω t·ª± trong input ph·∫£i xu·∫•t hi·ªán ƒë·ªß s·ªë l·∫ßn
                        const rowFreq = {};
                        for (const ch of labelStr) rowFreq[ch] = (rowFreq[ch] || 0) + 1;
                        for (const ch of inputKeys) {
                            if ((rowFreq[ch] || 0) < inputFreq[ch]) return false;
                        }
                        // N·∫øu y√™u c·∫ßu li·ªÅn k·ªÅ: t√¨m c·ª≠a s·ªï ƒë·ªô d√†i totalCount th·ªèa t·∫ßn su·∫•t input
                        if (consec.checked) {
                            for (let i = 0; i <= labelStr.length - totalCount; i++) {
                                const block = labelStr.slice(i, i + totalCount);
                                const blockFreq = {};
                                for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                let ok = true;
                                for (const ch of inputKeys) {
                                    if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                }
                                if (ok) return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o ph√π h·ª£p</div>"; return; }
                    let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < records.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                        records.slice(i, i + chunk).forEach(r => {
                            const nums = r.nums.map(n => `<span class='pill'>${n}</span>`).join(" ");
                            const labelStr = r.label;
                            let highlightPos = [];
                            if (consec.checked) {
                                // T√¨m c·ª≠a s·ªï ƒë·∫ßu ti√™n th·ªèa t·∫ßn su·∫•t ƒë·ªÉ highlight
                                let start = -1;
                                for (let s = 0; s <= labelStr.length - totalCount && start === -1; s++) {
                                    const block = labelStr.slice(s, s + totalCount);
                                    const blockFreq = {};
                                    for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                    let ok = true;
                                    for (const ch of inputKeys) {
                                        if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                    }
                                    if (ok) start = s;
                                }
                                if (start !== -1) {
                                    highlightPos = Array.from({ length: totalCount }, (_, k) => start + k);
                                }
                            }
                            // Kh√¥ng li·ªÅn k·ªÅ: highlight m·ªçi v·ªã tr√≠ c√≥ k√Ω t·ª± thu·ªôc t·∫≠p input
                            if (!highlightPos.length) {
                                for (let pos = 0; pos < labelStr.length; pos++) {
                                    if (keySet.has(labelStr[pos])) highlightPos.push(pos);
                                }
                            }
                            const labelHtml = renderHighlightedLabel(labelStr, highlightPos);
                            html += `<tr><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                }
            }

            // Handle mode change
            modeSel.onchange = () => {
                // Clear any drag-drop visual state from old containers
                document.querySelectorAll(".drag-input-container").forEach(c => {
                    c.style.opacity = "1";
                    c.style.transform = "";
                });

                inputs = createInputs(modeSel.value);
                containers = createContainers(inputs);
                setupDragListeners(containers);

                // Clear and update controls - remove old containers completely
                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                // Update label text
                inputLabel.textContent = modeSel.value === "number" ? "B·ªô s·ªë:" : "Label:";

                // Re-insert input containers
                const insertPoint = inputLabel;
                const containersToAdd = modeSel.value === "label" ? [...containers].reverse() : containers;
                containersToAdd.forEach(c => insertPoint.parentNode.insertBefore(c, insertPoint.nextSibling));

                // Re-attach event listeners to new inputs
                inputs.forEach((inp, idx) => {
                    inp.oninput = run;
                    inp.onkeydown = (e) => {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            const nextIdx = idx > 0 ? idx - 1 : inputs.length - 1;
                            inputs[nextIdx].focus();
                        }
                        if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            const nextIdx = idx < inputs.length - 1 ? idx + 1 : 0;
                            inputs[nextIdx].focus();
                        }
                    };
                });

                run();
            };

            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        const nextIdx = idx > 0 ? idx - 1 : inputs.length - 1;
                        inputs[nextIdx].focus();
                    }
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        const nextIdx = idx < inputs.length - 1 ? idx + 1 : 0;
                        inputs[nextIdx].focus();
                    }
                };
            });
            consec.onchange = run; clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function setValsIsSubset(setVals, arr) { for (const v of setVals) if (!arr.includes(v)) return false; return true; }
        function hasConsecutiveBlock(nums, setVals) {
            const k = setVals.size;
            for (let i = 0; i <= nums.length - k; i++) {
                const block = nums.slice(i, i + k);
                if (block.length === k && setValsIsSubset(setVals, block) && new Set(block).size === setVals.size) return true;
            }
            return false;
        }

        // Cell10: analyze other positions given value at order
        function renderCell10() {
            const body = sectionShell("cell10", "Cell10 ¬∑ Ph√¢n t√≠ch c√°c v·ªã tr√≠ kh√°c", "ƒêi·ªÅn 1 gi√° tr·ªã v√†o 1 √¥ ƒë·ªÉ xem ph√¢n b·ªë ·ªü 5 v·ªã tr√≠ c√≤n l·∫°i. C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");
            // Mode selector: Number (1‚Äì45) vs Column (1‚Äì6)
            const modeSel = document.createElement("select");
            [["number", "S·ªë (1‚Äì45)"], ["column", "C·ªôt (1‚Äì6)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; modeSel.appendChild(o); });
            modeSel.value = "number";
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;top:0;left:0;right:0;bottom:0;cursor:move;z-index:1;pointer-events:none;`;

                inp.style.position = "relative";
                inp.style.zIndex = "2";

                container.appendChild(inp);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                const updateDraggable = () => {
                    const hasValue = inp.value.trim() !== "";
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? "auto" : "none";
                    container.style.opacity = hasValue ? "1" : "0.7";
                    if (hasValue) {
                        container.style.border = "2px solid var(--accent)";
                        container.style.borderRadius = "10px";
                        container.style.padding = "2px";
                    } else {
                        container.style.border = "none";
                        container.style.padding = "0";
                    }
                };

                inp.addEventListener("input", updateDraggable);
                updateDraggable();

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    container.style.opacity = "0.4";
                    e.dataTransfer.effectAllowed = "move";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run(idx);
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            // Remove extra label; the dropdown options already indicate the mode
            controls.append(modeSel);
            containers.forEach(c => controls.appendChild(c)); body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "ghost"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            hint.innerHTML = "üí° M·∫πo: K√©o th·∫£ s·ªë gi·ªØa c√°c √¥ ƒë·ªÉ s·∫Øp x·∫øp l·∫°i. D√πng ph√≠m ‚Üê ‚Üí ƒë·ªÉ di chuy·ªÉn.";
            controls.appendChild(hint);

            function run(changeIdx) {
                const filled = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).filter(x => !isNaN(x.val));
                if (filled.length > 1 && changeIdx !== undefined) {
                    filled.filter(f => f.idx !== changeIdx).forEach(f => {
                        inputs[f.idx].value = "";
                        // Refresh drag visuals when value is cleared programmatically
                        inputs[f.idx].dispatchEvent(new Event("input"));
                    });
                }
                const single = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).find(x => !isNaN(x.val));
                if (!single) {
                    wrap.innerHTML = modeSel.value === "number"
                        ? "<div class='loader'>ƒêi·ªÅn 1 s·ªë (1‚Äì45) v√†o 1 √¥...</div>"
                        : "<div class='loader'>ƒêi·ªÅn 1 c·ªôt (1‚Äì6) v√†o 1 √¥...</div>";
                    return;
                }
                const order = single.idx + 1; const value = single.val;
                const posCols = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] }; const posMaps = { 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {} };
                let total = 0, hit = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return; total++;
                    const matched = (modeSel.value === "number") ? (r.nums[order - 1] === value) : (getCol(r.nums[order - 1]) === value);
                    if (!matched) return; hit++;
                    for (let pos = 1; pos <= 6; pos++) { if (pos === order) continue; const v = r.nums[pos - 1]; const c = getCol(v); posCols[pos].push(c); (posMaps[pos][c] ||= []).push(v); }
                });
                if (!hit) {
                    const what = modeSel.value === "number" ? value : `c·ªôt ${value}`;
                    wrap.innerHTML = `<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o v·ªõi ${what} ·ªü v·ªã tr√≠ ${order}</div>`; return;
                }
                const pattern = Array(6).fill("_"); pattern[order - 1] = (modeSel.value === "number") ? value : `C${value}`;
                let html = `<div class='muted'>${hit}/${total} k·ª≥ (${(hit / total * 100).toFixed(2)}%) ¬∑ Pattern: ${pattern.join(',')}</div>`;
                const positionsBefore = [1, 2, 3, 4, 5, 6].filter(p => p < order);
                const positionsAfter = [1, 2, 3, 4, 5, 6].filter(p => p > order);
                const renderPosTable = (pos) => {
                    const counts = countMap(posCols[pos]);
                    let rowsHtml = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([c, n]) => {
                        const vals = countMap(posMaps[pos][c] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        return `<tr><td style='font-weight:700'>C·ªôt ${c}</td><td style='text-align:right;font-weight:700'>${n}</td><td style='text-align:right;font-weight:700'>${fmtPct(n / posCols[pos].length)}</td><td style='font-weight:700'>${valsHtml || '‚Äî'}</td></tr>`;
                    }).join("");
                    return `<div class='card'><h4>V·ªã tr√≠ ${pos}</h4><table><thead><tr><th>C·ªôt</th><th>S·ªë l·∫ßn</th><th>T·ª∑ l·ªá</th><th>S·ªë hay ƒëi c√πng</th></tr></thead><tbody>${rowsHtml}</tbody></table></div>`;
                };
                // Column-mode: compact 4-column table (Column | Count | Percentage | Numbers), 6 rows ranked
                const renderPosTableColumn = (pos) => {
                    const counts = countMap(posCols[pos]);
                    const totalPos = posCols[pos].length || 1;
                    const items = [1, 2, 3, 4, 5, 6].map(c => ({ col: c, count: counts[c] || 0, pct: (counts[c] || 0) / totalPos }));
                    items.sort((a, b) => b.count - a.count || a.col - b.col);
                    // Ensure each card is at most 1/3 of the row and centered
                    let t = `<div class='card' style='flex:0 1 calc(33.333% - 10px);'><h4 style='margin:0 0 8px;'>V·ªã tr√≠ ${pos}</h4><table><thead><tr><th>C·ªôt</th><th>S·ªë l·∫ßn</th><th>T·ª∑ l·ªá</th><th>S·ªë hay xu·∫•t hi·ªán</th></tr></thead><tbody>`;
                    items.forEach((it, idx) => {
                        const rankBg = idx === 0 ? "#c8e6c9" : idx === 1 ? "#fff9c4" : idx === 2 ? "#b3e5fc" : "";
                        const style = rankBg ? `style=\"background:${rankBg}\"` : "";
                        const vals = countMap(posMaps[pos][it.col] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        t += `<tr ${style}><td style='font-weight:700'>${it.col}</td><td style='text-align:right;font-weight:700'>${it.count}</td><td style='text-align:right;font-weight:700'>${fmtPct(it.pct)}</td><td style='font-weight:700'>${valsHtml || '‚Äî'}</td></tr>`;
                    });
                    t += "</tbody></table></div>";
                    return t;
                };
                if (positionsBefore.length) html += `<h4>V·ªã tr√≠ tr∆∞·ªõc</h4><div class='grid-centered'>${(modeSel.value === "number" ? positionsBefore.map(renderPosTable) : positionsBefore.map(renderPosTableColumn)).join('')}</div>`;
                if (positionsAfter.length) html += `<h4>V·ªã tr√≠ sau</h4><div class='grid-centered'>${(modeSel.value === "number" ? positionsAfter.map(renderPosTable) : positionsAfter.map(renderPosTableColumn)).join('')}</div>`;
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => {
                inputs.forEach(i => {
                    i.value = "";
                    // Refresh drag visuals after clear
                    i.dispatchEvent(new Event("input"));
                });
                run();
            };
            // Mode changes: adjust input constraints, CLEAR values, and rerun
            modeSel.onchange = () => {
                inputs.forEach(inp => {
                    // Switch constraints per mode
                    if (modeSel.value === "number") { inp.min = 1; inp.max = 45; inp.placeholder = ""; }
                    else { inp.min = 1; inp.max = 6; inp.placeholder = "1‚Äì6"; }
                    // Clear previous value when switching modes
                    inp.value = "";
                    // Refresh drag visuals after mode switch
                    inp.dispatchEvent(new Event("input"));
                });
                run();
            };
            run();
        }
        function countMap(arr) { const m = {}; arr.forEach(v => m[v] = (m[v] || 0) + 1); return m; }

        // Cell11: pattern search 6 positions with commas, _ wildcard
        function renderCell11() {
            const body = sectionShell("cell11", "Cell11 ¬∑ T√¨m k·ª≥ theo Pattern s·ªë", "Nh·∫≠p s·ªë (1-45) v√†o t·ª´ng v·ªã tr√≠ ƒë·ªÉ t√¨m k·ª≥ kh·ªõp. C√≥ th·ªÉ k√©o th·∫£ s·ªë gi·ªØa c√°c v·ªã tr√≠ b·∫±ng chu·ªôt. B·ªè tr·ªëng v·ªã tr√≠ n√†o th√¨ v·ªã tr√≠ ƒë√≥ ch·∫•p nh·∫≠n s·ªë b·∫•t k·ª≥.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;";
                container.draggable = false; // Container kh√¥ng drag, ch·ªâ n·ªôi dung b√™n trong

                // Wrap input in a draggable area
                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `
                    position:absolute;
                    top:0;
                    left:0;
                    right:0;
                    bottom:0;
                    cursor:move;
                    z-index:1;
                    pointer-events:none;
                `;

                inp.style.position = "relative";
                inp.style.zIndex = "2";

                container.appendChild(inp);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                // Enable drag only when there's a value
                const updateDraggable = () => {
                    const hasValue = inp.value.trim() !== "";
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? "auto" : "none";
                    container.style.opacity = hasValue ? "1" : "0.7";
                    if (hasValue) {
                        container.style.border = "2px solid var(--accent)";
                        container.style.borderRadius = "10px";
                        container.style.padding = "2px";
                    } else {
                        container.style.border = "none";
                        container.style.padding = "0";
                    }
                };

                inp.addEventListener("input", updateDraggable);
                updateDraggable();

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    container.style.opacity = "0.4";
                    e.dataTransfer.effectAllowed = "move";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        // Swap values
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        // Update draggable state for both
                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        // Trigger search
                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Pattern:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            controls.appendChild(labelText);
            containers.forEach(c => controls.appendChild(c));
            body.appendChild(controls);

            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "ghost"; controls.appendChild(clearBtn);

            // Add hint text
            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            hint.innerHTML = "üí° M·∫πo: K√©o th·∫£ s·ªë gi·ªØa c√°c √¥ ƒë·ªÉ s·∫Øp x·∫øp l·∫°i pattern. D√πng ph√≠m ‚Üê ‚Üí ƒë·ªÉ di chuy·ªÉn gi·ªØa c√°c √¥.";
            controls.appendChild(hint);

            function run(changeIdx) {
                const pattern = inputs.map(inp => {
                    const v = inp.value.trim();
                    if (!v) return "_";
                    const n = parseInt(v, 10);
                    return (n >= 1 && n <= 45) ? String(n) : "_";
                });
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                if (pattern.every(p => p === "_")) { wrap.innerHTML = "<div class='loader'>Nh·∫≠p v√†o 1 √¥ ƒë·ªÉ t√¨m ki·∫øm...</div>"; return; }
                const results = rows.filter(r => pattern.every((p, i) => p === "_" || r.nums[i] === Number(p)));
                if (!results.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o kh·ªõp pattern</div>"; return; }
                const patternStr = pattern.join(',');
                let html = `<div class='muted'>${results.length} k·ª≥ ¬∑ pattern ${patternStr}</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < results.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                    results.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_" ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        const highlightPositions = pattern.map((p, i) => p === "_" ? -1 : i).filter(i => i >= 0);
                        const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                        html += `<tr><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        async function bootstrap() {
            // HTML badge image popup
            const htmlBadge = document.getElementById('htmlBadge');
            const imagePopup = document.getElementById('imagePopup');
            let isPopupVisible = false;

            // Show popup on hover (mouseenter)
            htmlBadge.addEventListener('mouseenter', () => {
                if (!isPopupVisible) {
                    isPopupVisible = true;
                    const rect = htmlBadge.getBoundingClientRect();
                    imagePopup.style.top = `${rect.bottom + 8}px`;
                    imagePopup.style.left = `${rect.left}px`;
                    imagePopup.classList.add('show');
                }
            });

            // Toggle popup on click - only way to close
            htmlBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                isPopupVisible = !isPopupVisible;

                if (isPopupVisible) {
                    // Calculate position based on badge location
                    const rect = htmlBadge.getBoundingClientRect();
                    imagePopup.style.top = `${rect.bottom + 8}px`;
                    imagePopup.style.left = `${rect.left}px`;
                }

                imagePopup.classList.toggle('show', isPopupVisible);
            });

            // Scroll to top button
            const scrollBtn = document.getElementById('scrollToTop');
            scrollBtn.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'flex';
                    scrollBtn.style.alignItems = 'center';
                    scrollBtn.style.justifyContent = 'center';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });

            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            const root = document.documentElement;
            const savedTheme = localStorage.getItem('theme') || 'light';
            root.setAttribute('data-theme', savedTheme);
            themeToggle.onclick = () => {
                const current = root.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
            };

            // T·∫£i d·ªØ li·ªáu TR∆Ø·ªöC khi render c√°c cell
            await loadData();

            const showSection = createSectionSwitcher();
            buildNav(showSection);
            renderCell4();
            renderCell5();
            renderCell6();
            renderCell7();
            renderCell8();
            renderCell9();
            renderCell10();
            renderCell11();
            // Hi·ªÉn th·ªã section theo hash (n·∫øu h·ª£p l·ªá), m·∫∑c ƒë·ªãnh cell4
            const initial = (location.hash || "#cell4").replace("#", "");
            showSection(initial || "cell4");
            window.addEventListener("hashchange", () => {
                const id = (location.hash || "#cell4").replace("#", "");
                showSection(id || "cell4");
            });
        }

        bootstrap();
    </script>
</body>

</html>
