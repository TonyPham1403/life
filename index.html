<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life Notebook → Web</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #94a3b8;
            --accent: #38ef7d;
            --accent-2: #667eea;
            --border: #1e293b;
            --card: #0b1220;
            --text: #e2e8f0;
            --text-strong: #fff;
            --highlight-bg: #4CAF50;
            --highlight-text: #0b1220;
            /* Canvas connection line color for dark mode */
            --connection-line-color: #ff5722;
            /* deep orange - contrasts with dark bg and yellow cells */
            /* Scroll button sizing/offsets will be defined on body for symmetry */
        }

        [data-theme="light"] {
            --bg: #f8f9ff;
            --panel: #ffffff;
            --muted: #666;
            --accent: #38ef7d;
            --accent-2: #11998e;
            --border: #eee;
            --card: #fafafa;
            --text: #333;
            --text-strong: #000;
            --highlight-bg: #4CAF50;
            --highlight-text: #fff;
            /* Canvas connection line color for light mode */
            --connection-line-color: #00cc00;
            /* keep green in light theme */
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
            /* Scroll button vars placed on body so positions are body-relative/mirrored */
            --scroll-btn-size: 50px;
            --scroll-btn-offset: 30px;
            --scroll-btn-right: 30px;
            /* height of the sticky header to exclude from the remaining area */
            --header-height: 64px;
        }

        [data-theme="dark"] body {
            background: radial-gradient(circle at 20% 20%, rgba(56, 239, 125, 0.08), transparent 35%),
                radial-gradient(circle at 80% 10%, rgba(102, 126, 234, 0.12), transparent 40%),
                var(--bg);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }

        [data-theme="light"] header {
            background: rgba(248, 250, 252, 0.9);
        }

        .theme-toggle {
            margin-left: auto;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .topbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand span {
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border-radius: 8px;
            font-size: 12px;
            color: var(--highlight-text);
            font-weight: 900;
            cursor: pointer;
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }

        .brand span:hover {
            transform: scale(1.05);
        }

        /* Number Picker Popup and Place Boxes (copied from index.html) */
        .number-picker-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 500px;
            max-height: 800px;
            /* increased to reduce internal scrolling when mode wraps */
            overflow-y: auto;
            left: 0;
            top: 0;
            cursor: move;
            transform-origin: top left;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            opacity: 0;
        }

        .popup-scale-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            display: none;
            background: var(--accent);
            border: 1px solid var(--accent-2);
            opacity: 0.7;
        }

        .popup-scale-handle.visible {
            display: block;
        }

        .number-picker-popup * {
            cursor: default;
        }

        .number-picker-popup .popup-scale-handle {
            cursor: nwse-resize !important;
        }

        [data-theme="dark"] .number-picker-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .number-picker-popup.show {
            display: block;
            opacity: 1;
        }

        /* Highlight the selected option inside native dropdowns where supported */
        select option:checked,
        select option.highlighted {
            background: var(--highlight-bg) !important;
            color: var(--highlight-text) !important;
            font-weight: 800;
        }

        /* Inline opacity control placed next to Σ */
        .inline-opacity-container {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        .inline-opacity-container input[type="range"] {
            width: 100px;
            max-width: 100%;
            height: 6px;
            accent-color: var(--accent);
        }

        /* Smaller slider when placed inside compact mode rows/selectors */
        .mode-rows .inline-opacity-container input[type="range"],
        .mode-selector .inline-opacity-container input[type="range"] {
            width: 72px;
        }

        .inline-opacity-container .inline-percent {
            min-width: 36px;
            font-weight: 800;
            font-size: 13px;
            color: var(--text-strong);
        }

        .number-picker-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .number-picker-table th {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: center;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table th.label-cell {
            cursor: grab;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            color: white;
        }

        .number-picker-table th.label-cell:active {
            cursor: grabbing;
        }

        .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        .number-picker-table th:nth-child(3) {
            border-right: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset -3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table th:nth-child(4) {
            border-left: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset 3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table td:active {
            cursor: grabbing;
        }

        [data-theme="light"] .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
        }

        [data-theme="light"] .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table th:nth-child(3) {
            border-right: 3px solid #11998e !important;
            box-shadow: inset -3px 0 0 0 #11998e;
        }

        [data-theme="light"] .number-picker-table th:nth-child(4) {
            border-left: 3px solid #11998e !important;
            box-shadow: inset 3px 0 0 0 #11998e;
        }

        .number-picker-table td:hover {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
            box-sizing: border-box;
            /* Added box-sizing */
            /* Do not set a global text color on the cell so rank badges keep their own color.
               Color for the main number is applied to the number span below. */
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        /* Target only the main number span inside the cell; exclude rank badge spans */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number>span:not(.rank-in-cell) {
            color: #00ff00 !important;
            font-weight: 900;
        }

        #numberPickerPopup #numberPickerTable td.disabled {
            opacity: 1;
            cursor: not-allowed;
            background: #1a2a3a !important;
            pointer-events: none;
            /* avoid changing all nested text color (rank badges must keep their own color) */
            font-weight: 700 !important;
        }

        /* For disabled cells, color only the displayed number span (not the rank badge) */
        #numberPickerPopup #numberPickerTable td.disabled>span:not(.rank-in-cell) {
            color: #00ff00 !important;
        }

        /* If a disabled cell is also selected/placed, show the selected highlight instead
           (override the darker disabled styling). This ensures dragging a number into a place
           will display the same accent highlight as hover/selection and will be cleared
           by the normal highlight-sync logic. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number,
        #numberPickerPopup #numberPickerTable td.selected-number.disabled,
        #numberPickerPopup #numberPickerTable td.number-cell.disabled.selected-number {
            background: #1a2a3a !important;
            color: #00ff00 !important;
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        [data-theme="light"] #numberPickerPopup #numberPickerTable td.disabled {
            background: #e8f4f8 !important;
            color: #1a1a1a !important;
        }

        /* Apply bright label-cell style when column has values */
        .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        [data-theme="light"] .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Dim label cells that don't have values */
        .number-picker-table tfoot:not(.disabled) th.label-cell:not(.with-values) {
            opacity: 0.3 !important;
            pointer-events: none !important;
        }

        .number-picker-table tbody.disabled,
        .number-picker-table tfoot.disabled {
            pointer-events: none;
            opacity: 0.3;
            position: relative;
        }

        .number-picker-table tbody.disabled::after,
        .number-picker-table tfoot.disabled::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.03) 10px,
                    rgba(0, 0, 0, 0.03) 20px);
            pointer-events: none;
        }

        [data-theme="dark"] .number-picker-table tbody.disabled::after,
        [data-theme="dark"] .number-picker-table tfoot.disabled::after {
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px);
        }

        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 1px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 44px;
            height: 44px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 15px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: #ffffff !important;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 1px;
        }

        /* Ensure child elements inside the place-box don't add extra padding */
        .place-box>* {
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        /* Compact style for trash mode dropdowns to save horizontal space */
        .trash-mode,
        select.trash-mode,
        .mode-selector select.trash-mode {
            width: auto !important;
            min-width: 90px;
            max-width: 140px;
            padding: 6px 8px;
            font-size: 13px;
        }

        /* Ensure specific trash selector in Cell6.6 matches height of other inputs */
        #cell6_6_trashSel {
            padding: 10px 12px !important;
            font-size: 13px !important;
            line-height: 1 !important;
            box-sizing: border-box !important;
            height: auto !important;
        }

        /* Stable IDs used for the two trash selectors (Cell5.5 / Cell6.5) */
        #cell6_5_trashSel,
        #cell5_5_trashSel {
            width: 100px;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        .image-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
        }

        [data-theme="dark"] .image-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .image-popup.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        .image-popup img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            border-radius: 8px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .image-popup img {
                max-width: 200px;
                max-height: 200px;
            }
        }

        nav {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .nav-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        .lienket-next-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 30px;
            padding: 0 8px;
            font-size: 14px;
            line-height: 1;
            border-radius: 6px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            box-sizing: border-box;
        }

        .lienket-prev-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 30px;
            padding: 0 8px;
            font-size: 14px;
            line-height: 1;
            border-radius: 6px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            box-sizing: border-box;
            margin-right: 6px;
        }

        .lienket-next-btn:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(56, 239, 125, 0.08);
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn.active {
            border-color: var(--accent);
            color: var(--highlight-text);
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            font-weight: 800;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
        }

        section h2 {
            margin: 0 0 12px;
            color: var(--text-strong);
            letter-spacing: 0.3px;
        }

        section p.lead {
            margin: 6px 0 16px;
            color: var(--muted);
        }

        .card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .card {
            background: var(--card);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 14px;
        }

        /* Remove right margin caused by inner child of the 6th control in Cell6.6 */
        #cell6_6>div>div.controls>div:nth-child(6)>* {
            margin-right: 0 !important;
        }

        /* More general: remove right margin from any child inside controls of #cell6_6
           This addresses nth-child(1) and similar cases where inner elements add extra spacing. */
        #cell6_6>div>div.controls>div>* {
            margin-right: 0 !important;
        }

        /* Specifically override inline margin set on JS-created drag input containers */
        #cell6_6 .controls .drag-input-container {
            margin-right: 0 !important;
            margin-left: 0 !important;
        }

        select,
        input,
        button {
            border-radius: 10px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            font-size: 13px;
        }

        select:focus,
        input:focus {
            outline: 1px solid var(--accent);
        }

        /* Hide number input spinner arrows */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100());
            border: none;
            color: var(--highlight-text);
            font-weight: 700;
            cursor: pointer;
        }

        button.ghost {
            background: var(--card);
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        [data-theme="dark"] table {
            background: var(--panel);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            z-index: 1;
        }

        /* Allow opt-out of sticky table headers for small popup tables
           — keep header visuals (background + text color) but disable sticky positioning */
        table.no-sticky thead {
            position: static !important;
            top: auto !important;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%) !important;
            color: white !important;
            z-index: auto !important;
        }

        th {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        /* Narrow column for Tổng % to keep layout compact */
        th.col-total,
        td.col-total {
            width: 110px;
            max-width: 140px;
            white-space: nowrap;
        }

        th:last-child {
            border-right: none;
        }

        td {
            padding: 5px 6px;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        /* Ensure Cell5.5 table cells center their content (date and result pills) */
        #cell5_5 table th,
        #cell5_5 table td {
            text-align: center !important;
            vertical-align: middle !important;
            display: table-cell !important;
        }

        [data-theme="dark"] td {
            border-color: var(--border);
        }

        td:last-child {
            border-right: none;
        }

        tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        tbody tr:nth-child(odd) {
            background: white;
        }

        [data-theme="dark"] tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        [data-theme="dark"] tbody tr:nth-child(odd) {
            background: transparent;
        }

        tbody tr:hover {
            background: #ffe6b3 !important;
        }

        [data-theme="dark"] tbody tr:hover {
            background: rgba(255, 230, 179, 0.2) !important;
        }

        /* Keep top ranks in Cell4 readable on dark theme */
        [data-theme="dark"] #cell4 tbody tr.rank-top td {
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr.rank-top .pill {
            background: #fffbea;
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr:nth-child(n+4) td[style*="background:linear-gradient"] {
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.15) 0%, rgba(56, 239, 125, 0.25) 100%) !important;
            color: #fff !important;
        }

        .pill {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: #e6f4ea;
            color: #0b8a60;
            white-space: nowrap;
            margin: 1px;
            font-family: monospace;
        }

        /* Euclid small framed pills (default style copied from day.html) */
        .euclid-pill {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            /* single soft orange for lower glare */
            background: #f8f333;
            color: #000;
            white-space: nowrap;
            margin: 0 1px 0 0;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }

        .euclid-pill.empty {
            opacity: 0.45;
        }

        /* Popup-scoped euclid pill appearance (keeps high-contrast pill look in info popup) */
        table.no-sticky .euclid-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 28px;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 900;
            background: #fffbea;
            color: var(--text-strong);
            margin: 0 6px 0 0;
            font-family: monospace;
            text-align: center;
            border: none;
            -webkit-text-stroke: 0.36px rgba(0, 0, 0, 0.6);
            text-shadow: 0 0 1px rgba(0, 0, 0, 0.22);
        }

        /* Color the pill text according to 5 rank tiers (1..5) inside popup only */
        table.no-sticky .euclid-pill.rank-tier-1 {
            color: #08eb56;
        }

        table.no-sticky .euclid-pill.rank-tier-2 {
            color: #00E5FF;
        }

        table.no-sticky .euclid-pill.rank-tier-3 {
            color: #1a62ea;
        }

        table.no-sticky .euclid-pill.rank-tier-4 {
            color: #ea3ade;
        }

        table.no-sticky .euclid-pill.rank-tier-5 {
            color: #ea0313;
        }

        /* Apply same rank-tier colors inside Cell4 rank column */
        #cell4 .rank-pill.rank-tier-1 {
            color: #08eb56;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-2 {
            color: #00E5FF;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-3 {
            color: #1a62ea;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-4 {
            color: #ea3ade;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-5 {
            color: #ea0313;
            font-weight: 800;
        }

        /* Info popup number pill (Số column) */
        table.no-sticky td.num-cell {
            text-align: center;
        }

        .info-num-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 22px;
            padding: 2px 4px;
            border-radius: 6px;
            background: #2e7d32;
            color: #ffffff;
            font-weight: 800;
            font-family: monospace;
            box-sizing: border-box;
        }

        /* Zero-occurrence number style shown in Cell5.5 info popup */
        .info-zero-num {
            color: #ff1744;
            /* bright red */
            font-weight: 900;
            background: rgba(255, 23, 68, 0.06);
            padding: 0px 2px;
            border-radius: 4px;
            margin-right: 2px;
            font-size: 13px;
            line-height: 1;
            display: inline-block;
            box-shadow: 0 1px 0 rgba(255, 23, 68, 0.06);
        }

        /* teal */

        .euclid-total-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 2px 5px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 800;
            background: #38ef7d;
            color: #072018;
            margin-left: 3px;
            font-family: monospace;
            min-width: 38px;
            text-align: center;
        }

        .label-chip {
            display: inline-block;
            min-width: 18px;
            padding: 2px 5px;
            margin: 1px 2px 1px 0;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-weight: 700;
            background: transparent;
            color: inherit;
        }

        .label-chip.highlight {
            background: var(--highlight-bg);
            color: var(--highlight-text);
        }

        /* Highlight class applied to number cells in the popup when hovering a group row.
           Use an outline + stronger box-shadow and z-index so the orange accent isn't
           visually obscured by darker 'selected/disabled' backgrounds or competing rules. */
        #numberPickerPopup #numberPickerTable td.popup-number-highlight {
            /* Thicker visible outline with inward emphasis (inner glow)
               Keep properties conservative to avoid linter noise. */
            outline: 4px solid #ff8c00;
            outline-offset: 2px;
            /* Outer soft glow + subtle ring to increase perceived thickness */
            box-shadow:
                0 10px 24px rgba(255, 140, 0, 0.10),
                /* outer soft shadow */
                0 0 0 6px rgba(255, 140, 0, 0.06),
                /* mid ring */
                inset 0 0 0 4px rgba(255, 140, 0, 0.18);
            /* inner thickening */
            position: relative;
            z-index: 1100;
        }

        [data-theme="dark"] .pill {
            background: rgba(56, 239, 125, 0.15);
            color: #38ef7d;
        }

        /* Prevent pill containers from wrapping.
           The selector `:has()` isn't supported in some editors/linters —
           provide a compatible class-based fallback and a tiny JS shim
           that marks `td` elements containing `.pill` with `.td-has-pill`. */
        td.td-has-pill {
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .pill {
                font-size: 10px;
                padding: 2px 5px;
                margin: 1px;
            }

            th,
            td {
                padding: 4px 6px;
                font-size: 11px;
            }
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid>* {
            flex: 1 1 350px;
            min-width: 0;
        }

        .grid-centered {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .grid-centered>* {
            flex: 0 1 calc(33.333% - 10px);
            max-width: 600px;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            .grid>* {
                flex: 1 1 100%;
            }

            .grid-centered>* {
                flex: 1 1 100%;
                max-width: none;
            }
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            padding: 3px 8px;
            border-radius: 8px;
            background: var(--accent-2);
            color: white;
            font-weight: 700;
            font-size: 12px;
            opacity: 0.9;
        }

        main {
            padding: 16px 12px 32px;
        }

        section {
            margin: 20px 0;
            padding: 16px;
        }

        /* Performance: skip rendering offscreen content like large apps do */
        section {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 800px 600px;
        }

        .card {
            content-visibility: auto;
            contain: content;
        }

        /* Marker for cards nested inside "card-inner" wrappers.
           JS will add the class 'card-inner-child' to any .card inside .card.card-inner.
           Use this selector to style inner cards separately. */
        .card-inner-child {
            /* empty by default; add overrides as needed */
            box-sizing: border-box;
            /* harmless default to avoid empty-selector warning */
        }

        /* Layout rule: make the inner wrapper a flex container so we can
           enforce max 2 child cards per row. Each child gets up to 50%
           width and will be centered when it's the only child. */
        .card.card-inner {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-start;
        }

        .card.card-inner>.card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* Some renderers create .card elements nested deeper than direct children.
           Ensure any descendant marked with .card-inner-child gets the same sizing. */
        .card.card-inner .card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* When a .card.card-inner contains exactly one inner card, center that
           inner card horizontally and allow it to size to its content (up to
           the wrapper width). This centers narrow tables while still allowing
           wider tables to grow up to the container. */
        .card.card-inner.single-child {
            justify-content: center;
        }

        .card.card-inner.single-child .card-inner-child {
            flex: 0 1 auto !important;
            max-width: 100% !important;
            width: auto !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* Override for Cell5.5: when a row contains exactly one table,
           do not center it — render normally left-to-right. */
        #cell5_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell5_5 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            /* keep natural width and flow left-to-right */
            flex: 0 1 auto !important;
            width: auto !important;
            max-width: none !important;
        }

        /* Also ensure the table itself isn't centered by inherited rules */
        #cell5_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Prefer intrinsic table width inside a centered single child; allow
           the table to grow up to the wrapper width but not force 100% width. */
        .card.card-inner.single-child .card-inner-child table {
            width: auto !important;
            max-width: 100% !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* If a wrapper contains a single child, center it horizontally */
        .card.card-inner>.card-inner-child:only-child {
            margin-left: auto;
            margin-right: auto;
        }

        /* Ensure the grid container used by Cell5.5 aligns children left-to-right
           instead of centering them (this container holds the paged tables). */
        #cell5_5 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        /* Same behavior for Cell6.5: don't center its grid/cards when only one child/table */
        #cell6_5 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        #cell6_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell6_5 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
            flex: 0 1 auto !important;
        }

        #cell6_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Clear any :only-child centering inside cell6_5 */
        #cell6_5 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Same behavior for Cell6.6: don't center its grid/cards when only one child/table */
        #cell6_6 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        #cell6_6 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell6_6 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
            flex: 0 1 auto !important;
        }

        #cell6_6 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Clear any :only-child centering inside cell6_6 */
        #cell6_6 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Small screens: stack to single column */
        @media (max-width: 768px) {
            .card.card-inner>.card-inner-child {
                flex: 0 0 100%;
                max-width: 100%;
            }
        }

        /* Reduce paint/layout when card bodies are offscreen */
        .card-body {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 200px 120px;
        }

        @media (min-width: 768px) {
            main {
                padding: 24px 18px 48px;
            }

            section {
                margin: 32px 0;
                padding: 22px;
            }
        }

        .error {
            color: #fca5a5;
            font-weight: 600;
        }

        .success {
            color: #34d399;
            font-weight: 700;
        }

        .loader {
            text-align: center;
            color: var(--muted);
            padding: 16px 0;
        }

        .flex {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        a.anchor {
            color: inherit;
            text-decoration: none;
        }

        .hidden {
            display: none;
        }

        /* Flash highlight after copying a row */
        tr.copied-row {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Persistent highlight when a record is Ctrl+clicked in Cell5.5 */
        tr.ctrl-selected {
            outline: 3px solid #FFD500;
            /* yellow */
            outline-offset: -3px;
        }

        /* Fallback highlight using inset box-shadow on cells so clipping doesn't hide the outline */
        tr.ctrl-selected td {
            box-shadow: inset 0 0 0 3px #FFD500;
            background-clip: padding-box;
        }

        /* Floating scroll-to-top button (uses variables so mirror can be computed on body) */
        #scrollToTop {
            position: fixed;
            bottom: var(--scroll-btn-offset);
            right: var(--scroll-btn-right);
            width: var(--scroll-btn-size);
            height: var(--scroll-btn-size);
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: calc(var(--scroll-btn-size) * 0.48);
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToTop:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToTop:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            body {
                --scroll-btn-offset: 20px;
                --scroll-btn-size: 45px;
                --scroll-btn-right: 20px;
            }

            #scrollToTop {
                font-size: calc(var(--scroll-btn-size) * 0.44);
            }
        }

        /* Scroll to bottom button: vertically mirrored relative to scrollToTop (uses same vars) */
        #scrollToBottom {
            position: fixed;
            /* place below header so it's the mirror across the midpoint of the remaining body
               remaining midpoint derivation simplifies to top = header + offset */
            top: calc(var(--header-height) + var(--scroll-btn-offset));
            right: var(--scroll-btn-right);
            width: var(--scroll-btn-size);
            height: var(--scroll-btn-size);
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: calc(var(--scroll-btn-size) * 0.48);
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToBottom:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToBottom:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #scrollToBottom {
                font-size: calc(var(--scroll-btn-size) * 0.44);
            }
        }

        /* Close button for number picker popup */
        .number-picker-close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255, 67, 67, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .number-picker-close-btn:hover {
            background: rgba(255, 67, 67, 1);
            transform: scale(1.1);
        }

        .number-picker-close-btn:active {
            transform: scale(0.95);
        }

        /* Canvas overlay for drawing connections */
        #connectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Make controls inside Cell8/9/10/11 stick under the header when scrolling.
           Keep them in normal flow so they match other sections visually.
        */
        #cell5_5 .controls,
        #cell6_5 .controls,
        #cell6_6 .controls,
        #cell8 .controls,
        #cell9 .controls,
        #cell10 .controls,
        #cell11 .controls {
            position: sticky;
            top: 64px;
            /* space for sticky header */
            z-index: 11;
            /* blue-gray → dark-gray gradient to match normal section look */
            background: linear-gradient(135deg, #334155 0%, #1f2937 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px 12px;
            margin: 0 0 14px 0;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        /* Some browsers prevent sticky when an ancestor uses 'contain' or
           'content-visibility'. Disable containment for this specific
           section so the controls can stick correctly. */
        #cell5_5,
        #cell6_5,
        #cell6_6,
        #cell8,
        #cell9,
        #cell10,
        #cell11 {
            contain: none;
            content-visibility: visible;
        }

        /* JS fallback will add this class when it needs to pin the controls */
        .controls.stuck {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.24);
            transition: box-shadow 0.12s ease;
        }

        /* Mode selector two-row layout + swap control */
        .mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .mode-rows {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .mode-row {
            display: flex;
            gap: 6px;
            align-items: center;
            /* Keep controls on a single row; allow horizontal scroll when space is tight */
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .mode-rows.reversed {
            flex-direction: column-reverse;
        }

        #swapRowsBtn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
        }

        /* === Exact place styles copied from day.html to match visuals === */
        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 54px;
            height: 54px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: #ffffff !important;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 3px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        /* === End copied styles === */

        /* FINAL OVERRIDE: ensure Cell5.5 single-table outputs are left-aligned.
           This rule is placed last and uses high specificity + !important so
           it wins over earlier centering rules. */
        #cell5_5.card .card.card-inner.single-child,
        #cell5_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell5_5 .card.card-inner.single-child .card-inner-child,
        #cell5_5.card .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
        }

        /* Override the generic rule that centers tables inside single-child wrappers */
        #cell5_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* If any :only-child centering rule remains, specifically clear it inside #cell5_5 */
        #cell5_5 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Trash popup styles */
        #trashPopup {
            position: absolute;
            z-index: 10001;
            left: calc(-1 * (var(--trash-width, 420px) + 12px));
            top: 8px;
            display: none;
            background: var(--card);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            overflow-y: auto;
            overflow-x: hidden;
            /* prevent horizontal scrollbar */
            transform: none !important;
            will-change: width, height, left, top;
        }

        /* Cell5.5 count highlight */
        .cell5-count-x {
            font-weight: 800;
            color: var(--text-strong);
            display: inline-block;
        }

        #trashPopup table {
            width: 100%;
            max-width: var(--trash-width);
            border-collapse: collapse;
            table-layout: fixed;
            transform: none !important;
            table-layout: fixed;
        }

        #trashPopup td {
            padding: 6px;
            text-align: center;
            vertical-align: middle;
            cursor: grab;
            box-sizing: border-box;
        }

        /* Each trash cell: 3 columns, responsive and keep aspect ratio */
        #trashPopup td {
            width: calc(100% / 3);
            max-width: calc(100% / 3);
            aspect-ratio: 1 / 1.732;
            /* height = width / 1.732 */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 6px;
            /* ensure consistent padding inside cells */
            box-sizing: border-box;
        }

        #trashPopup td.trash-number {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            font-weight: 700;
            border: 2px solid var(--connection-line-color);
            /* keep td as a table-cell so the table layout enforces 3 columns
               use an inner wrapper for flex layout instead of changing td display */
        }

        /* inner flex wrapper inside each trash cell to position rank and number */
        #trashPopup td.trash-number>.trash-inner {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            min-width: 0;
            /* allow flex children to shrink to prevent overflow */
            overflow: hidden;
        }

        #trashPopup td.trash-number:active {
            cursor: grabbing;
        }

        /* rank/pill should appear left of the main number */
        #trashPopup td.trash-number .rank-in-cell,
        #trashPopup td.trash-number .pill {
            margin-right: 6px;
            order: 0;
        }

        #trashPopup td.trash-number .number-main,
        #trashPopup td.trash-number span:not(.pill):not(.rank-in-cell) {
            order: 1;
        }

        /* Hidden state for numbers removed into trash
           keep the table cell as a placeholder so other cells don't shift */
        #numberPickerTable td.in-trash {
            visibility: hidden !important;
            pointer-events: none !important;
            background: transparent !important;
        }

        /* Show a red flagged style for trashed numbers when shown inside the
           number-picker popup. This overrides the global hidden state so the
           popup can visually indicate items that were moved to trash. */
        #numberPickerPopup #numberPickerTable td.in-trash {
            visibility: visible !important;
            pointer-events: none !important;
            /* Bright red background and high-contrast white text */
            background: #ff1744 !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
        }

        /* Hide all visible content (rank badges and main number) inside
           trashed cells when rendered in the popup. This keeps the cell
           visually flagged red but removes readable text/rank. */
        #numberPickerPopup #numberPickerTable td.in-trash .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash .pill,
        #numberPickerPopup #numberPickerTable td.in-trash .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash>span:not(.rank-in-cell):not(.pill) {
            display: none !important;
            visibility: hidden !important;
        }

        /* Keep trashed cells visibly red for direct hover/selection/inline-style.
           Exclude `.popup-number-highlight` here so the split-gradient
           pseudo-element can render the left-dark/right-red highlight. */
        #numberPickerPopup #numberPickerTable td.in-trash:hover,
        #numberPickerPopup #numberPickerTable td.in-trash.selected-number,
        #numberPickerPopup #numberPickerTable td.in-trash[style] {
            background: #ff1744 !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
            outline: none !important;
        }

        /* Additional hard override: ensure no descendant text or inline styles
           inside popup trashed cells can show green/black text. This forces
           children to be hidden and text to be transparent even under hover,
           highlight, selection, or inline-style overrides applied by JS. */
        #numberPickerPopup #numberPickerTable td.in-trash *,
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash *,
        .number-picker-popup #numberPickerTable td.in-trash * {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            color: transparent !important;
            pointer-events: none !important;
        }

        /* Extra overlay: create an absolutely positioned red layer that fully
           covers the trashed cell. This prevents other styling (outline,
           box-shadow, or pseudo-elements) from visually overriding the red
           background during transient hover/selection updates. */
        #numberPickerPopup #numberPickerTable td.in-trash {
            position: relative !important;
            z-index: 2000 !important;
            transition: none !important;
            -webkit-transition: none !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash::before {
            content: '' !important;
            position: absolute !important;
            inset: 0 !important;
            background: #ff1744 !important;
            border-radius: inherit !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
            z-index: 2001 !important;
            pointer-events: none !important;
        }

        /* Dimmed overlay for trashed numbers that are also present in place boxes.
           This shows a 50% red overlay but keeps the cell contents visible. It
           overrides the heavier in-trash rules above when the additional
           `in-trash-dim` class is present. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            visibility: visible !important;
            pointer-events: none !important;
            background: rgba(255, 23, 68, 0.5) !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            position: relative !important;
            z-index: 2000 !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::before {
            background: rgba(255, 23, 68, 0.5) !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            z-index: 2001 !important;
            pointer-events: none !important;
        }

        /* Ensure children of dimmed trashed cells remain visible (undo the
           global hide rules for plain trashed items). Keep pointer-events off
           so interaction remains disabled while the visual remains readable. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim * {
            display: revert !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            pointer-events: none !important;
        }

        /* Ensure dim overlay persists when JS toggles highlight/selection/inline styles
           which previously forced a full-red overlay via higher-specificity selectors. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number::before,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]::before,
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before {
            background: rgba(255, 23, 68, 0.5) !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            z-index: 3000 !important;
            pointer-events: none !important;
        }

        /* Ensure the orange outline remains visible for dimmed trashed cells
           that are highlighted by group hover. Lower the overlay z-index so
           the outline (drawn on the cell) appears above the pseudo-element. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight {
            outline: 4px solid #ff8c00 !important;
            outline-offset: 2px !important;
            position: relative !important;
            z-index: 4000 !important;
        }

        /* Push the dim ::before overlay beneath the cell's outline when highlighted */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before {
            z-index: 2000 !important;
        }

        /* Also ensure children remain visible under these transient states */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight *,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number *,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] * {
            display: revert !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            pointer-events: none !important;
        }

        /* Also ensure highlighted/selected variants keep the overlay intact.
           When a trashed number is highlighted (hovering a record that maps
           to this number), show a left-dark / right-red split so the UI
           clearly indicates both 'flagged' and 'highlighted' states. */
        /* Highlight-on-hover (record hover -> popup-number-highlight): split background */
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Keep fully-red overlay for selected/explicitly-styled trashed cells */
        #numberPickerPopup #numberPickerTable td.in-trash.selected-number::before,
        .number-picker-popup #numberPickerTable td.in-trash[style]::before {
            background: #ff1744 !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
        }

        /* Stronger rule: when a trashed cell is also highlighted via
           `popup-number-highlight`, prefer the split appearance even if
           `selected-number` or inline styles are present. This wins by
           being more specific and placed after the full-red rule. */
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight.selected-number::before,
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight[style]::before,
        .number-picker-popup #numberPickerTable td.in-trash.popup-number-highlight::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Small visual for the trash button when active */
        #trashBtn {
            background: transparent;
            border: 1px solid var(--border);
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
        }

        #trashBtn.disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        #trashToggle {
            background: var(--card);
            border: 1px solid var(--border);
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
        }

        /* Stronger enforcement: ensure the split (50% dark / 50% red)
           gradient appears for trashed popup cells when they are highlighted.
           This rule is very specific and placed at the end of the stylesheet
           so it wins over earlier full-red overrides (including inline-style
           based selectors). */
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash.popup-number-highlight::before,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight::before,
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight[style]::before,
        .number-picker-popup #numberPickerTable td.in-trash.popup-number-highlight[style]::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Additional overrides: ensure trashed-but-present cells show the
       split overlay while keeping number and rank text visible and in
       their intended colors. Inserted to win over earlier hiding rules. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            position: relative;
            isolation: isolate;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(56, 239, 125, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 0;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Explicit rules to ensure number text and rank/pill remain visible
           for trashed items that are also present in place boxes (in-trash-dim).
           These selectors override earlier hiding rules and make text render
           above the split overlay. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            position: relative;
            isolation: isolate;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(56, 239, 125, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 0;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Unhide the specific spans that were previously hidden for trashed cells */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>span:not(.rank-in-cell):not(.pill) {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            font-weight: 700 !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Ensure the above also applies during transient highlight/selection or when inline styles are present */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>span:not(.rank-in-cell):not(.pill),
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>span:not(.rank-in-cell):not(.pill),
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>span:not(.rank-in-cell):not(.pill) {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            font-weight: 700 !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Neutralize underlying cell color and render a crisp split overlay
           using exact colors requested: left #1a2a3a, right #ff1744. Keep
           text above overlays so number and rank remain readable. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            background: transparent !important;
            box-shadow: none !important;
            position: relative;
            isolation: isolate;
        }

        /* Remove earlier ::before full-red overlays (if present) */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::before {
            display: none !important;
            content: none !important;
        }

        /* Split overlay: left half #1a2a3a, right half #ff1744 at 50% opacity
           so underlying theme doesn't change perceived color too much. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(26, 42, 58, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: normal;
        }

        /* Ensure content renders above overlays */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 2;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Also enforce during transient highlight/selection or when inline styles
           are applied by JS so overlay remains visible and text keeps color */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>* {
            position: relative;
            z-index: 2;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Compact k input and keep trash popup header on one line */
        #trashPopup>div:first-child {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
        }

        #trashPopup input[type="number"] {
            width: 56px;
            min-width: 40px;
            max-width: 88px;
            padding: 4px 6px;
            box-sizing: border-box;
            font-size: 13px;
            display: inline-block;
            vertical-align: middle;
        }

        /* Prioritize a class if present for the k field */
        #trashPopup .k-input,
        #trashPopup input.k-input {
            width: 56px;
        }

        /* Override the inline style applied to the specific input #trashKInput */
        #trashPopup #trashKInput {
            width: 56px !important;
            min-width: 40px !important;
            max-width: 88px !important;
            padding: 4px 6px 4px 8px !important;
            padding-right: 26px !important;
            /* make room for compact spinner */
            box-sizing: border-box !important;
            font-size: 13px !important;
            display: inline-block !important;
            vertical-align: middle !important;
        }

        /* Keep average-k label on one line and prevent wrapping */
        #trashPopup .avg-k {
            white-space: nowrap;
            margin-left: 8px;
            flex: 0 0 auto;
            display: inline-block;
            align-self: center;
        }
    </style>
</head>

<body>
    <header>
        <div class="topbar">
            <div class="brand">Life Notebook
                <span id="htmlBadge">HTML</span>
            </div>
            <nav id="nav"></nav>
            <button class="theme-toggle" id="themeToggle" title="Chuyển giao diện">🌓</button>
        </div>
    </header>
    <div class="image-popup" id="imagePopup">
        <img src="anh.png" alt="Preview">
    </div>
    <!-- Number Picker Popup (copied from index.html) -->
    <div class="number-picker-popup" id="numberPickerPopup">
        <button class="number-picker-close-btn" id="closeNumberPickerBtn" title="Đóng">✕</button>
        <table class="number-picker-table" id="numberPickerTable">
            <!-- Generated by JS -->
        </table>
        <div class="place-container">
            <div class="places-grid" id="placesGrid">
                <!-- Generated by JS: 6 place boxes V1-V6 -->
            </div>
        </div>
        <div class="mode-selector" id="modeSelectorContainer">
            <div class="mode-rows reversed" id="modeRows">
                <div class="mode-row" id="modeRowRank"
                    style="font-size:14px;gap:8px;align-items:center;display:flex;justify-content:space-between;width:100%;order:999;">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <button id="trashBtn" title="Thùng rác">🗑️</button>
                        <button id="trashToggle" title="Bật thùng rác">Off</button>
                    </div>
                    <div id="rankSummary"
                        style="font-size:14px;font-weight:700;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:0 auto;">
                    </div>
                </div>
                <div class="mode-row" id="modeRowTop">
                    <label style="font-size: 12px;">Mode:</label>
                    <button id="modeSelector"
                        style="width: 100px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);">Số
                        (1-45)</button>
                    <button id="clearPlaceBtn" class="clear-btn" title="Xóa toàn bộ place"
                        style="padding: 6px 10px; font-size: 12px;">Xóa</button>
                    <label style="margin-left:6px;font-size:12px;">Rank:</label>
                    <button id="rankToggle"
                        style="width:80px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">rank</button>
                    <label style="margin-left:6px;font-size:12px;">Hover:</label>
                    <button id="quickPlaceToggle"
                        style="width:auto;min-width:48px;font-size:11px;padding:6px 4px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);box-sizing:border-box;max-width:100%;"
                        title="Toggle hover mode: 'Normal' = dblclick copies; 'Hover' = hover fills places">Normal</button>
                </div>
                <div class="mode-row" id="modeRowBottom">
                    <label style="margin-left: 6px; font-size: 12px;" id="connectionToggleLabel">Nối:</label>
                    <button id="connectionToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiện/ẩn đường nối giữa các số liên tiếp">Hiện</button>
                    <label style="font-size: 12px;" id="euclidToggleLabel">Euclid:</label>
                    <button id="euclidToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiện/ẩn hiển thị khoảng cách Euclid">Hiện</button>
                    <span id="euclidTotal"
                        style="margin-left:8px;font-size:13px;font-weight:700;color:var(--text-strong);opacity:1;">Σ:&nbsp;&nbsp;
                        <span id="euclidTotalValue"
                            style="color:#38ef7d;font-weight:900;margin-left:8px;font-size:16px;text-shadow:0 0 8px rgba(56,239,125,0.22);">0.00</span>
                    </span>
                </div>
            </div>
        </div>
    </div>
    <button id="scrollToTop" title="Quay về đầu trang">↑</button>
    <button id="scrollToBottom" title="Xuống cuối trang">↓</button>
    <main>
        <div id="status" class="card" style="margin-bottom:18px;">Đang tải dữ liệu...</div>
        <!-- Sections injected by JS -->
    </main>

    <script>
        // ===== Helpers from notebook =====
        const COL_MAP = { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 2, 10: 2, 11: 2, 12: 2, 13: 2, 14: 2, 15: 2, 16: 2, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 3, 23: 3, 24: 3, 25: 4, 26: 4, 27: 4, 28: 4, 29: 4, 30: 4, 31: 4, 32: 5, 33: 5, 34: 5, 35: 5, 36: 5, 37: 5, 38: 5, 39: 6, 40: 6, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6 };
        const getCol = (v) => COL_MAP[v] ?? 0;

        // Safe focus helper: prefer preventing scroll when moving focus programmatically
        function safeFocus(el) {
            if (!el) return;
            try {
                el.focus({ preventScroll: true });
            } catch (e) {
                try { el.focus(); } catch (e2) { /* ignore */ }
            }
        }
        // ===== Web Worker Setup =====
        // Tạo web worker inline để xử lý tính toán nặng
        const workerCode = `
            // Helpers for worker
            const compareKey = (a, b) => { const pa = a.split("-").map(Number); const pb = b.split("-").map(Number); for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; } return pa.length - pb.length; };

            function kCombinations(set, k) {
                const combs = [];
                const recur = (start, combo) => {
                    if (combo.length === k) { combs.push([...combo]); return; }
                    for (let i = start; i < set.length; i++) { combo.push(set[i]); recur(i + 1, combo); combo.pop(); }
                };
                recur(0, []);
                return combs;
            }

            self.onmessage = (e) => {
                const { rows, xSel, consec, order, sortSel, workerType } = e.data;
                if (workerType === 'groupBySet') {
                    const x = parseInt(xSel, 10);
                    const groups = new Map();

                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            // Always enumerate combinations of size x from the 6 numbers.
                            // This ensures sets like size 5 (and 6) are counted correctly
                            // rather than only checking consecutive slices.
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                });
                            }
                        });

                    let arr = [...groups.entries()].filter(([, indices]) => indices.size >= 2);
                    if (sortSel === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sortSel === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sortSel === "count_asc") arr.sort((a, b) => a[1].size - b[1].size);
                    else arr.sort((a, b) => b[1].size - a[1].size);

                    self.postMessage({ result: arr.map(([k, v]) => [k, Array.from(v)]) });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        let worker = null;

        const getWorker = () => {
            if (!worker) worker = new Worker(workerUrl);
            return worker;
        };

        // ===== Data Loading =====
        let rows = [];
        async function loadData() {
            const status = document.getElementById("status");
            try {
                // Expect data.json in format: [{"date": "2024-01-01", "Result": "1,2,3,4,5,6"}, ...]
                const res = await fetch("data.json");
                if (!res.ok) throw new Error("Không tìm thấy data.json. Hãy xuất từ Excel trước.");
                const raw = await res.json();
                // Parse rows and normalize dates into a Date object + display string
                function parseDateString(raw) {
                    if (raw === undefined || raw === null) return { parsedDate: null, displayDate: '' };
                    let s = String(raw).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    if (s.includes('/')) {
                        const parts = s.split('/').map(p => p.trim());
                        if (parts.length >= 3) {
                            let [dd, mm, yy] = parts;
                            dd = dd.padStart(2, '0');
                            mm = mm.padStart(2, '0');
                            if (yy.length === 2) yy = '20' + yy;
                            const date = new Date(Number(yy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yy}` };
                        }
                    }
                    // only digits: try ddmmyyyy or ddmmyy (padded)
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = digits.slice(0, 2), mm = digits.slice(2, 4), yyyy = digits.slice(4, 8);
                            const date = new Date(Number(yyyy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                        }
                        // pad to 6 digits (ddmmyy) — handles numbers like 10117 -> 010117
                        const d6 = digits.padStart(6, '0');
                        const dd = d6.slice(0, 2), mm = d6.slice(2, 4), yy = d6.slice(4, 6);
                        const yyyy = 2000 + Number(yy);
                        const date = new Date(yyyy, Number(mm) - 1, Number(dd));
                        if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    // fallback to Date.parse
                    const dt = new Date(s);
                    if (!isNaN(dt)) {
                        const dd = String(dt.getDate()).padStart(2, '0');
                        const mm = String(dt.getMonth() + 1).padStart(2, '0');
                        const yyyy = dt.getFullYear();
                        return { parsedDate: dt, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    return { parsedDate: null, displayDate: s };
                }

                // Treat `date` as raw display string (don't attempt heavy parsing).
                rows = raw
                    .map(r => {
                        if (!r.Result || typeof r.Result !== "string") return null;
                        const nums = r.Result.split(",").map(x => parseInt(x.trim(), 10)).filter(Number.isInteger);
                        if (nums.length !== 6) return null;
                        const dateStr = String(r.date ?? r.Date ?? r.dateStr ?? r["date"] ?? '');
                        return { dateRaw: dateStr, date: dateStr, parsedDate: null, nums, label: nums.map(getCol).join("") };
                    })
                    .filter(Boolean);
                status.innerHTML = `<span class="success">Đã tải ${rows.length} dòng</span> · file: data.json`;
            } catch (err) {
                status.innerHTML = `<span class="error">${err.message}</span><br/><span class="muted">Tạo file data.json từ Excel bằng script python: <code>python - <<'PY'\nimport pandas as pd, json\ndf = pd.read_excel('data.xlsx')\nout = df[['date','Result']]\nout.to_json('data.json', orient='records', force_ascii=False, indent=2)\nPY</code></span>`;
            }
        }

        // ===== Utilities =====
        let decimalPlaces = 2; // default decimal places for percentage
        const fmtPct = (v) => `${(v * 100).toFixed(decimalPlaces)}%`;
        const fmtPctCustom = (v, decimals) => `${(v * 100).toFixed(decimals)}%`;
        const MATCH_STYLE = "background:#2e7d32;color:#fff;"; // dark green with white text for matched values

        // Helpers to highlight numbers inside the number-picker popup
        function clearPopupHighlights() {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            tbl.querySelectorAll('td.popup-number-highlight').forEach(td => td.classList.remove('popup-number-highlight'));
        }

        function applyPopupHighlights(nums) {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            clearPopupHighlights();
            // Only apply the orange popup highlight when quick-place mode is 'hover'
            try {
                const inHover = (window.getQuickPlaceMode && window.getQuickPlaceMode() === 'hover');
                if (!inHover) return;
            } catch (e) { return; }
            nums.forEach(n => {
                try {
                    const td = tbl.querySelector(`td[data-number="${n}"]`);
                    // Allow highlighting for trashed numbers too so the popup can
                    // render a split overlay (left dark / right red).
                    // Also allow highlighting disabled cells so group-hover
                    // highlights remain visible even when numbers are disabled.
                    if (td) {
                        td.classList.add('popup-number-highlight');
                    }
                } catch (e) { /* ignore */ }
            });
        }

        // Debounce helper to prevent excessive function calls
        const createDebounce = (fn, delay = 100) => {
            let timeout;
            return function debounced(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        };

        // Throttle helper for smoother updates
        const createThrottle = (fn, delay = 100) => {
            let lastCall = 0;
            return function throttled(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return fn.apply(this, args);
                }
            };
        };

        // Double-click any table row that has data-result to copy its result string (format: 1,2,3,4,5,6)
        const handleRowCopyDblClick = (e) => {
            const row = e.target.closest("tr[data-result]");
            if (!row || !row.dataset.result) return;
            // Always allow dblclick-copy regardless of quick-place mode
            const text = row.dataset.result;

            const flash = () => {
                row.classList.add("copied-row");
                setTimeout(() => row.classList.remove("copied-row"), 500);
            };

            const fallbackCopy = () => {
                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.top = "-9999px";
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    document.execCommand("copy");
                    document.body.removeChild(ta);
                    flash();
                } catch (_) { /* ignore */ }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(flash).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        };

        // Global listener to catch all dynamic tables
        document.addEventListener('dblclick', handleRowCopyDblClick, true);

        // Global mouseover: apply popup highlights when hovering any record row
        // and clear when moving to a different card. This centralizes the
        // hover->popup behavior so all cells (cell6, cell6.5, cell6.6, etc.)
        // behave consistently.
        document.addEventListener('mouseover', (ev) => {
            try {
                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                const cardEl = tr ? tr.closest('.card') : null;

                // If hovering a result row, try to find the header <strong>{...}</strong>
                // in the same card and use it to compute popup highlights.
                if (tr && cardEl) {
                    const s = cardEl.querySelector('strong');
                    if (s && s.textContent) {
                        const nums = String(s.textContent || '').replace(/[{}]/g, '')
                            .split(/[^0-9]+/).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
                        if (nums.length) {
                            try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                            applyPopupHighlights(nums);
                            return;
                        }
                    }
                }

                // Otherwise, if moving to a different card, clear existing highlights
                const src = window.__popupHighlightSource || null;
                if (src && cardEl && cardEl !== src) {
                    clearPopupHighlights();
                    try { window.__popupHighlights = null; window.__popupHighlightSource = null; } catch (e) { }
                }
            } catch (e) { /* ignore */ }
        }, true);

        const anchorNav = [
            { id: "cell4", label: "Cell4 · Tỷ lệ theo vị trí" },
            { id: "cell5", label: "Cell5 · Xếp hạng vị trí" },
            { id: "cell5_5", label: "Cell5.5 · Lịch sử" },
            { id: "cell6", label: "Cell6 · Cặp phổ biến" },
            { id: "cell6_5", label: "Cell6.5 · Truy x" },
            { id: "cell6_6", label: "Cell6.6 · Mổ pattern" },
            { id: "cell7", label: "Cell7 · Nhóm label" },
            { id: "cell8", label: "Cell8 · Tìm label" },
            { id: "cell9", label: "Cell9 · Tổ hợp tùy chọn" },
            { id: "cell10", label: "Cell10 · Phân tích vị trí" },
            { id: "cell11", label: "Cell11 · Pattern số" },
        ];

        function buildNav(showSection) {
            const nav = document.getElementById("nav");
            anchorNav.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "nav-btn";
                btn.textContent = item.label;
                btn.dataset.target = item.id;
                btn.onclick = () => {
                    // Lazy render the section only when needed
                    if (typeof ensureRendered === 'function') {
                        ensureRendered(item.id);
                    }
                    showSection(item.id);
                    history.replaceState(null, "", `#${item.id}`);
                };
                nav.appendChild(btn);
            });
        }

        // ===== Renderers =====
        // Fallback: capture Ctrl+clicks on rows inside section#cell11 (use capture so it runs before other handlers)
        document.addEventListener('click', (ev) => {
            try {
                if (!ev || !ev.ctrlKey) return;
                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                if (!tr) return;
                const section = tr.closest('section');
                if (!section || section.id !== 'cell11') return;
                ev.preventDefault();
                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                if (!result) return;
                const nums = parseSixNumbersFromString(result);
                if (!nums) return;
                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                tr.classList.add('ctrl-selected');
                try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
            } catch (e) { /* ignore */ }
        }, true);
        function sectionShell(id, title, lead = "") {
            const sec = document.createElement("section");
            sec.id = id;
            sec.dataset.section = id;
            const h2 = document.createElement("h2");
            h2.textContent = title;
            sec.appendChild(h2);
            if (lead) {
                const p = document.createElement("p");
                p.className = "lead";
                p.textContent = lead;
                sec.appendChild(p);
            }
            const body = document.createElement("div");
            sec.appendChild(body);
            document.querySelector("main").appendChild(sec);
            return body;
        }

        // Quản lý hiển thị từng "trang" (section) mà không mất state
        function createSectionSwitcher() {
            const main = document.querySelector("main");
            const buttons = () => Array.from(document.querySelectorAll(".nav-btn"));
            const sections = () => Array.from(main.querySelectorAll("section"));
            const scrollPositions = new Map(); // Lưu vị trí scroll cho từng section

            function setActive(id) {
                // Lưu vị trí scroll hiện tại trước khi chuyển
                const currentSection = sections().find(sec => !sec.classList.contains("hidden"));
                if (currentSection) {
                    scrollPositions.set(currentSection.id, window.scrollY);
                }

                buttons().forEach(btn => {
                    const active = btn.dataset.target === id;
                    btn.classList.toggle("active", active);
                });
                sections().forEach(sec => {
                    sec.classList.toggle("hidden", sec.id !== id);
                });

                // notify other components which section is now active
                try { document.dispatchEvent(new CustomEvent('sectionchange', { detail: { id } })); } catch (e) { }

                // Restore vị trí scroll của section mới
                requestAnimationFrame(() => {
                    // Prefer per-input saved scroll for cell10 when available
                    let savedPosition;
                    try {
                        if (id === 'cell10' && window._cell10LastIndex !== undefined && window._cell10LastIndex !== null && window._cell10ScrollByIndex instanceof Map) {
                            const p = window._cell10ScrollByIndex.get(window._cell10LastIndex);
                            if (p !== undefined) savedPosition = p;
                        }
                    } catch (e) { }

                    if (savedPosition === undefined) savedPosition = scrollPositions.get(id);
                    if (savedPosition !== undefined) {
                        window.scrollTo(0, savedPosition);
                    } else {
                        window.scrollTo(0, 0); // Scroll về đầu nếu chưa có lịch sử
                    }
                });
            }

            function showSection(id) {
                const target = sections().find(sec => sec.id === id);
                const fallback = "cell4";
                const finalId = target ? id : fallback;
                setActive(finalId);
            }

            return showSection;
        }


        function renderCell4() {
            const body = sectionShell("cell4", "Cell4 · Tỷ lệ theo vị trí (home)", "Top/Sort tương tự notebook: hiển thị tỷ lệ từng số theo 6 vị trí.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[10, "Top 10"], [20, "Top 20"], [30, "Top 30"], [45, "Tất cả (45)"]].forEach(([v, l]) => {
                const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o);
            });
            topSel.value = "45";
            const sortSel = document.createElement("select");
            [["default", "Mặc định (1→45)"], ["total_desc", "Theo tổng % giảm dần"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            // Mặc định chọn sắp xếp theo tổng % giảm dần
            sortSel.value = "total_desc";
            const decimalSel = document.createElement("select");
            [[0, "0 chữ số"], [1, "1 chữ số"], [2, "2 chữ số"], [3, "3 chữ số"], [4, "4 chữ số"], [5, "5 chữ số"], [6, "6 chữ số"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiển thị:", topSel, "Sắp xếp:", sortSel, "Độ chính xác:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);
            // (removed debug placeholder)

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const counts = Array.from({ length: 46 }, () => Array(6).fill(0));
                let total = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return;
                    total++;
                    r.nums.forEach((v, i) => { counts[v][i]++; });
                });
                let data = [];
                for (let v = 1; v <= 45; v++) {
                    const pcts = counts[v].map(c => total ? c / total : 0);
                    const countSum = counts[v].reduce((a, b) => a + b, 0);
                    data.push({ v, pcts, sum: pcts.reduce((a, b) => a + b, 0), count: countSum });
                }
                if (sortSel.value === "total_desc") data.sort((a, b) => b.sum - a.sum); else data.sort((a, b) => a.v - b.v);
                data = data.slice(0, parseInt(topSel.value, 10));

                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr>" +
                    "<th>Rank</th><th>Số</th><th class=\"col-total\">Tổng %</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                data.forEach((row, idx) => {
                    const bg = idx % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.05)";
                    // Assign tier by 9-rank blocks: ranks 1-9 -> tier1, 10-18 -> tier2, ...
                    let tier = Math.floor(idx / 9) + 1;
                    if (tier < 1) tier = 1;
                    if (tier > 5) tier = 5;
                    html += `<tr style="background:${bg};">` +
                        `<td><span class="rank-pill rank-tier-${tier}">#${idx + 1}</span></td><td><span class='pill'>${row.v}</span></td>` +
                        `<td class=\"col-total\"><span class='muted rank-pill rank-tier-${tier}' style='font-size:12px;margin-right:8px;'>${row.count}</span><span class='muted' style='font-size:12px;margin:0 6px'>/${total}=</span><strong class='rank-pill rank-tier-${tier}'>${fmtPctCustom(row.sum, decimals)}</strong></td>` +
                        row.pcts.map(p => `<td>${fmtPctCustom(p, decimals)}</td>`).join("") +
                        `</tr>`;
                });
                html += "</tbody></table></div>";
                wrap.innerHTML = html;
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell11
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell11_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach delegated hover + Ctrl+click handlers on wrap so all generated inner cards/tables receive behavior
                (function attachRowHoverAndCtrlClick_cell11_delegated() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const cardEl = tr.closest('.card');
                            if (!cardEl) return;
                            const s = cardEl.querySelector('strong');
                            if (!s) return;
                            const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;
                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                            } catch (e) { }
                        });
                    } catch (err) { }
                })();
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell11
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell11_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach Ctrl+click handler for cell11 (use delegation on wrap so all inner cards/tables are covered)
                (function attachRowHoverAndCtrlClick_cell11() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const cardEl = tr.closest('.card');
                            if (!cardEl) return;
                            const s = cardEl.querySelector('strong');
                            if (!s) return;
                            const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;
                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                            } catch (e) { }
                        });
                    } catch (err) { }
                })();
                // ensure viewport shows controls + results consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            topSel.onchange = sortSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5: xếp hạng theo vị trí
        function renderCell5() {
            const body = sectionShell("cell5", "Cell5 · Xếp hạng theo vị trí", "Chọn top và tô đậm theo notebook.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[3, "Top 3"], [5, "Top 5"], [10, "Top 10"], [45, "Tất cả (45)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o); });
            topSel.value = "45";
            const decimalSel = document.createElement("select");
            [[0, "0 chữ số"], [1, "1 chữ số"], [2, "2 chữ số"], [3, "3 chữ số"], [4, "4 chữ số"], [5, "5 chữ số"], [6, "6 chữ số"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiển thị:", topSel, "Độ chính xác:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const count = Array.from({ length: 6 }, () => Array(46).fill(0));
                rows.forEach(r => { r.nums.forEach((v, i) => { count[i][v]++; }); });
                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                const topN = parseInt(topSel.value, 10);
                for (let rank = 0; rank < topN; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        const arr = [...Array(45).keys()].map(i => i + 1).map(v => [v, count[pos][v]]).sort((a, b) => b[1] - a[1]);
                        const [v, c] = arr[rank];
                        const pct = rows.length ? (c / rows.length) : 0;
                        const col = getCol(v);
                        cells.push(`<td><div><strong>${v}</strong> <span class='muted'>[C${col}]</span></div><div class='muted'>${c}/${rows.length}= ${fmtPctCustom(pct, decimals)}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank + 1}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                // Thêm bảng mới: Xếp hạng cột theo vị trí (6x6)
                html += "<h3 style='margin-top: 24px; margin-bottom: 12px;'>Xếp hạng cột theo vị trí</h3>";

                // Tổng % của từng cột (C1-C6) trên toàn bộ 6 vị trí
                const colTotals = Array(6).fill(0);
                rows.forEach(r => {
                    r.nums.forEach(v => { const col = getCol(v); colTotals[col - 1]++; });
                });
                const totalPositions = rows.length * 6;
                const colPctDisplay = colTotals.map((c, idx) => {
                    const pct = fmtPctCustom(totalPositions ? c / totalPositions : 0, decimals);
                    return `<span class="pill" style="background:linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%); color:#fff; border:none;">C${idx + 1}</span> <strong>${pct}</strong>`;
                }).join(" · ");
                html += `<div style='margin:6px 0 10px; font-size:12px; color:var(--text-strong);'>${colPctDisplay}</div>`;

                html += "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";

                // Tính toán: với mỗi vị trí, xếp hạng các cột (1-6) theo số lần xuất hiện
                for (let rank = 1; rank <= 6; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        // Đếm mỗi cột (1-6) xuất hiện ở vị trí này
                        const colCounts = {};
                        for (let col = 1; col <= 6; col++) colCounts[col] = 0;

                        rows.forEach(r => {
                            const v = r.nums[pos];
                            const col = getCol(v);
                            colCounts[col]++;
                        });

                        // Sắp xếp các cột theo số lần xuất hiện (giảm dần)
                        const sortedCols = Object.entries(colCounts)
                            .map(([col, count]) => ({ col: parseInt(col), count }))
                            .sort((a, b) => b.count - a.count);

                        // Lấy cột ở rank này (rank - 1 vì rank bắt đầu từ 1)
                        const { col: topCol, count: topCount } = sortedCols[rank - 1];
                        const pct = rows.length ? (topCount / rows.length) : 0;
                        cells.push(`<td><div><strong>C${topCol}</strong></div><div class='muted'>${topCount}/${rows.length}= ${fmtPctCustom(pct, parseInt(decimalSel.value, 10))}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                wrap.innerHTML = html;
            }
            topSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5.5: Lịch sử — in ra toàn bộ bộ các kỳ, 3 bảng trên một hàng, loại bỏ cột euclid
        function renderCell5_5() {
            const body = sectionShell("cell5_5", "Cell5.5 · Lịch sử", "Hiển thị lịch sử toàn bộ bộ các kỳ. Lọc theo năm và sắp xếp theo thời gian.");
            const controls = document.createElement("div");
            controls.className = "controls";

            const sortSel = document.createElement("select");
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            sortSel.value = 'desc';

            const yearSel = document.createElement("select");
            // will populate years after data is ready

            const monthSel = document.createElement("select");
            // will populate months after years are populated

            // info button that shows counts popup on hover
            const infoBtn = document.createElement('div');
            infoBtn.textContent = 'info';
            infoBtn.title = 'Di chuột để xem thống kê số lần xuất hiện (1..45) cho Năm/Tháng đã chọn';
            infoBtn.style.padding = '8px 10px';
            infoBtn.style.borderRadius = '8px';
            infoBtn.style.border = '1px solid var(--border)';
            infoBtn.style.background = 'var(--card)';
            infoBtn.style.color = 'var(--text)';
            infoBtn.style.cursor = 'pointer';
            infoBtn.style.fontSize = '12px';
            infoBtn.style.marginLeft = '6px';

            controls.append("Sắp xếp:", sortSel, "Năm:", yearSel, "Tháng:", monthSel, infoBtn);
            body.appendChild(controls);

            // Trash filter selector (compact): include | exclude
            const trashSel = document.createElement('select');
            [["include", "include"], ["exclude", "exclude"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; trashSel.appendChild(o); });
            trashSel.value = 'include';
            // append trash selector to controls for Cell5.5
            controls.append("Trash:", trashSel);

            // Ensure Cell5.5 redraws when the popup trash changes (only add listener once)
            try {
                if (!window.__cell5_5_trash_listener_added) {
                    document.addEventListener('trashchange', function () {
                        try {
                            if (trashSel && trashSel.value === 'exclude') {
                                draw();
                            }
                        } catch (e) { }
                    });
                    window.__cell5_5_trash_listener_added = true;
                }
            } catch (e) { /* ignore */ }

            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            // parse date string into sortable timestamp (reused by months/year builders)
            function parseDateSortable(s) {
                if (!s) return 0;
                s = String(s).trim();
                // dd/mm/yyyy or dd/mm/yy
                let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                if (m) {
                    let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                    if (yy < 100) yy += 2000;
                    const dt = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt)) return dt.getTime();
                }
                // digits only: ddmmyyyy or ddmmyy
                const digits = s.replace(/\D/g, '');
                if (/^\d+$/.test(digits)) {
                    if (digits.length === 8) {
                        const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                        const dt = new Date(yyyy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    const d6 = digits.padStart(6, '0');
                    const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                    const dt2 = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt2)) return dt2.getTime();
                }
                // fallback to Date parsing
                const dtf = new Date(s);
                if (!isNaN(dtf)) return dtf.getTime();
                return 0;
            }

            function populateYears() {
                const prev = yearSel.value;
                yearSel.innerHTML = '';
                const yearsSet = new Set();
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (s.length >= 4) yearsSet.add(s.slice(-4));
                });
                const years = Array.from(yearsSet).filter(Boolean).sort((a, b) => b - a);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Tất cả'; yearSel.appendChild(oAll);
                years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; yearSel.appendChild(o); });
                // restore previous selection if still available, otherwise default to 'all'
                if (prev && Array.from(yearSel.options).some(o => o.value === prev)) {
                    yearSel.value = prev;
                } else {
                    yearSel.value = 'all';
                }
                // populate months for the (possibly restored) year selection
                // mark selected option visually
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                populateMonths();
            }

            function populateMonths() {
                const prev = monthSel.value;
                monthSel.innerHTML = '';
                const monthsSet = new Set();
                const selectedYear = yearSel.value;
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (!s) return;
                    // if filtering by year, only consider rows matching that year (by last-4)
                    if (selectedYear && selectedYear !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== selectedYear) return;
                    }
                    const ts = parseDateSortable(s);
                    if (ts) {
                        const dt = new Date(ts);
                        const m = dt.getMonth() + 1;
                        monthsSet.add(m);
                    }
                });
                const months = Array.from(monthsSet).sort((a, b) => a - b);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Tất cả'; monthSel.appendChild(oAll);
                // if no months detected (e.g., non-parseable dates), include generic 1..12
                if (!months.length) {
                    for (let i = 1; i <= 12; i++) {
                        const o = document.createElement('option'); o.value = String(i).padStart(2, '0'); o.textContent = `Tháng ${i}`; monthSel.appendChild(o);
                    }
                } else {
                    months.forEach(m => { const o = document.createElement('option'); o.value = String(m).padStart(2, '0'); o.textContent = `Tháng ${m}`; monthSel.appendChild(o); });
                }
                if (prev && Array.from(monthSel.options).some(o => o.value === prev)) {
                    monthSel.value = prev;
                } else {
                    monthSel.value = 'all';
                }
                // mark selected option visually
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
            }

            // Create a floating popup for the info box (shared for all hovers)
            const infoPopup = document.createElement('div');
            // use fixed positioning so the popup stays aligned with sticky controls
            infoPopup.style.position = 'fixed';
            infoPopup.style.zIndex = 9999;
            infoPopup.style.minWidth = '220px';
            infoPopup.style.maxWidth = '480px';
            infoPopup.style.maxHeight = '320px';
            infoPopup.style.overflow = 'auto';
            infoPopup.style.padding = '10px';
            infoPopup.style.borderRadius = '8px';
            infoPopup.style.border = '1px solid var(--border)';
            infoPopup.style.background = 'var(--panel)';
            infoPopup.style.color = 'var(--text)';
            infoPopup.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
            infoPopup.style.display = 'none';
            document.body.appendChild(infoPopup);

            // Pre-compute global totals/rank (across all rows, full history)
            const globalCounts = new Array(46).fill(0);
            rows.forEach(r => {
                const nums = r.nums || [];
                nums.forEach(n => {
                    const v = Number(n);
                    if (v >= 1 && v <= 45) globalCounts[v]++;
                });
            });
            const globalItems = [];
            for (let i = 1; i <= 45; i++) globalItems.push({ n: i, c: globalCounts[i] });
            globalItems.sort((a, b) => b.c - a.c || a.n - b.n);
            const globalRankMap = {};
            globalItems.forEach((it, idx) => { globalRankMap[it.n] = idx + 1; });

            // Build counts for numbers 1..45 for currently selected year/month
            let infoSort = 'desc'; // 'default' | 'desc' | 'asc' — default to Giảm dần
            function buildCountsHtml() {
                // filter rows by year/month similar to draw()
                const filtered = rows.filter(r => {
                    const s = String(r.date || '');
                    if (!s) return false;
                    if (yearSel.value && yearSel.value !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== yearSel.value) return false;
                    }
                    if (monthSel.value && monthSel.value !== 'all') {
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        if (m !== monthSel.value) return false;
                    }
                    return true;
                });

                const counts = new Array(46).fill(0);
                filtered.forEach(r => {
                    const nums = r.nums || [];
                    nums.forEach(n => {
                        const v = Number(n);
                        if (v >= 1 && v <= 45) counts[v]++;
                    });
                });

                // prepare items and apply sorting
                const items = [];
                for (let i = 1; i <= 45; i++) items.push({ n: i, c: counts[i] });
                if (infoSort === 'desc') items.sort((a, b) => b.c - a.c || a.n - b.n);
                else if (infoSort === 'asc') items.sort((a, b) => a.c - b.c || a.n - b.n);

                let html = `<div style="font-weight:700;margin-bottom:6px;">Thống kê xuất hiện (Năm: ${yearSel.value || 'Tất cả'} · Tháng: ${monthSel.value || 'Tất cả'})</div>`;
                html += `<div style="margin-bottom:8px;"><select id="infoSortSel" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);"><option value="default">Mặc định</option><option value="desc">Giảm dần (số lần)</option><option value="asc">Tăng dần (số lần)</option></select></div>`;
                // compute numbers that did NOT appear in the filtered set
                const zeros = items.filter(it => it.c === 0).map(it => it.n).sort((a, b) => a - b);
                if (zeros.length) {
                    const zerosHtml = zeros.map(n => `<span class="info-zero-num">${n}</span>`).join(' ');
                    html += `<div style="margin-top:6px;font-size:12px;font-weight:700;color:var(--muted);">Không có ${zeros.length} số: ${zerosHtml}</div>`;
                }

                html += `<div style="margin-top:8px;color:var(--muted);font-size:11px;">Tổng kỳ: ${filtered.length}</div>`;
                html += '<table class="no-sticky" style="width:100%;font-size:12px;border-collapse:collapse;">';
                html += '<thead><tr><th style="width:28px;text-align:left;padding:6px;border-bottom:1px solid var(--border);">Hạng</th><th class="num-header" style="width:36px;text-align:center;padding:6px;border-bottom:1px solid var(--border);">Số</th><th style="text-align:right;padding:6px;border-bottom:1px solid var(--border);">Số lần</th></tr></thead>';
                html += '<tbody>';
                items.forEach(it => {
                    const rankNum = globalRankMap[it.n];
                    const displayRank = rankNum || '-';
                    let pillClass = 'euclid-pill';
                    if (typeof rankNum === 'number') {
                        let tier = Math.ceil(rankNum / 9); // 45 numbers → 5 tiers of ~9 each
                        tier = Math.max(1, Math.min(5, tier));
                        pillClass += ' rank-tier-' + tier;
                    }
                    html += `<tr><td style="padding:4px 6px;"><span class="${pillClass}">${displayRank}</span></td><td class="num-cell" style="padding:4px 6px;text-align:center;"><span class="info-num-pill">${it.n}</span></td><td style="padding:4px 6px;text-align:right;">${it.c}</td></tr>`;
                });
                html += '</tbody></table>';
                html += `<div style="margin-top:8px;color:var(--muted);font-size:11px;">Tổng kỳ: ${filtered.length}</div>`;
                return html;
            }

            // Show/hide logic with pointer interaction (keep open if moving between btn and popup)
            let hoverTimeout = null;
            function renderInfoPopup() {
                infoPopup.innerHTML = buildCountsHtml();
                // wire the sort select inside popup
                const sel = infoPopup.querySelector('#infoSortSel');
                if (sel) {
                    sel.value = infoSort;
                    sel.onchange = () => {
                        infoSort = sel.value; infoPopup.innerHTML = buildCountsHtml(); // re-wire recursively
                        const sel2 = infoPopup.querySelector('#infoSortSel'); if (sel2) sel2.onchange = () => { infoSort = sel2.value; renderInfoPopup(); }
                    };
                }
            }

            // Positioning and show/hide helpers so the popup stays anchored
            // under the sticky controls even while the page is scrolled.
            let __infoPopupPositionBound = false;
            function positionInfoPopup() {
                try {
                    const rect = infoBtn.getBoundingClientRect();
                    const top = rect.bottom + 8;
                    let left = rect.left;
                    // Use actual popup width when available; fallback to declared maxWidth
                    const popupRect = infoPopup.getBoundingClientRect();
                    const popupWidth = (popupRect && popupRect.width) ? popupRect.width : parseInt(infoPopup.style.maxWidth || 480, 10);
                    // keep popup within viewport with small padding
                    const maxLeft = Math.max(8, window.innerWidth - popupWidth - 12);
                    if (left > maxLeft) left = maxLeft;
                    if (left < 8) left = 8;
                    infoPopup.style.top = top + 'px';
                    infoPopup.style.left = left + 'px';
                } catch (e) { /* ignore positioning errors */ }
            }

            function bindPopupPositionListeners() {
                if (__infoPopupPositionBound) return;
                // capture scroll so reposition happens even when ancestor elements scroll
                window.addEventListener('scroll', positionInfoPopup, true);
                window.addEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = true;
            }

            function unbindPopupPositionListeners() {
                if (!__infoPopupPositionBound) return;
                window.removeEventListener('scroll', positionInfoPopup, true);
                window.removeEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = false;
            }

            function showInfoPopup() {
                // only show when the Cell5.5 section is active
                const cell5 = document.getElementById('cell5_5');
                if (cell5 && cell5.classList.contains('hidden')) return;
                clearTimeout(hoverTimeout);
                renderInfoPopup();
                // ensure popup is visible so we can measure and position it
                infoPopup.style.display = 'block';
                // position now and while scrolling/resizing
                positionInfoPopup();
                bindPopupPositionListeners();
            }

            function hideInfoPopupSoon() {
                clearTimeout(hoverTimeout);
                hoverTimeout = setTimeout(() => { hideInfoPopup(); }, 180);
            }

            // Click-to-toggle only: popup opens/closes when clicking the `infoBtn` itself.
            infoBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (infoPopup.style.display === 'block') hideInfoPopup();
                else showInfoPopup();
            });
            // make infoBtn focusable and allow keyboard toggle (Enter/Space)
            infoBtn.tabIndex = 0;
            infoBtn.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (infoPopup.style.display === 'block') hideInfoPopup();
                    else showInfoPopup();
                }
            });

            // immediate hide helper (used by click)
            function hideInfoPopup() {
                clearTimeout(hoverTimeout);
                infoPopup.style.display = 'none';
                try { unbindPopupPositionListeners(); } catch (e) { }
            }

            // Prevent outer page scrolling when the pointer is over the popup.
            // Wheel: stop propagation and prevent default when appropriate.
            infoPopup.addEventListener('wheel', function (ev) {
                // allow scrolling inside the popup but prevent page scroll
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!canScroll) {
                    ev.preventDefault(); ev.stopPropagation();
                    return;
                }
                const delta = ev.deltaY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if ((delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    // consume the wheel so page doesn't move while interacting with popup
                    ev.stopPropagation();
                }
            }, { passive: false });

            // Touch support: prevent overscroll from reaching page on mobile
            let __infoTouchStartY = 0;
            infoPopup.addEventListener('touchstart', function (ev) {
                if (ev.touches && ev.touches.length) __infoTouchStartY = ev.touches[0].clientY;
            }, { passive: true });
            infoPopup.addEventListener('touchmove', function (ev) {
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!ev.touches || !ev.touches.length) return;
                const curY = ev.touches[0].clientY;
                const delta = __infoTouchStartY - curY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if (!canScroll || (delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    ev.stopPropagation();
                }
            }, { passive: false });

            // hide the info popup whenever we switch to another section
            document.addEventListener('sectionchange', (ev) => {
                try {
                    if (!ev || !ev.detail) return;
                    if (ev.detail.id !== 'cell5_5') {
                        hideInfoPopup();
                    }
                } catch (e) { }
            });

            // Update popup if filters change while it's visible
            yearSel.addEventListener('change', () => {
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });
            monthSel.addEventListener('change', () => {
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                populateYears();
                // Build data with parsedDate (if available) and display date
                let data = rows.map(r => ({ date: r.date || '', parsedDate: r.parsedDate || null, nums: r.nums || [], label: r.label || '' }));
                if (yearSel.value && yearSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        return s.length >= 4 ? s.slice(-4) === yearSel.value : false;
                    });
                }
                // filter by month if selected
                if (monthSel.value && monthSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        return m === monthSel.value;
                    });
                }

                // Apply trash-exclude filter when requested: if trashSel is set to 'exclude',
                // remove any record that contains at least one number currently in the popup trash.
                try {
                    if (typeof trashSel !== 'undefined' && trashSel.value === 'exclude') {
                        let trashed = [];
                        try {
                            if (window.getTrashItems && typeof window.getTrashItems === 'function') trashed = window.getTrashItems();
                            else if (Array.isArray(window.__trashItems)) trashed = window.__trashItems.slice();
                        } catch (e) { trashed = []; }
                        if (trashed && trashed.length) {
                            const tset = new Set(trashed.map(n => Number(n)));
                            data = data.filter(d => {
                                const nums = d.nums || [];
                                for (const n of nums) if (tset.has(Number(n))) return false;
                                return true;
                            });
                        }
                    }
                } catch (e) { /* ignore trash filter errors */ }
                // Helper: parse common dd/mm/yyyy or dd/mm/yy or digit-only forms into timestamp
                function parseDateSortable(s) {
                    if (!s) return 0;
                    s = String(s).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                    if (m) {
                        let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                        if (yy < 100) yy += 2000;
                        const dt = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    // digits only: ddmmyyyy or ddmmyy
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                            const dt = new Date(yyyy, mm - 1, dd);
                            if (!isNaN(dt)) return dt.getTime();
                        }
                        const d6 = digits.padStart(6, '0');
                        const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                        const dt2 = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt2)) return dt2.getTime();
                    }
                    // fallback to Date parsing
                    const dtf = new Date(s);
                    if (!isNaN(dtf)) return dtf.getTime();
                    return 0;
                }

                data = data.slice().sort((a, b) => {
                    const ta = a.parsedDate ? a.parsedDate.getTime() : parseDateSortable(a.date);
                    const tb = b.parsedDate ? b.parsedDate.getTime() : parseDateSortable(b.date);
                    return sortSel.value === 'desc' ? tb - ta : ta - tb;
                });

                if (!data.length) { wrap.innerHTML = "<div class='loader'>Không có dữ liệu cho lựa chọn này</div>"; return; }

                const pageSize = 20;
                const pages = [];
                for (let i = 0; i < data.length; i += pageSize) pages.push(data.slice(i, i + pageSize));

                // DEBUG: log counts to help diagnose mismatched page count reported by user
                try { console.debug('renderCell5_5 debug:', { filteredCount: data.length, pages: pages.length, totalRows: rows.length }); } catch (e) { }

                if (!pages.length) {
                    wrap.innerHTML = "<div class='loader'>Không có dữ liệu cho lựa chọn này</div>";
                    return;
                }

                // Build lightweight card placeholders and mount content lazily to avoid scroll jank
                wrap.innerHTML = '';
                const infoBar = document.createElement('div');
                infoBar.style.cssText = 'text-align:center;margin-bottom:10px;color:var(--muted);font-weight:700;';
                const totalItems = rows.length || 0;
                infoBar.innerHTML = `Hiển thị <span class="cell5-count-x">${data.length}</span>/${totalItems} mục · ${pages.length} bảng (tối đa ${pageSize}/bảng)`;
                wrap.appendChild(infoBar);

                const container = document.createElement('div');
                container.className = 'grid-centered';
                container.style.alignItems = 'flex-start';
                wrap.appendChild(container);

                const htmlCache = new Map();
                const heightCache = new Map();
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 36; // allow more mounted cards like Cell6.5 for snappier scroll
                // background pre-cache queue: build page HTML off-main when browser is idle
                const preCacheQueue = [];
                let preCacheScheduled = false;
                function runPreCache() {
                    if (preCacheScheduled) return;
                    preCacheScheduled = true;
                    const process = (deadline) => {
                        let count = 0;
                        while (preCacheQueue.length && (deadline ? deadline.timeRemaining() > 0 : count < 6)) {
                            const idx = preCacheQueue.shift();
                            if (!htmlCache.has(idx)) {
                                try {
                                    const p = pages[idx];
                                    if (p) htmlCache.set(idx, buildPageHtml(p, idx));
                                } catch (e) { /* ignore build errors */ }
                            }
                            count++;
                        }
                        if (preCacheQueue.length) {
                            if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                            else setTimeout(() => process(null), 50);
                        } else {
                            preCacheScheduled = false;
                        }
                    };
                    if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                    else setTimeout(() => process(null), 50);
                }

                const buildPageHtml = (page, pIdx) => {
                    const start = pIdx * pageSize;
                    const firstDate = page[0] ? page[0].date : '';
                    const lastDate = page[page.length - 1] ? page[page.length - 1].date : '';
                    let table = `<table style="width:100%;"><thead><tr><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>Ngày</th><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>Kết quả</th></tr></thead><tbody>`;
                    // Precompute trash-based k thresholds using the same greedy heuristic as
                    // computeBestRemoval(k) in the trash popup. We simulate selection once per
                    // page so each record can get its maximal visible-k (t).
                    try {
                        const numberPickerTableEl = document.getElementById('numberPickerTable');
                        const poolNodes = numberPickerTableEl ? Array.from(numberPickerTableEl.querySelectorAll('td[data-number]')) : [];
                        const pool = Array.from(new Set(poolNodes.map(n => Number(n.dataset.number)).filter(n => Number.isFinite(n))));
                        const poolSet = new Set(pool);
                        // build number -> set(rowIndex) mapping over global `rows`
                        // also build a stable key->indices map so we can match page rows
                        const numToRows = new Map();
                        const rowKeyToIndices = new Map();
                        rows.forEach((r, ridx) => {
                            try {
                                const nums = r.nums || [];
                                const rk = (nums || []).join(',') + '|' + (r.date || '');
                                if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                                rowKeyToIndices.get(rk).push(ridx);
                                for (const v of nums) {
                                    const n = Number(v);
                                    if (!poolSet.has(n)) continue;
                                    if (!numToRows.has(n)) numToRows.set(n, new Set());
                                    numToRows.get(n).add(ridx);
                                }
                            } catch (er) { }
                        });

                        const MAX_K_TRASH = 39;
                        const maxK = Math.min(MAX_K_TRASH, Math.max(1, pool.length));
                        const available = new Set(pool);
                        const excludedSet = new Set(); // row indices excluded by chosen numbers
                        const chosenSoFar = [];
                        // record first-k-when-excluded for rows appearing on this page
                        const rowFirstExcludedAt = new Map();

                        for (let k = 1; k <= maxK; k++) {
                            // pick candidate minimizing marginal newly excluded rows (greedy)
                            let bestChoice = null;
                            let bestMarginal = Infinity;
                            for (const candidate of Array.from(available)) {
                                const s = numToRows.get(candidate);
                                if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                                let marginal = 0;
                                for (const idx of s) if (!excludedSet.has(idx)) marginal++;
                                if (marginal < bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                            }
                            if (bestChoice === null) break;
                            // choose it
                            available.delete(bestChoice);
                            chosenSoFar.push(bestChoice);
                            const s2 = numToRows.get(bestChoice);
                            if (s2) for (const idx of s2) excludedSet.add(idx);

                            // mark page rows first excluded at this k by matching stable key
                            for (const rowObj of page) {
                                try {
                                    const rk = ((rowObj.nums || []).join(',')) + '|' + (rowObj.date || '');
                                    const idxs = rowKeyToIndices.get(rk) || [];
                                    for (const globalIdx of idxs) {
                                        if (!rowFirstExcludedAt.has(globalIdx) && excludedSet.has(globalIdx)) {
                                            rowFirstExcludedAt.set(globalIdx, k);
                                        }
                                    }
                                } catch (er) { }
                            }
                        }

                        // Now render rows with computed t = firstExcludedAt - 1 (or maxK if never excluded)
                        let sumT_forPage = 0;
                        let countT_forPage = 0;
                        page.forEach((row, j) => {
                            const result = (row.nums || []).join(',');
                            const numsHtml = (row.nums || []).map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            const rk = ((row.nums || []).join(',')) + '|' + (row.date || '');
                            const idxs = rowKeyToIndices.get(rk) || [];
                            let firstK = null;
                            for (const globalIdx of idxs) {
                                if (rowFirstExcludedAt.has(globalIdx)) {
                                    const v = rowFirstExcludedAt.get(globalIdx);
                                    if (firstK === null || v < firstK) firstK = v;
                                }
                            }
                            let t = maxK;
                            if (firstK !== null) t = Math.max(0, firstK - 1);
                            sumT_forPage += t;
                            countT_forPage += 1;
                            table += `<tr data-result="${result}" title="k=${t}" data-k="${t}"><td style='padding:6px;text-align:left'>${row.date}</td><td style='padding:6px;text-align:left'>${numsHtml}</td></tr>`;
                        });

                        // compute average k for this page and update trash popup header (if present)
                        try {
                            const avg = countT_forPage ? (sumT_forPage / countT_forPage) : 0;
                            const avgStr = Number.isFinite(avg) ? avg.toFixed(2) : '0';
                            const tp = document.getElementById('trashPopup');
                            if (tp) {
                                try {
                                    const firstDiv = tp.querySelector('div');
                                    if (firstDiv) {
                                        // remove existing avg element if present
                                        const existing = firstDiv.querySelector('.avg-k');
                                        if (existing) existing.remove();
                                        const span = document.createElement('span');
                                        span.className = 'avg-k';
                                        span.style.cssText = 'margin-left:12px;color:var(--muted);font-weight:700;';
                                        span.textContent = 'k̄ = ' + avgStr;
                                        firstDiv.appendChild(span);
                                    }
                                } catch (e) { /* ignore DOM errors */ }
                            }
                            // store last-average globally so other UI (trash tooltip) can use it
                            try { window.__lastAvgK = Number(avgStr); } catch (e) { window.__lastAvgK = null; }
                        } catch (e) { /* ignore avg errors */ }
                    } catch (e) {
                        // fallback: render without tooltip
                        page.forEach((row, j) => {
                            const result = (row.nums || []).join(',');
                            const numsHtml = (row.nums || []).map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            table += `<tr data-result="${result}"><td style='padding:6px;text-align:left'>${row.date}</td><td style='padding:6px;text-align:left'>${numsHtml}</td></tr>`;
                        });
                    }
                    table += '</tbody></table>';
                    const header = `<div style="font-weight:700; padding:8px 12px; border-bottom:1px solid var(--border);">Bảng ${pIdx + 1} · ${page.length} mục · ${firstDate} → ${lastDate}</div>`;
                    return `<div>${header}<div style='padding:8px;'>${table}</div></div>`;
                };

                const mount = (card, page, idx) => {
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(idx)) return;
                    const body = card.querySelector('.card-body');
                    let inner = htmlCache.get(idx);
                    if (!inner) {
                        inner = buildPageHtml(page, idx);
                        htmlCache.set(idx, inner);
                    }
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell5_5_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table (same as Cell6.5)
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights until another record hover updates them.
                                return;
                            });

                            // Ctrl+click a row: switch to cell6_6, paste its 6 numbers, and mark row with yellow border
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    // parse numbers (use existing helper)
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    // clear any previous ctrl-selected rows globally and mark this one
                                    try {
                                        document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected'));
                                    } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    // persist selection so it survives remounts/navigation
                                    try { localStorage.setItem('cell5_5_ctrl_selected', result); } catch (e) { }

                                    // Ensure target section is rendered then navigate to it after a short delay
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            // apply numbers after nav; give a small delay to allow render
                                            setTimeout(() => {
                                                try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { }
                                            }, 220);
                                        }, 200);
                                    } else {
                                        // fallback: apply even if nav button missing
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { /* ignore */ }
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(idx);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const page = pages[idx];
                        if (!page) return;
                        if (entry.isIntersecting) mount(entry.target, page, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // chunked creation
                const total = pages.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, total);
                    for (let i = created; i < end; i++) {
                        const page = pages[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.currentPage = '-1';
                        card.dataset.page = String(i);
                        card.innerHTML = `<div class='card-body' style='min-height:100px;padding:8px;'></div>`;
                        container.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                        // enqueue light-weight pre-build of this page's HTML
                        preCacheQueue.push(i);
                        runPreCache();
                    }
                    created = end;
                    if (created < total) requestAnimationFrame(createChunk);
                };
                createChunk();

                // after structure is ready, scroll viewport to 240px so controls sit under header
                // Use a small timeout + rAF to wait for layout/paint to settle (match Cell6.5 behavior)
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (er) { } }
                    });
                }, 160);
            }

            sortSel.onchange = yearSel.onchange = monthSel.onchange = trashSel.onchange = draw;
            // If rows are already loaded, populate and draw; otherwise draw will handle once data present
            draw();
        }
        // Helpers for labels
        const labelOf = (nums) => nums.map(getCol).join("");
        const diffPositions = (a, b) => { const pos = []; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) pos.push(i); return pos; };

        // Helper: compute per-row trash k (cached). Returns t (largest k for which row remains visible)
        (function setupRowKCache() {
            let cache = null;
            function computeCache() {
                try {
                    const npTable = document.getElementById('numberPickerTable');
                    const poolNodes = npTable ? Array.from(npTable.querySelectorAll('td[data-number]')) : [];
                    let pool = poolNodes.map(n => Number(n.dataset.number)).filter(n => Number.isFinite(n));
                    if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);
                    const poolSet = new Set(pool);
                    const numToRows = new Map();
                    const rowKeyToIndices = new Map();
                    rows.forEach((rr, ridx) => {
                        try {
                            const rk = (rr.nums || []).join(',') + '|' + (rr.date || '');
                            if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                            rowKeyToIndices.get(rk).push(ridx);
                            for (const v of (rr.nums || [])) {
                                const n = Number(v);
                                if (!poolSet.has(n)) continue;
                                if (!numToRows.has(n)) numToRows.set(n, new Set());
                                numToRows.get(n).add(ridx);
                            }
                        } catch (e) { }
                    });

                    const MAX_K_TRASH = 39;
                    const maxK = Math.min(MAX_K_TRASH, Math.max(1, pool.length));
                    const available = new Set(pool);
                    const excludedSet = new Set();
                    const rowFirstExcludedAt = new Array(rows.length).fill(null);

                    for (let k = 1; k <= maxK; k++) {
                        let bestChoice = null;
                        let bestMarginal = Infinity;
                        for (const candidate of Array.from(available)) {
                            const s = numToRows.get(candidate);
                            if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                            let marginal = 0;
                            for (const idx of s) if (!excludedSet.has(idx)) marginal++;
                            if (marginal < bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                        }
                        if (bestChoice === null) break;
                        available.delete(bestChoice);
                        const s2 = numToRows.get(bestChoice);
                        if (s2) for (const idx of s2) excludedSet.add(idx);

                        // mark rows first excluded at this k
                        for (const [rk, idxs] of rowKeyToIndices) {
                            for (const globalIdx of idxs) {
                                if (rowFirstExcludedAt[globalIdx] === null && excludedSet.has(globalIdx)) rowFirstExcludedAt[globalIdx] = k;
                            }
                        }
                    }

                    cache = { rowKeyToIndices, rowFirstExcludedAt, maxK, pool };
                    return cache;
                } catch (e) { cache = null; return null; }
            }

            window.getRowTrashK = function (row) {
                try {
                    if (!cache) computeCache();
                    if (!cache) return 0;
                    const rk = ((row.nums || []).join(',')) + '|' + (row.date || '');
                    const idxs = cache.rowKeyToIndices.get(rk) || [];
                    let firstK = null;
                    for (const gi of idxs) {
                        const v = cache.rowFirstExcludedAt[gi];
                        if (v !== null && v !== undefined) { if (firstK === null || v < firstK) firstK = v; }
                    }
                    let t = cache.maxK;
                    if (firstK !== null) t = Math.max(0, firstK - 1);
                    return t;
                } catch (e) { return 0; }
            };
        })();

        // Cell6: group by label with max diff + consecutive
        function renderCell6() {
            const body = sectionShell("cell7", "Cell7 · Nhóm theo label", "max sai khác & liền kề, chỉ nhóm >=2 kỳ.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const diffSel = document.createElement("select");
            for (let i = 0; i <= 6; i++) { const o = document.createElement("option"); o.value = i; o.textContent = `Sai khác ${i}`; diffSel.appendChild(o); } diffSel.value = "1";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề"));
            const sortSel = document.createElement("select");
            [["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            controls.append("Sai khác tối đa:", diffSel, consecLabel, "Sắp xếp:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }

                // Tạo key để kiểm tra cache
                const newCacheKey = `${diffSel.value}|${consec.checked}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroups(groupCache);
                    return;
                }

                wrap.innerHTML = "<div class='loader'>Đang xử lý...</div>";

                // Dùng requestIdleCallback để tính toán khi browser rảnh
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => computeAndRender());
                } else {
                    setTimeout(() => computeAndRender(), 0);
                }

                function computeAndRender() {
                    const labelRows = {};
                    rows.forEach(r => { const label = labelOf(r.nums); (labelRows[label] ||= []).push(r); });
                    const labels = Object.keys(labelRows).sort();
                    const used = new Set();
                    let groups = [];

                    // Bước 1: Luôn nhóm theo điều kiện lỏng nhất (không liền kề)
                    labels.forEach(base => {
                        if (used.has(base)) return;
                        used.add(base);
                        const gLabels = [base];
                        let gRows = [...labelRows[base]];

                        for (let j = 0; j < labels.length; j++) {
                            const other = labels[j];
                            if (used.has(other)) continue;
                            const pos = diffPositions(base, other);
                            // Chỉ kiểm tra số vị trí khác nhau, không kiểm tra liền kề
                            if (pos.length > parseInt(diffSel.value, 10)) continue;
                            used.add(other); gLabels.push(other); gRows.push(...labelRows[other]);
                        }
                        if (gRows.length >= 2) groups.push({ base, labels: gLabels, rows: gRows });
                    });

                    // Bước 2: Nếu tick "Liền kề", lọc các labels không thoả điều kiện trong mỗi nhóm
                    if (consec.checked) {
                        groups = groups.map(g => {
                            // Giữ lại chỉ những labels thoả điều kiện liền kề với base
                            const filteredLabels = g.labels.filter(label => {
                                const pos = diffPositions(g.base, label);
                                // Nếu chỉ khác ≤1 vị trí thì OK (không cần kiểm tra liền kề)
                                if (pos.length <= 1) return true;
                                // Nếu khác ≥2 vị trí, kiểm tra liền kề
                                return pos.every((p, i) => i === 0 || p - pos[i - 1] === 1);
                            });
                            // Tính lại rows dựa trên filtered labels
                            const filteredRows = [];
                            filteredLabels.forEach(label => {
                                filteredRows.push(...labelRows[label]);
                            });
                            return { base: g.base, labels: filteredLabels, rows: filteredRows };
                        }).filter(g => g.rows.length >= 2); // Chỉ giữ nhóm ≥2 kỳ
                    }

                    groups.sort((a, b) => b.rows.length - a.rows.length);
                    groupCache = groups;
                    cacheKey = newCacheKey;
                    renderGroups(groups);
                }
            }

            function renderGroups(groups) {
                // Apply sorting based on sortSel value
                if (sortSel.value === 'count_desc') groups.sort((a, b) => b.rows.length - a.rows.length);
                else if (sortSel.value === 'count_asc') groups.sort((a, b) => a.rows.length - b.rows.length);
                else if (sortSel.value === 'value_asc') groups.sort((a, b) => compareKey(a.base, b.base));
                else if (sortSel.value === 'value_desc') groups.sort((a, b) => compareKey(b.base, a.base));

                // Summary + grid container
                wrap.innerHTML = `<div class='muted'>${groups.length} nhóm · ${groups.reduce((s, g) => s + g.rows.length, 0)} kỳ</div>` +
                    `<div class='grid-centered' id='labelGroupGrid'></div>`;
                const grid = wrap.querySelector('#labelGroupGrid');

                // Caches for smoother back-scroll (per-page keys `${idx}|${page}`)
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = []; // maintain recency for limiting cache
                const MAX_CACHE = 160;
                const cardRefs = new Map(); // idx -> element
                const mountedSet = new Set(); // idx currently mounted
                const MAX_MOUNTED = 36; // limit live DOM to reduce churn

                const setCache = (key, html) => {
                    htmlCache.set(key, html);
                    lruQueue.push(key);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        const rmIdx = String(rm).split('|')[0];
                        if (!mountedSet.has(Number(rmIdx))) htmlCache.delete(rm);
                    }
                };

                const mount = (card, g, idx) => {
                    const body = card.querySelector('.card-body');
                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(g.rows.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;
                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const start = page * pageSizeRows;
                        const rowsToUse = (typeof recencySel !== 'undefined' && recencySel.value === 'desc') ? g.rows.slice().reverse() : g.rows.slice();
                        const slice = rowsToUse.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        inner += "<table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        slice.forEach(r => {
                            const label = labelOf(r.nums);
                            const labelHtml = label.split("").map((ch, i) => ch !== g.base[i]
                                ? `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>`
                                : `<span>${ch}</span>`).join(" ");
                            const nums = r.nums.map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        inner += "</tbody></table>";
                        if (g.rows.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${g.rows.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner);
                    }
                    body.style.minHeight = "";
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell7
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell7_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // attach hover + Ctrl+click handler to tbody so Ctrl+click will mark + apply to Cell6.6
                    (function attachRowHoverAndCtrlClick() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;
                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });
                            _tbody.addEventListener('mouseout', () => { return; });

                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell7_ctrl_selected', result); } catch (e) { }

                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220);
                                        }, 200);
                                    } else {
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // attach pagination handlers
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    // Measure and cache height after first mount
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = ""; // free DOM when offscreen
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    // Unmount farthest cards first
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const g = groups[idx];
                        if (!g) return;
                        if (entry.isIntersecting) {
                            mount(entry.target, g, idx);
                        } else {
                            unmount(entry.target, idx);
                        }
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Chunked creation of cards to avoid main-thread spikes
                const totalGroups = groups.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, groups.length);
                    for (let i = created; i < end; i++) {
                        const g = groups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // show rank/total to the left of the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>Base ${g.base}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${g.rows.length} kỳ</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < groups.length) requestAnimationFrame(createChunk);
                };
                createChunk();
                // After rendering group cards, ensure page scrolls to 240px
                // Use a small delay to allow layout to settle before scrolling
                try { setTimeout(() => { window.scrollTo({ top: 240, behavior: 'smooth' }); }, 50); } catch (e) { try { setTimeout(() => { window.scrollTo(0, 240); }, 50); } catch (er) { /* ignore */ } }
            }

            // Dùng debounce để tránh tính toán quá tần suất
            const debouncedGroup = createDebounce(group, 300);
            diffSel.onchange = consec.onchange = debouncedGroup;
            recencySel.onchange = debouncedGroup;
            sortSel.onchange = () => groupCache && renderGroups(groupCache);
            group();
        }

        // Helper: parse a comma/space separated string into six valid numbers (1-45), or return null
        function parseSixNumbersFromString(s) {
            if (!s || typeof s !== 'string') return null;
            // split on any non-digit characters
            const parts = s.split(/[^0-9]+/).map(p => p.trim()).filter(Boolean);
            if (parts.length !== 6) return null;
            const nums = parts.map(p => parseInt(p, 10));
            if (nums.some(n => !Number.isFinite(n) || n < 1 || n > 45)) return null;
            const uniq = new Set(nums);
            if (uniq.size !== 6) return null;
            return nums;
        }

        // Helper: apply an array of 6 numbers into the cell6_6 inputs (if present)
        function applySixToCell6_6(nums) {
            try {
                if (!Array.isArray(nums) || nums.length !== 6) return false;
                const sec = document.getElementById('cell6_6');
                if (!sec) return false;
                const inputs = Array.from(sec.querySelectorAll('.drag-input-container input'));
                if (!inputs || inputs.length < 6) return false;
                for (let i = 0; i < 6; i++) {
                    inputs[i].value = String(nums[i]);
                    inputs[i].dispatchEvent(new Event('input'));
                }
                // small visual feedback: pulse the first input container
                try {
                    const cont = inputs[0].parentElement;
                    if (cont) {
                        cont.animate([{ boxShadow: '0 0 0 6px rgba(56,239,125,0.18)' }, { boxShadow: '0 0 0 0 rgba(56,239,125,0)' }], { duration: 450 });
                    }
                } catch (e) { }
                return true;
            } catch (e) { return false; }
        }

        // Delegated dblclick behavior: read clipboard and, when a place-box or a cell6_6 input is double-clicked,
        // parse a 6-number string and apply it to the Cell6.6 inputs. Use document-level delegation so listeners
        // work regardless of render order.
        (function setupClipboardDoubleClickHandlersDelegated() {
            try {
                document.addEventListener('dblclick', async (ev) => {
                    // If the dblclick happened inside the number picker popup, let the
                    // popup-local handlers handle it (they run on the target). The
                    // global handler runs in capture mode and may cause unwanted
                    // focus/scroll behavior; ignore events originating inside the popup.
                    try {
                        const popup = document.getElementById('numberPickerPopup');
                        if (popup && popup.contains(ev.target)) return;
                    } catch (e) { }

                    // Only handle dblclick when user targets a place-box or one of the six input containers
                    const box = ev.target.closest('.place-box');
                    const inputContainer = ev.target.closest('.drag-input-container');
                    if (!box && !inputContainer) return;

                    let text = null;
                    // Try clipboard API first
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            text = await navigator.clipboard.readText();
                        }
                    } catch (err) {
                        // ignore and fall back to prompt
                        text = null;
                    }

                    // If clipboard API not available or returned empty, fall back to prompt
                    if (!text || String(text).trim() === '') {
                        try {
                            const promptStr = 'Paste 6 numbers (comma or space separated), e.g. 29,3,35,24,18,30';
                            const res = window.prompt(promptStr, '');
                            if (res && String(res).trim() !== '') text = res.trim();
                        } catch (e) { text = null; }
                    }

                    if (!text) return;

                    try {
                        const nums = parseSixNumbersFromString(text);
                        const targetElem = box || inputContainer || ev.target;
                        if (nums) {
                            applySixToCell6_6(nums);
                            try { if (targetElem) targetElem.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (e) { }
                        } else {
                            try { if (targetElem) targetElem.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (e) { }
                        }
                    } catch (err) { console.warn('clipboard parse/apply failed', err); }
                }, true);
            } catch (e) { }
        })();

        // Cell6.6: Mổ pattern — accept exactly 6 distinct numbers and list all combinations
        function renderCell6_6() {
            const body = sectionShell("cell6_6", "Cell6.6 · Mổ pattern", "Nhập đủ 6 số (1-45) và chọn kích thước tổ hợp để liệt kê.");
            const controls = document.createElement("div"); controls.className = "controls";

            // six fixed number inputs with per-input +/- buttons and global left/right navigation
            const rawInputs = Array.from({ length: 6 }, (_, i) => {
                const inp = document.createElement('input');
                inp.type = 'number'; inp.min = 1; inp.max = 45; inp.placeholder = `#${i + 1}`;
                inp.style.width = '70px'; inp.style.boxSizing = 'border-box';
                return inp;
            });

            // create select controls
            const combSel = document.createElement('select');[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = `Bộ ${v}`; combSel.appendChild(o); }); combSel.value = '3';
            const sortSel = document.createElement('select');[["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            // recency selector (Mới → Cũ / Cũ → Mới) — mirror Cell6.5 behavior
            const recencySel = document.createElement('select');
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';

            // consecutive & order toggles (same behavior as Cell6/Cell6.5)
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;

            // (no global nav buttons — per-input arrow buttons and keyboard arrows remain)

            const inputs = [];
            // create per-input container with up/down buttons (same behavior as Cell9)
            rawInputs.forEach((inp, idx) => {
                const container = document.createElement('div');
                container.className = 'drag-input-container';
                container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;vertical-align:middle;';
                container.draggable = false;

                // small left-side grip (visual) — kept but pointer-events managed by updateDraggable
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // reserve space on the right for buttons to match Cell9
                inp.style.position = 'relative'; inp.style.zIndex = '1'; inp.style.paddingRight = '40px'; inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                // clamp helper for numeric input
                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });

                btnGroup.appendChild(up); btnGroup.appendChild(down);
                container.appendChild(inp); container.appendChild(btnGroup); container.appendChild(dragHandle);
                container.dataset.index = idx;

                // visual/state update for draggable container
                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                // keyboard left/right move (wrap)
                inp.addEventListener('keydown', (ev) => {
                    if (ev.key === 'ArrowLeft') {
                        ev.preventDefault();
                        const prev = (idx - 1 + 6) % 6; rawInputs[prev].focus();
                    } else if (ev.key === 'ArrowRight') {
                        ev.preventDefault();
                        const next = (idx + 1) % 6; rawInputs[next].focus();
                    }
                });

                inp.addEventListener('input', () => { clampForNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampForNumber(); updateDraggable(); });
                updateDraggable();

                // drag/drop: allow dragging this input out to clear it, and swapping values with another input
                container.__dropHandled = false;
                container.__dragging = false;

                container.addEventListener('dragstart', (e) => {
                    container.__dragging = true;
                    container.__dropHandled = false;
                    container.style.opacity = '0.5';
                    try { window.__draggingDynamic = { type: 'cell6_6', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                    try { e.dataTransfer.setData('text/plain', String(inp.value ?? '')); } catch (er) { }
                    try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                });

                container.addEventListener('dragend', (e) => {
                    container.style.opacity = '';
                    try { window.__draggingDynamic = null; } catch (err) { }
                    if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                        draw();
                    }
                    container.__dragging = false;
                    container.__dropHandled = false;
                });

                container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(56, 239, 125, 0.04)'; });
                container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                container.addEventListener('drop', (e) => {
                    e.preventDefault(); container.style.backgroundColor = ''; container.__dropHandled = true;
                    const txt = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');
                    let value = null;
                    // If dragging from another dynamic input, swap values instead of replacing
                    try {
                        if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                            const srcInput = window.__draggingDynamic.input;
                            const srcVal = String(srcInput.value ?? '');
                            const tgtVal = String(inp.value ?? '');
                            // perform swap
                            srcInput.value = tgtVal;
                            srcInput.dispatchEvent(new Event('input'));
                            inp.value = srcVal;
                            inp.dispatchEvent(new Event('input'));
                            // mark both containers as handled to avoid clearing on dragend
                            try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                            container.__dropHandled = true;
                            try { window.__draggingDynamic = null; } catch (err) { }
                            draw();
                            return;
                        }
                    } catch (err) { }

                    if (placeIndexData) {
                        const idx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                    } else if (placeSetData) {
                        // If full place-set (6 values) is dropped, apply the entire 6-number state to the cell
                        try {
                            const arr = JSON.parse(placeSetData);
                            if (Array.isArray(arr) && arr.length === 6) {
                                try {
                                    // write all six inputs
                                    for (let k = 0; k < 6; k++) {
                                        const v = arr[k];
                                        if (v === null || v === undefined || String(v).trim() === '') {
                                            inputs[k].value = '';
                                        } else {
                                            let nn = parseInt(String(v).trim(), 10);
                                            if (!Number.isFinite(nn)) nn = '';
                                            else {
                                                if (nn < 1) nn = 1;
                                                if (nn > 45) nn = 45;
                                            }
                                            inputs[k].value = nn === '' ? '' : String(nn);
                                        }
                                        inputs[k].dispatchEvent(new Event('input'));
                                    }
                                    // mark all containers handled so they won't clear on dragend
                                    try { inputs.forEach(i => i.parentElement.__dropHandled = true); } catch (e) { }
                                    try { window.__draggingDynamic = null; } catch (e) { }
                                    draw();
                                    return;
                                } catch (err) { }
                            }
                            // fallback: pick first non-empty value in the set for this single input
                            if (Array.isArray(arr) && arr.length) {
                                for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } }
                            }
                        } catch (err) { }
                    } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                        value = txt;
                    } else if (labelData) { value = labelData; }

                    if (value !== null && value !== undefined) {
                        let n = parseInt(String(value).trim(), 10);
                        if (Number.isFinite(n)) {
                            if (n < 1) n = 1;
                            if (n > 45) n = 45;
                            inp.value = String(n);
                            inp.dispatchEvent(new Event('input'));
                            draw();
                        }
                    }
                });

                inputs.push(inp);
                controls.append(container);
            });

            // trash selector for Cell6.6 — kept in sync with Cell6.5
            const trashSel = document.createElement('select');
            ['include', 'exclude'].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; trashSel.appendChild(o); });
            trashSel.value = 'include';
            try { trashSel.id = 'cell6_6_trashSel'; trashSel.className = 'trash-mode'; trashSel.style.cssText = 'width:100px;margin-left:4px;height:28px;vertical-align:middle;'; } catch (e) { }
            trashSel.title = 'Trash mode (include/exclude)';
            trashSel.addEventListener('change', () => {
                try {
                    const other = document.getElementById('cell6_5_trashSel');
                    if (other) other.value = trashSel.value;
                } catch (e) { }
                try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                try { draw(); } catch (e) { }
            });

            // keep this selector in sync when popup or Cell6.5 updates trash
            try {
                document.addEventListener('trashchange', () => {
                    try {
                        const other = document.getElementById('cell6_5_trashSel');
                        if (other && trashSel && trashSel.value !== other.value) trashSel.value = other.value;
                    } catch (e) { }
                    try { draw(); } catch (e) { }
                });
            } catch (e) { }

            controls.append('Kích thước:', combSel, consecLabel, orderLabel, 'Sắp xếp:', sortSel, recencySel, 'Trash:', trashSel);
            body.appendChild(controls);

            const wrap = document.createElement('div'); wrap.className = 'card card-inner'; body.appendChild(wrap);

            function draw() {
                if (!rows || !rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const vals = inputs.map(i => { const v = String(i.value ?? '').trim(); return v === '' ? NaN : parseInt(v, 10); });
                if (vals.some(v => !Number.isFinite(v))) { wrap.innerHTML = "<div class='muted'>Vui lòng nhập đủ 6 số hợp lệ</div>"; return; }
                const uniq = new Set(vals);
                if (uniq.size !== 6) { wrap.innerHTML = "<div class='error'>Các số phải khác nhau</div>"; return; }

                const m = parseInt(combSel.value, 10) || 1;

                // generate all combinations from the user-provided 6 numbers
                const combos = kCombinations(vals, m).map(c => c.slice().sort((a, b) => a - b));

                // compute global counts for all combos of size m across rows
                // respect consecutive/order toggles when counting
                const globalCounts = Object.create(null);
                const consecChecked = !!consec.checked;
                const orderChecked = !!order.checked;
                // read trash mode from Cell6.5 (if present) so Cell6.6 mirrors its behavior
                // If Cell6.5 selector is missing (e.g., not rendered), fall back to this cell's own selector
                let trashModeEl = null;
                try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                if (!trashModeEl) trashModeEl = trashSel;
                const trashMode = (trashModeEl && (trashModeEl.value || trashSel && trashSel.value)) ? (trashModeEl.value || trashSel.value) : 'include';
                const trashedArr = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                const trashedSet = new Set((trashedArr || []).map(n => Number(n)));
                rows.forEach(r => {
                    if (!r.nums || !Array.isArray(r.nums)) return;
                    if (trashMode === 'exclude') {
                        // skip any row containing a trashed number
                        let skip = false;
                        for (const nn of r.nums) { if (trashedSet.has(Number(nn))) { skip = true; break; } }
                        if (skip) return;
                    }
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            globalCounts[key] = (globalCounts[key] || 0) + 1;
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m).map(c => c.slice().sort((a, b) => a - b));
                        combosRow.forEach(c => { const k = c.join('-'); globalCounts[k] = (globalCounts[k] || 0) + 1; });
                    }
                });

                // build results for user's combos
                const results = combos.map(c => {
                    const key = c.join('-');
                    return { key, combo: c, cnt: globalCounts[key] || 0 };
                });

                // build ranking map over all global combos (use same baseline sort logic as other cells)
                const globalArr = Object.keys(globalCounts).map(k => ({ k, cnt: globalCounts[k] }));
                const baselineSort = sortSel.value;
                if (baselineSort === "value_asc") globalArr.sort((a, b) => compareKey(a.k, b.k));
                else if (baselineSort === "value_desc") globalArr.sort((a, b) => compareKey(b.k, a.k));
                else if (baselineSort === "count_asc") globalArr.sort((a, b) => a.cnt - b.cnt);
                else globalArr.sort((a, b) => b.cnt - a.cnt);
                const rankMap = Object.create(null);
                globalArr.forEach((it, idx) => { rankMap[it.k] = idx + 1; });

                // apply requested sort
                if (sortSel.value === 'value_asc') results.sort((a, b) => compareKey(a.key, b.key));
                else if (sortSel.value === 'value_desc') results.sort((a, b) => compareKey(b.key, a.key));
                else if (sortSel.value === 'count_asc') results.sort((a, b) => a.cnt - b.cnt);
                else results.sort((a, b) => b.cnt - a.cnt);

                // build groups for only the user's combos (map key -> rows array)
                const userKeys = new Set(results.map(r => r.key));
                const groups = new Map();
                rows.forEach(r => {
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            if (!userKeys.has(key)) continue;
                            if (!groups.has(key)) groups.set(key, []);
                            groups.get(key).push(r);
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m);
                        combosRow.forEach(c => {
                            const values = c.slice().sort((a, b) => a - b);
                            const k = values.join('-');
                            if (!userKeys.has(k)) return;
                            if (!groups.has(k)) groups.set(k, []);
                            groups.get(k).push(r);
                        });
                    }
                });
                // If trashMode is 'exclude', filter the groups' rows to remove trashed-number rows
                if (trashMode === 'exclude' && trashedSet && trashedSet.size) {
                    for (const [k, list] of groups.entries()) {
                        const filtered = (list || []).filter(r => {
                            if (!r.nums || !Array.isArray(r.nums)) return false;
                            for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                            return true;
                        });
                        groups.set(k, filtered);
                    }
                }

                // build array of [key, list] for user's combos
                // include combos with no records (empty list) so every user combo is shown
                let arrGroups = results.map(r => [r.key, groups.get(r.key) || []]);

                // build baseline over all global combos for ranking (same baseline sort logic)
                const globalArrFull = Object.keys(globalCounts).map(k => [k, []]);
                // populate counts into a map for baseline ordering
                const baselineArrAll = Object.keys(globalCounts).map(k => [k, new Array(globalCounts[k])]);
                // sort baseline keys according to baselineSort (reuse earlier `baselineSort`)
                if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => globalCounts[a[0]] - globalCounts[b[0]]);
                else baselineArrAll.sort((a, b) => globalCounts[b[0]] - globalCounts[a[0]]);

                // sort displayed groups according to user's sortSel
                if (sortSel.value === 'value_asc') arrGroups.sort((a, b) => compareKey(a[0], b[0]));
                else if (sortSel.value === 'value_desc') arrGroups.sort((a, b) => compareKey(b[0], a[0]));
                else if (sortSel.value === 'count_asc') arrGroups.sort((a, b) => a[1].length - b[1].length);
                else arrGroups.sort((a, b) => b[1].length - a[1].length);

                // render cards similar to Cell6: one card per combo showing rows
                // Create container and defer building full table HTML until a card is visible
                wrap.innerHTML = `<div class='muted'>${arrGroups.length} tổ hợp · hiển thị tối đa ${arrGroups.length} bảng</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // caches and mount management
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}|${recency}`)
                const heightCache = new Map();
                const lruQueue = [];
                const MAX_CACHE = 160;
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idxForCache) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idxForCache)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arrGroups[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    let displayList = (list && list.slice) ? list.slice() : [];
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                    const totalPages = Math.max(1, Math.ceil(displayList.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        const baselineTotal = baselineArrAll && baselineArrAll.length ? baselineArrAll.length : arrGroups.length;
                        const idxInBaseline = baselineArrAll ? baselineArrAll.findIndex(([k]) => k === key) : -1;
                        // By default show baseline ranking (position within all combos)
                        // baseline arrays were computed from `globalCounts` which already
                        // respect trashMode (include/exclude). Use those values so that
                        // when trash mode is 'exclude' the sample space and ranks shrink
                        // accordingly.
                        let rankDisplay = `${idx + 1}/${arrGroups.length}`;
                        let occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                        try {
                            if (idxInBaseline >= 0) {
                                rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                            }
                            // Prefer showing the globalCounts-based occurrence which
                            // already accounts for any excluded trashed rows.
                            occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                        } catch (e) {
                            if (idxInBaseline >= 0) {
                                rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                                occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                            }
                        }

                        inner = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                            `<span class='badge'>${occDisplay}</span>` +
                            `</div>` +
                            `</div>`;

                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;

                        inner += `<table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        if (slice.length === 0) {
                            inner += `<tr><td colspan='4' class='muted'>Không có kết quả</td></tr>`;
                        } else {
                            // Build a stable mapping from row key -> global indices so we can
                            // map page copies back to canonical `rows` indices for k computation
                            const rowKeyToIndices = new Map();
                            try {
                                rows.forEach((rr, gi) => {
                                    try {
                                        const rk = (rr.nums && Array.isArray(rr.nums) ? rr.nums.join(',') : '') + '|' + (rr.date || '');
                                        if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                                        rowKeyToIndices.get(rk).push(gi);
                                    } catch (err) { }
                                });
                            } catch (err) { }

                            // Build pool of numbers (respect numberPickerTable if present)
                            let pool = [];
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                if (npTable) {
                                    const tds = Array.from(npTable.querySelectorAll('td[data-number]'));
                                    pool = tds.map(td => Number(td.dataset.number)).filter(n => Number.isFinite(n));
                                }
                            } catch (e) { }
                            if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);

                            // Greedy simulation: record first-k when each global row becomes excluded
                            const rowFirstExcludedAt = new Array(rows.length).fill(null);
                            const chosen = new Set();
                            const maxK = pool.length;
                            for (let kIdx = 1; kIdx <= maxK; kIdx++) {
                                let best = null; let bestNew = Infinity;
                                for (const cand of pool) {
                                    if (chosen.has(cand)) continue;
                                    let newExcl = 0;
                                    for (let gi = 0; gi < rows.length; gi++) {
                                        if (rowFirstExcludedAt[gi] !== null) continue;
                                        const rr = rows[gi];
                                        if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                        for (const nn of rr.nums) { if (Number(nn) === cand) { newExcl++; break; } }
                                    }
                                    if (newExcl < bestNew) { bestNew = newExcl; best = cand; }
                                }
                                if (best === null) break;
                                for (let gi = 0; gi < rows.length; gi++) {
                                    if (rowFirstExcludedAt[gi] !== null) continue;
                                    const rr = rows[gi];
                                    if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                    for (const nn of rr.nums) { if (Number(nn) === best) { rowFirstExcludedAt[gi] = kIdx; break; } }
                                }
                                chosen.add(best);
                            }

                            // Now emit table rows, mapping each page-copy `r` to a global index
                            slice.forEach(r => {
                                const orderedSeqForHighlight = (consecChecked && orderChecked) ? key.split('-').map(Number) : Array.from(setValues);
                                const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, m, consecChecked, orderedSeqForHighlight, orderChecked);
                                const labelHtml = renderHighlightedLabel(r.label, positions);
                                let euclidPartsHtml = [];
                                let euclidTotal = 0;
                                try {
                                    const npTable = document.getElementById('numberPickerTable');
                                    const tbody = npTable ? npTable.querySelector('tbody') : null;
                                    const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                    for (let j = 0; j < 5; j++) {
                                        const n1 = r.nums[j];
                                        const n2 = r.nums[j + 1];
                                        let part = '';
                                        if (npTable && tbodyRows.length > 0) {
                                            const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                            const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                            if (cell1 && cell2) {
                                                const rowElem1 = cell1.parentElement;
                                                const rowElem2 = cell2.parentElement;
                                                const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                                const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                                const logicalRow1 = 7 - rowIdx1;
                                                const logicalRow2 = 7 - rowIdx2;
                                                const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                                const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                                const dx = colIdx2 - colIdx1;
                                                const dy = logicalRow2 - logicalRow1;
                                                const d = Math.sqrt(dx * dx + dy * dy);
                                                part = isFinite(d) ? d.toFixed(2) : '';
                                                euclidTotal += isFinite(d) ? d : 0;
                                            }
                                        }
                                        if (part) euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                        else euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                } catch (e) {
                                    for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                                const totalStr = euclidTotal.toFixed(2);
                                const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;

                                // determine t (largest k for which the record remains visible)
                                let t = pool.length;
                                try {
                                    const rk = (r.nums && Array.isArray(r.nums) ? r.nums.join(',') : '') + '|' + (r.date || '');
                                    const gids = rowKeyToIndices.get(rk) || [];
                                    const gi = (gids && gids.length) ? gids[0] : null;
                                    if (gi !== null && rowFirstExcludedAt[gi] !== null) t = Math.max(0, rowFirstExcludedAt[gi] - 1);
                                } catch (err) { }

                                inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${t}" data-k="${t}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                            });
                        }
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }

                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;
                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });
                            _tbody.addEventListener('mouseout', () => { return; });
                        } catch (err) { }
                    })();

                    try { if (typeof updateHeaderCount === 'function') updateHeaderCount(); } catch (e) { }
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // create card shells in chunks to avoid blocking layout
                const totalGroups = arrGroups.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arrGroups.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arrGroups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        // Only create an empty card body here. The card header (div.flex)
                        // will be rendered inside the mounted body to avoid duplicate headers.
                        card.innerHTML = `<div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arrGroups.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                if (arrGroups.length === 1) wrap.classList.add('single-child');

                // After chunked creation completes, scroll viewport to keep controls visible
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } }
                    });
                }, 160);
            }

            // wire events: input changes trigger redraw
            inputs.forEach((i) => i.addEventListener('input', draw));
            combSel.addEventListener('change', draw);
            sortSel.addEventListener('change', draw);
            if (recencySel) recencySel.addEventListener('change', draw);
            // consec toggles enable/disable order and trigger redraw
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; draw(); };
            order.addEventListener('change', draw);
            draw();

            // Listen to trash changes (dispatched by popup) so Cell6.6 mirrors Cell6.5 behavior
            try {
                const secEl = document.getElementById('cell6_6');
                if (secEl && !secEl.__trashListenerAdded) {
                    secEl.__trashListenerAdded = true;
                    document.addEventListener('trashchange', () => { try { draw(); } catch (e) { } });
                }
            } catch (e) { /* ignore */ }
        }
        // Cell6.5: Truy x - same grouping logic as Cell6 but filter groups to those containing a user-specified number x
        function renderCell6_5() {
            const body = sectionShell("cell6_5", "Cell6.5 · Truy x", "Chọn số x (1-45) và kích thước bộ để liệt kê chỉ những bộ liên quan tới x.");
            // Mode selector placed next to the H2 header
            try {
                const sec = document.getElementById('cell6_5');
                const h2 = sec ? sec.querySelector('h2') : null;
                if (h2) {
                    const modeSel = document.createElement('select');
                    modeSel.title = 'Chế độ hiển thị';
                    modeSel.style.marginLeft = '12px';
                    ['truy', 'lienket'].forEach(k => {
                        const o = document.createElement('option');
                        if (k === 'truy') { o.value = 'truy'; o.textContent = 'Truy x (mặc định)'; }
                        else { o.value = 'lienket'; o.textContent = 'Liên kết x'; }
                        modeSel.appendChild(o);
                    });
                    // insert inside the H2 so the dropdown stays compact on the same line
                    h2.appendChild(modeSel);
                    // ensure default mode is 'truy'
                    try { modeSel.value = 'truy'; } catch (e) { }
                    modeSel.style.cssText = 'margin-left:12px;font-size:12px;padding:4px 6px;height:28px;vertical-align:middle;';
                    // build a separate controls container for Liên kết x
                    const lkControls = document.createElement('div'); lkControls.className = 'controls';
                    lkControls.style.display = 'none';
                    // top input
                    const topLabel = document.createElement('input'); topLabel.type = 'number'; topLabel.min = 1; topLabel.placeholder = 'Top (dương)'; topLabel.style.width = '120px';
                    // bộ dropdown (1..6)
                    const lkSetSel = document.createElement('select');[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement('option'); o.value = String(v); o.textContent = `Bộ ${v}`; lkSetSel.appendChild(o); }); lkSetSel.value = '2';
                    // append inputs (no explicit button — auto-update on change)
                    lkControls.appendChild(document.createTextNode('Top:'));
                    lkControls.appendChild(topLabel);
                    lkControls.appendChild(document.createTextNode('Bộ:'));
                    lkControls.appendChild(lkSetSel);
                    // place the lkControls below the header by inserting into the DOM
                    // (insert before the original next sibling of h2)
                    h2.parentElement.insertBefore(lkControls, h2.nextSibling);

                    // switching logic will be attached later after main controls created
                    // expose references on body so switch handler can access them
                    body.__modeSel = modeSel;
                    body.__lkControls = lkControls;
                    body.__lkTopInput = topLabel;
                    body.__lkSetSel = lkSetSel;
                }
            } catch (e) { /* ignore if DOM ops fail */ }

            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `Bộ ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            // remember previous comb so we only clear extras when shrinking the set
            let prevComb = parseInt(xSel.value, 10) || 1;
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement("select");
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';
            const xFilter = document.createElement("input"); xFilter.type = "number"; xFilter.min = 1; xFilter.max = 45; xFilter.placeholder = "Số x (1-45)"; xFilter.style.width = '88px';
            // Create +/- buttons styled and behaving like Cell9 arrows
            const xContainer = document.createElement('div');
            xContainer.style.cssText = 'position:relative;display:inline-block;vertical-align:middle;margin-right:8px;';
            xFilter.style.paddingRight = '40px';
            xFilter.style.boxSizing = 'border-box';
            const btnGroup = document.createElement('div');
            btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
            const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
            const upBtn = document.createElement('button'); upBtn.type = 'button'; upBtn.className = 'arrow-up'; upBtn.innerHTML = '▲'; upBtn.title = 'Tăng 1'; upBtn.style.cssText = arrowStyle;
            const downBtn = document.createElement('button'); downBtn.type = 'button'; downBtn.className = 'arrow-down'; downBtn.innerHTML = '▼'; downBtn.title = 'Giảm 1'; downBtn.style.cssText = arrowStyle;

            upBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n + 1;
                if (n > 45) n = 1; // wrap like cell9
                if (n < 1) n = 1;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            downBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n - 1;
                if (n < 1) n = 45; // wrap like cell9
                if (n > 45) n = 45;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            btnGroup.appendChild(upBtn);
            btnGroup.appendChild(downBtn);
            xContainer.appendChild(xFilter);
            xContainer.appendChild(btnGroup);

            // Make the input container draggable like Cell9 inputs: allow dragging-out to clear value
            xContainer.__dropHandled = false;
            let draggedX = false;

            const updateXDraggable = () => {
                const v = String(xFilter.value ?? '').trim();
                const has = v !== '';
                xContainer.draggable = has;
                xContainer.style.cursor = has ? 'grab' : 'default';
                xContainer.style.opacity = has ? '' : '';
            };
            updateXDraggable();
            xFilter.addEventListener('input', () => {
                updateXDraggable();
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            xContainer.addEventListener('dragstart', (e) => {
                draggedX = true;
                xContainer.__dropHandled = false;
                // expose global dragging source so other dynamic drops can swap values
                try { window.__draggingDynamic = { type: 'xFilter', input: xFilter, container: xContainer, value: String(xFilter.value ?? '') }; } catch (err) { }
                xContainer.style.opacity = '0.5';
                try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                e.dataTransfer.setData('text/plain', String(xFilter.value ?? ''));
                // include full place set for richer drops
                try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
            });

            xContainer.addEventListener('dragend', (e) => {
                xContainer.style.opacity = '';
                // If drag ended without a handled drop, clear the input (like Cell9 behavior)
                try { window.__draggingDynamic = null; } catch (err) { }
                if (!xContainer.__dropHandled && draggedX && String(xFilter.value ?? '').trim() !== '') {
                    xFilter.value = '';
                    xFilter.dispatchEvent(new Event('input'));
                    if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                }
                draggedX = false;
                xContainer.__dropHandled = false;
            });

            // Accept drags from number picker popup (single number, place index or place set)
            xContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { }
                xContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
            });
            xContainer.addEventListener('dragleave', () => {
                xContainer.style.backgroundColor = '';
            });
            xContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                xContainer.style.backgroundColor = '';
                xContainer.__dropHandled = true;
                const txt = e.dataTransfer.getData('text/plain');
                const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                const placeSetData = e.dataTransfer.getData('application/x-place-set');
                const labelData = e.dataTransfer.getData('application/x-label');
                let value = null;
                // If dragging from another dynamic input, swap values instead of replacing
                try {
                    if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== xFilter) {
                        const srcInput = window.__draggingDynamic.input;
                        const srcVal = String(srcInput.value ?? '');
                        const tgtVal = String(xFilter.value ?? '');
                        // perform swap
                        srcInput.value = tgtVal;
                        srcInput.dispatchEvent(new Event('input'));
                        xFilter.value = srcVal;
                        xFilter.dispatchEvent(new Event('input'));
                        // mark both containers as handled to avoid clearing on dragend
                        try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                        xContainer.__dropHandled = true;
                        // conclude drop handling
                        try { window.__draggingDynamic = null; } catch (err) { }
                        return;
                    }
                } catch (err) { }
                if (placeIndexData) {
                    const idx = parseInt(placeIndexData, 10);
                    const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                    if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                    // Prefer simple text/plain payloads (single number) over place-set JSON
                    value = txt;
                } else if (placeSetData) {
                    try {
                        const arr = JSON.parse(placeSetData);
                        if (Array.isArray(arr) && arr.length) {
                            // pick first numeric value in the set
                            for (const v of arr) {
                                if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; }
                            }
                        }
                    } catch (err) { }
                } else if (labelData) {
                    value = labelData;
                }

                if (value !== null && value !== undefined) {
                    let n = parseInt(String(value).trim(), 10);
                    if (Number.isFinite(n)) {
                        if (n < 1) n = 1;
                        if (n > 45) n = 45;
                        xFilter.value = String(n);
                        xFilter.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    }
                }
            });

            // Container for extra combo inputs (comb - 1) shown when user selects comb > 1
            const comboExtras = document.createElement('div');
            comboExtras.style.cssText = 'display:flex;gap:6px;align-items:center;margin-left:6px;flex-wrap:wrap;';

            // Build or rebuild the (comb - 1) extra inputs based on xSel
            function rebuildComboExtras(prefill = []) {
                comboExtras.innerHTML = '';
                const comb = parseInt(xSel.value, 10) || 1;
                const count = Math.max(0, comb - 1);
                for (let i = 0; i < count; i++) {
                    // container mimics Cell9 input container with drag handle and up/down buttons
                    const container = document.createElement('div');
                    container.className = 'combo-extra-container';
                    container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;padding:2px;border-radius:8px;border:2px solid #f8f333;background:rgba(248,243,180,0.04);';

                    const inp = document.createElement('input');
                    inp.type = 'number';
                    inp.min = 1; inp.max = 45;
                    inp.placeholder = `v${i + 1}`;
                    inp.className = 'combo-extra';
                    inp.style.cssText = 'width:64px;padding:8px;border-radius:6px;border:0;background:transparent;color:var(--text);box-sizing:border-box;';
                    // prefill if value for this index was provided (preserve when increasing comb)
                    if (prefill && prefill[i] !== undefined && String(prefill[i]).trim() !== '') {
                        const parsed = parseInt(String(prefill[i]).trim(), 10);
                        if (Number.isFinite(parsed)) {
                            const clamped = Math.max(1, Math.min(45, parsed));
                            inp.value = String(clamped);
                        }
                    }

                    // right-side up/down buttons
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;
                    btnGroup.appendChild(up); btnGroup.appendChild(down);

                    // drag handle (visual)
                    const dragHandle = document.createElement('div');
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);pointer-events:none;`;

                    // attach behaviors
                    container.__dropHandled = false;
                    container.__dragging = false;

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const has = v !== '';
                        container.draggable = has;
                        dragHandle.style.pointerEvents = has ? 'auto' : 'none';
                        dragHandle.style.cursor = has ? 'grab' : 'default';
                        // Always show yellow border even when empty
                        container.style.borderColor = '#f8f333';
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1; if (n > 45) n = 1; if (n < 1) n = 1;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1; if (n < 1) n = 45; if (n > 45) n = 45;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.addEventListener('dragstart', (e) => {
                        container.__dragging = true; container.__dropHandled = false;
                        container.style.opacity = '0.5';
                        try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                        e.dataTransfer.setData('text/plain', String(inp.value ?? ''));
                        try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                        // expose global dragging source so other dynamic drops can swap values
                        try { window.__draggingDynamic = { type: 'combo-extra', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    });
                    container.addEventListener('dragend', () => {
                        container.style.opacity = '';
                        try { window.__draggingDynamic = null; } catch (err) { }
                        if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                            inp.value = '';
                            inp.dispatchEvent(new Event('input'));
                            if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                        }
                        container.__dragging = false; container.__dropHandled = false; updateDraggable();
                    });

                    container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(248,243,180,0.06)'; });
                    container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                    container.addEventListener('drop', (e) => {
                        e.preventDefault(); container.style.backgroundColor = '';
                        container.__dropHandled = true;
                        const txt = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        let value = null;
                        // If dragging from another dynamic input, swap values instead of replacing
                        try {
                            if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                                const srcInput = window.__draggingDynamic.input;
                                const srcVal = String(srcInput.value ?? '');
                                const tgtVal = String(inp.value ?? '');
                                // perform swap
                                srcInput.value = tgtVal;
                                srcInput.dispatchEvent(new Event('input'));
                                inp.value = srcVal;
                                inp.dispatchEvent(new Event('input'));
                                // mark both containers as handled to avoid clearing on dragend
                                try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                                container.__dropHandled = true;
                                try { window.__draggingDynamic = null; } catch (err) { }
                                return;
                            }
                        } catch (err) { }

                        if (placeIndexData) {
                            const idx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                        } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                            value = txt;
                        } else if (placeSetData) {
                            try { const arr = JSON.parse(placeSetData); if (Array.isArray(arr) && arr.length) { for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } } } } catch (err) { }
                        } else if (labelData) { value = labelData; }

                        if (value !== null && value !== undefined) {
                            let n = parseInt(String(value).trim(), 10);
                            if (Number.isFinite(n)) {
                                if (n < 1) n = 1; if (n > 45) n = 45;
                                inp.value = String(n); inp.dispatchEvent(new Event('input'));
                                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                            }
                        }
                    });

                    inp.addEventListener('input', () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') { updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        if (n < 1) n = 1; if (n > 45) n = 45; inp.value = String(n);
                        updateDraggable();
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = String(i);
                    comboExtras.appendChild(container);
                    updateDraggable();
                }

                // Unified left/right navigation across the main x input and dynamic extras
                function setupFocusNavigation() {
                    const extrasInputs = Array.from(comboExtras.querySelectorAll('input.combo-extra'));
                    const navElems = [xFilter, ...extrasInputs];
                    navElems.forEach((el, idx) => {
                        el.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const nextIdx = e.key === 'ArrowLeft'
                                ? (idx - 1 + navElems.length) % navElems.length
                                : (idx + 1) % navElems.length;
                            try { navElems[nextIdx].focus(); } catch (err) { }
                        };
                    });
                }

                // Create focus navigation buttons (will be added to controls later)
                try {
                    if (typeof focusPrevBtn === 'undefined') {
                        var focusPrevBtn = document.createElement('button'); focusPrevBtn.type = 'button'; focusPrevBtn.className = 'nav-btn'; focusPrevBtn.title = 'Chuyển ô trái'; focusPrevBtn.textContent = '◀';
                        var focusNextBtn = document.createElement('button'); focusNextBtn.type = 'button'; focusNextBtn.className = 'nav-btn'; focusNextBtn.title = 'Chuyển ô phải'; focusNextBtn.textContent = '▶';
                        focusPrevBtn.style.marginRight = '6px'; focusNextBtn.style.marginLeft = '6px';
                        focusPrevBtn.addEventListener('click', () => {
                            const elems = [xFilter, ...Array.from(comboExtras.querySelectorAll('input.combo-extra'))];
                            const active = document.activeElement; let idx = elems.indexOf(active); if (idx === -1) idx = 0;
                            const prev = (idx - 1 + elems.length) % elems.length; try { elems[prev].focus(); } catch (e) { }
                        });
                        focusNextBtn.addEventListener('click', () => {
                            const elems = [xFilter, ...Array.from(comboExtras.querySelectorAll('input.combo-extra'))];
                            const active = document.activeElement; let idx = elems.indexOf(active); if (idx === -1) idx = 0;
                            const nxt = (idx + 1) % elems.length; try { elems[nxt].focus(); } catch (e) { }
                        });
                    }
                } catch (e) { }
                // ensure nav wiring after rebuild
                try { setupFocusNavigation(); } catch (e) { }
            }

            // rebuild extras when comb selection changes
            xSel.addEventListener('change', () => {
                const newComb = parseInt(xSel.value, 10) || 1;
                const oldCount = Math.max(0, prevComb - 1);
                const newCount = Math.max(0, newComb - 1);
                if (newCount >= oldCount) {
                    // preserve existing values when increasing or same size
                    const existing = Array.from(comboExtras.querySelectorAll('input[type="number"].combo-extra')).map(i => i.value ?? '');
                    rebuildComboExtras(existing);
                    // dispatch input for preserved values to trigger any UI updates
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => { if ((inp.value ?? '').trim() !== '') inp.dispatchEvent(new Event('input')); });
                } else {
                    // shrinking: preserve leading values up to newCount
                    const existing = Array.from(comboExtras.querySelectorAll('input[type="number"].combo-extra')).map(i => i.value ?? '');
                    const prefill = existing.slice(0, newCount);
                    rebuildComboExtras(prefill);
                    // dispatch input for preserved values to trigger any UI updates
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach((inp, idx) => {
                        if ((prefill[idx] ?? '').trim() !== '') inp.dispatchEvent(new Event('input'));
                    });
                }
                prevComb = newComb;
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            // initial build
            rebuildComboExtras();

            // Trash selector (copied from Cell5.5): compact include/exclude toggle
            const trashSel = document.createElement('select');
            ['include', 'exclude'].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; trashSel.appendChild(o); });
            trashSel.value = 'include';
            trashSel.title = 'Trash mode (include/exclude)';
            trashSel.style.cssText = 'width:120px;';
            // stable id so external listeners can find current selector after re-renders
            try { trashSel.id = 'cell6_5_trashSel'; trashSel.className = 'trash-mode'; } catch (e) { }

            // Mirror Cell6.6's selector syncing: when this selector changes,
            // propagate value to Cell6.6's selector, dispatch a global trashchange
            // and trigger a local recompute. Also listen for external trashchange
            // events to keep this selector in sync when Cell6.6 or popup updates.
            try {
                trashSel.addEventListener('change', () => {
                    try {
                        const other = document.getElementById('cell6_6_trashSel');
                        if (other) other.value = trashSel.value;
                    } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                });
            } catch (e) { }

            try {
                document.addEventListener('trashchange', () => {
                    try {
                        const other = document.getElementById('cell6_6_trashSel');
                        if (other && trashSel && trashSel.value !== other.value) trashSel.value = other.value;
                    } catch (e) { }
                    try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                });
            } catch (e) { }

            controls.append("Số x:", xContainer, typeof focusPrevBtn !== 'undefined' ? focusPrevBtn : document.createElement('span'), typeof focusNextBtn !== 'undefined' ? focusNextBtn : document.createElement('span'), comboExtras, "Bộ số:", xSel, consecLabel, orderLabel, "Sắp xếp:", sortSel, recencySel, "Trash:", trashSel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            // baseline (after main-x filter but before trash exclude) — keys preserved for stable rank
            let baselineArrAll = null;
            // global baseline (before applying main x filter) used to show overall rank
            let baselineArrGlobal = null;
            // map of original occurrence counts per key (computed before trash/exclude)
            let baselineCountsMap = null;
            // helper arrays of keys for quick rank lookups
            let baselineAllKeys = null;
            let baselineGlobalKeys = null;
            let isComputing = false;

            // Mode switching: if the header-inserted selector exists, wire it to show/hide
            try {
                const modeSel = body && body.__modeSel ? body.__modeSel : null;
                const lkControls = body && body.__lkControls ? body.__lkControls : null;
                const lkTopInput = body && body.__lkTopInput ? body.__lkTopInput : null;
                const lkSetSel = body && body.__lkSetSel ? body.__lkSetSel : null;
                if (modeSel) {
                    const switchToTruy = () => {
                        controls.style.display = '';
                        if (lkControls) lkControls.style.display = 'none';
                        // clear any lienket output
                        try { wrap.innerHTML = ''; } catch (e) { }
                        groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null;
                        // re-run group to show Truy x UI
                        try { group(); } catch (e) { }
                    };
                    const switchToLienKet = () => {
                        controls.style.display = 'none';
                        if (lkControls) lkControls.style.display = 'flex';
                        // clear existing Truy x tables and caches
                        try { wrap.innerHTML = ''; } catch (e) { }
                        groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null;
                        // immediately compute lien ket using retained input values
                        try { if (typeof computeLienKet === 'function') computeLienKet(); } catch (e) { /* ignore */ }
                    };
                    modeSel.addEventListener('change', (ev) => {
                        const v = String(modeSel.value || 'truy');
                        if (v === 'lienket') switchToLienKet(); else switchToTruy();
                    });

                    // compute function for Liên kết x: take top-N combos of chosen bộ, aggregate number frequencies
                    function computeLienKet() {
                        if (!rows || !rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                        const topN = Math.max(1, parseInt(String(lkTopInput.value || '').trim(), 10) || 30);
                        const comb = Math.max(1, parseInt(String(lkSetSel.value || '2'), 10) || 2);
                        const groups = new Map();
                        rows.forEach((r, rowIndex) => {
                            const nums = r.nums;
                            // generate combos of size `comb` (order-insensitive)
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, comb);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        });
                        let arr = [...groups.entries()].map(([key, set]) => [key, [...set]]);
                        // attach recency (most recent rowIndex) to stabilize ties
                        const arrWithRecency = arr.map(([key, idxs]) => [key, idxs, Math.max(...idxs)]);
                        // sort by occurrence count desc, then lexical key (stable)
                        arrWithRecency.sort((A, B) => {
                            const cntDiff = B[1].length - A[1].length;
                            if (cntDiff !== 0) return cntDiff;
                            return compareKey(A[0], B[0]);
                        });
                        const topEntries = arrWithRecency.slice(0, Math.max(0, Math.min(arrWithRecency.length, topN))).map(a => [a[0], a[1]]);
                        // aggregate number frequencies across the selected top entries
                        const freq = Object.create(null);
                        topEntries.forEach(([key]) => {
                            key.split('-').map(Number).forEach(n => { freq[n] = (freq[n] || 0) + 1; });
                        });
                        // Also prepare a human-readable compact listing of chosen top combos (no rows)
                        const topList = topEntries.map(([key, idxs]) => ({ key, count: idxs.length }));
                        // invert: count -> [numbers]
                        const inv = Object.create(null);
                        Object.keys(freq).forEach(k => {
                            const c = freq[k];
                            if (!inv[c]) inv[c] = [];
                            inv[c].push(Number(k));
                        });
                        const counts = Object.keys(inv).map(Number).sort((a, b) => b - a);
                        // build output grouped by occurrence count
                        let out = `<div style='margin-top:8px;'><div class='card'><div class='card-body'>`;
                        if (topEntries.length === 0) out += `<div class='muted'>Không tìm thấy bộ nào</div>`;
                        // show selected top combos compactly (key (count)), arranged N-per-line to reduce vertical space
                        out += `<div style='margin-bottom:8px;font-weight:700'>Top ${topN} bộ (key · số kỳ) — danh sách đã chọn:</div>`;
                        const perLine = 5;
                        for (let i = 0; i < topList.length; i += perLine) {
                            const slice = topList.slice(i, i + perLine).map(t => `<div class="lk-item">{<strong>${t.key.replace(/-/g, ', ')}</strong>} (${t.count})</div>`);
                            out += `<div class="lk-row" style="display:grid;grid-template-columns:repeat(${perLine},1fr);gap:8px;font-family:monospace;margin-left:6px;text-align:left">${slice.join('')}</div>`;
                        }
                        // compute numbers 1..45 that did not appear in the selected top combos
                        const allNums = Array.from({ length: 45 }, (_, i) => i + 1);
                        const present = new Set(Object.keys(freq).map(Number));
                        const missing = allNums.filter(n => !present.has(n));
                        if (missing.length > 0) {
                            const missingHtml = missing.map(n => `<strong style="color:#ff1744">${n}</strong>`).join(', ');
                            out += `<div style='margin-bottom:8px;font-weight:700'>không có ${missing.length} số: ${missingHtml}</div>`;
                        } else {
                            out += `<div style='margin-bottom:8px;font-weight:700' class='muted'>Tất cả số đều xuất hiện</div>`;
                        }
                        out += `<hr style='margin:8px 0'/>`;
                        counts.forEach(c => {
                            const nums = (inv[c] || []).sort((a, b) => a - b);
                            const numsHtml = nums.map(n => `<strong style="color:var(--accent)">${n}</strong>`).join(', ');
                            // add a per-row ⏭ button (data-nums contains comma-separated numbers)
                            out += `<div class='lk-count-row' data-nums='${nums.join(',')}' style='margin-bottom:6px;'>` +
                                `<span class='lk-count-text'>${numsHtml}: Xuất hiện ${c} lần.</span>` +
                                `<button type='button' class='lienket-prev-btn' data-nums='${nums.join(',')}'>⏮</button>` +
                                `<button type='button' class='lienket-next-btn' data-nums='${nums.join(',')}'>⏭</button>` +
                                `</div>`;
                        });
                        out += `</div></div></div>`;
                        wrap.innerHTML = out;
                        // Post-render: wire up per-row buttons to cycle-highlight numbers inside the Top list
                        try {
                            const strongs = Array.from(wrap.querySelectorAll('.lk-item strong'));
                            // store original text so we can restore later
                            strongs.forEach(s => { try { s.dataset.orig = s.textContent; } catch (e) { s.dataset.orig = s.innerText || ''; } });

                            // Wire up per-button handlers so each button cycles independently (restore original next behavior)
                            const nextButtons = Array.from(wrap.querySelectorAll('.lienket-next-btn'));
                            const prevButtons = Array.from(wrap.querySelectorAll('.lienket-prev-btn'));

                            nextButtons.forEach(btn => {
                                // use a shared index on the parent row so prev/next stay in sync
                                const row = btn.closest('.lk-count-row');
                                if (row && typeof row._idx === 'undefined') row._idx = -1;
                                btn.addEventListener('click', (e) => {
                                    try { e.preventDefault(); } catch (er) { }
                                    e.stopPropagation();
                                    const numsArr = String(btn.dataset.nums || '').split(',').map(s => s.trim()).filter(s => s !== '');
                                    if (!numsArr.length) return;
                                    const scrollTop = window.scrollY || document.documentElement.scrollTop || (document.scrollingElement && document.scrollingElement.scrollTop) || 0;
                                    const scrollLeft = window.scrollX || document.documentElement.scrollLeft || (document.scrollingElement && document.scrollingElement.scrollLeft) || 0;
                                    const prevActive = document.activeElement;

                                    // advance the shared row index
                                    if (row) row._idx = (Number(row._idx) + 1) % numsArr.length;
                                    const curr = row ? numsArr[row._idx] : numsArr[(0 + 1) % numsArr.length];

                                    strongs.forEach(s => { s.innerHTML = s.dataset.orig; });
                                    strongs.forEach(s => {
                                        const arr = String(s.dataset.orig || '').split(/\s*,\s*/);
                                        if (arr.includes(String(curr))) {
                                            s.innerHTML = arr.map(p => p === String(curr)
                                                ? `<span class='lienket-highlight' style='background:yellow;color:#000;padding:0 2px;border-radius:3px'>${p}</span>`
                                                : p
                                            ).join(', ');
                                        }
                                    });

                                    setTimeout(() => {
                                        try { window.scrollTo({ top: scrollTop, left: scrollLeft, behavior: 'auto' }); } catch (er) {
                                            try { if (document.scrollingElement) document.scrollingElement.scrollTop = scrollTop; } catch (e) { }
                                        }
                                        try { if (prevActive && typeof prevActive.focus === 'function') prevActive.focus(); } catch (e) { }
                                    }, 8);
                                });
                            });

                            prevButtons.forEach(btn => {
                                // use the same shared row index used by nextButtons
                                const row = btn.closest('.lk-count-row');
                                if (row && typeof row._idx === 'undefined') row._idx = 0;
                                btn.addEventListener('click', (e) => {
                                    try { e.preventDefault(); } catch (er) { }
                                    e.stopPropagation();
                                    const numsArr = String(btn.dataset.nums || '').split(',').map(s => s.trim()).filter(s => s !== '');
                                    if (!numsArr.length) return;
                                    const scrollTop = window.scrollY || document.documentElement.scrollTop || (document.scrollingElement && document.scrollingElement.scrollTop) || 0;
                                    const scrollLeft = window.scrollX || document.documentElement.scrollLeft || (document.scrollingElement && document.scrollingElement.scrollLeft) || 0;
                                    const prevActive = document.activeElement;

                                    // move the shared row index backward
                                    if (row) row._idx = (Number(row._idx) - 1 + numsArr.length) % numsArr.length;
                                    const curr = row ? numsArr[row._idx] : numsArr[(0 - 1 + numsArr.length) % numsArr.length];

                                    strongs.forEach(s => { s.innerHTML = s.dataset.orig; });
                                    strongs.forEach(s => {
                                        const arr = String(s.dataset.orig || '').split(/\s*,\s*/);
                                        if (arr.includes(String(curr))) {
                                            s.innerHTML = arr.map(p => p === String(curr)
                                                ? `<span class='lienket-highlight' style='background:yellow;color:#000;padding:0 2px;border-radius:3px'>${p}</span>`
                                                : p
                                            ).join(', ');
                                        }
                                    });

                                    setTimeout(() => {
                                        try { window.scrollTo({ top: scrollTop, left: scrollLeft, behavior: 'auto' }); } catch (er) {
                                            try { if (document.scrollingElement) document.scrollingElement.scrollTop = scrollTop; } catch (e) { }
                                        }
                                        try { if (prevActive && typeof prevActive.focus === 'function') prevActive.focus(); } catch (e) { }
                                    }, 8);
                                });
                            });
                        } catch (err) { /* ignore wiring errors */ }
                    }

                    // Auto-run compute on input/change with light debounce
                    const debouncedCompute = (typeof createDebounce === 'function') ? createDebounce(computeLienKet, 200) : computeLienKet;
                    if (lkTopInput) lkTopInput.addEventListener('input', debouncedCompute);
                    if (lkSetSel) lkSetSel.addEventListener('change', debouncedCompute);
                }
            } catch (e) { /* ignore */ }

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }

                // include extra combo inputs values in cache key so changing them invalidates cache
                const extraValsKey = (() => {
                    const inputs = comboExtras.querySelectorAll('input[type="number"].combo-extra');
                    return Array.from(inputs).map(i => (i.value ?? '').trim()).join(',');
                })();
                // Prefer Cell6.6's trash selector when present so the two cells stay in sync.
                let externalTrashEl = null;
                try { externalTrashEl = document.getElementById('cell6_6_trashSel'); } catch (e) { externalTrashEl = null; }
                const trashValue = (externalTrashEl && externalTrashEl.value) ? externalTrashEl.value : (trashSel && trashSel.value ? String(trashSel.value) : 'include');
                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${xFilter.value}|${extraValsKey}|${trashValue}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return;
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>Đang xử lý (trên background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    // record original occurrence counts per key (before any UI-level excludes)
                    try {
                        const m = new Map();
                        arr.forEach(([k, list]) => { m.set(k, list.length); });
                        baselineCountsMap = m;
                    } catch (e) { baselineCountsMap = null; }

                    // capture global baseline (before applying main x filter) and sort it
                    baselineArrGlobal = arr.slice();
                    const baselineSort = sortSel.value;
                    if (baselineSort === "value_asc") baselineArrGlobal.sort((a, b) => compareKey(a[0], b[0]));
                    else if (baselineSort === "value_desc") baselineArrGlobal.sort((a, b) => compareKey(b[0], a[0]));
                    else if (baselineSort === "count_asc") baselineArrGlobal.sort((a, b) => a[1].length - b[1].length);
                    else baselineArrGlobal.sort((a, b) => b[1].length - a[1].length);

                    try { baselineGlobalKeys = baselineArrGlobal.map(([k]) => k); } catch (e) { baselineGlobalKeys = null; }

                    // apply main x filter first (if provided) so baseline is the set of combos containing x
                    const mainX = parseInt(xFilter.value, 10);
                    if (!Number.isNaN(mainX)) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            return nums.includes(mainX);
                        });
                    }

                    // capture baseline (after main x filter, before dynamic extras)
                    baselineArrAll = arr.slice();
                    try { baselineAllKeys = baselineArrAll.map(([k]) => k); } catch (e) { baselineAllKeys = null; }
                    // sort baselineArrAll the same way so rank/sum are stable for filtered view
                    if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                    else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                    else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                    else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                    // now apply dynamic extra filters (extras besides mainX)
                    const extras = [];
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                        const v = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isNaN(v)) extras.push(v);
                    });
                    if (extras.length > 0) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            for (const f of extras) if (!nums.includes(f)) return false;
                            return true;
                        });
                    }

                    // If trash exclude mode is active, filter rows inside each group
                    // but keep the group entry (so ordering can be based on visible counts)
                    try {
                        let trashedSet = null;
                        if (String(trashValue) === 'exclude') {
                            const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                            trashedSet = new Set((trashed || []).map(n => Number(n)));
                        }
                        if (trashedSet && trashedSet.size) {
                            arr = arr.map(([key, list]) => {
                                const filtered = (list || []).filter(r => {
                                    try {
                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                        return true;
                                    } catch (err) { return true; }
                                });
                                return [key, filtered];
                            });
                        }
                    } catch (e) { /* ignore */ }

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        let arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);
                        // record original counts (before UI-level excludes)
                        try {
                            const m = new Map();
                            arr.forEach(([k, list]) => { m.set(k, (list && list.length) ? list.length : 0); });
                            baselineCountsMap = m;
                        } catch (e) { baselineCountsMap = null; }

                        // capture global baseline (before applying main x filter) and sort it
                        baselineArrGlobal = arr.slice();
                        const baselineSortW = sortSel.value;
                        if (baselineSortW === "value_asc") baselineArrGlobal.sort((a, b) => compareKey(a[0], b[0]));
                        else if (baselineSortW === "value_desc") baselineArrGlobal.sort((a, b) => compareKey(b[0], a[0]));
                        else if (baselineSortW === "count_asc") baselineArrGlobal.sort((a, b) => a[1].length - b[1].length);
                        else baselineArrGlobal.sort((a, b) => b[1].length - a[1].length);

                        try { baselineGlobalKeys = baselineArrGlobal.map(([k]) => k); } catch (e) { baselineGlobalKeys = null; }

                        // apply main x filter so baseline reflects combos that include x
                        const mainXw = parseInt(xFilter.value, 10);
                        if (!Number.isNaN(mainXw)) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                return nums.includes(mainXw);
                            });
                        }

                        // capture baseline before applying dynamic extras (filtered by mainX)
                        baselineArrAll = arr.slice();
                        try { baselineAllKeys = baselineArrAll.map(([k]) => k); } catch (e) { baselineAllKeys = null; }
                        if (baselineSortW === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                        else if (baselineSortW === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                        else if (baselineSortW === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                        else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                        // now apply dynamic extras (excluding mainX)
                        const extrasW = [];
                        comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                            const v = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isNaN(v)) extrasW.push(v);
                        });
                        if (extrasW.length > 0) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                for (const f of extrasW) if (!nums.includes(f)) return false;
                                return true;
                            });
                        }

                        // Apply trash exclude if active (mirror Cell5.5 behavior)
                        try {
                            let trashedSetW = null;
                            if (String(trashValue) === 'exclude') {
                                const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                                trashedSetW = new Set((trashed || []).map(n => Number(n)));
                            }
                            if (trashedSetW && trashedSetW.size) {
                                arr = arr.map(([key, list]) => {
                                    const filtered = (list || []).filter(r => {
                                        try {
                                            if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                            for (const nn of r.nums) if (trashedSetW.has(Number(nn))) return false;
                                            return true;
                                        } catch (err) { return true; }
                                    });
                                    return [key, filtered];
                                });
                            }
                        } catch (e) { /* ignore */ }

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                // Use baselineArrAll (unfiltered) for totals/rank while grid shows filtered arr
                const baselineTotal = (typeof baselineArrAll !== 'undefined' && baselineArrAll && Array.isArray(baselineArrAll)) ? baselineArrAll.length : arr.length;
                // build a readable filter text from xFilter + extras
                const fs = [];
                const mx = parseInt(xFilter.value, 10);
                if (!Number.isNaN(mx)) fs.push(String(mx));
                comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                    const v = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isNaN(v)) fs.push(String(v));
                });
                const filterText = fs.length ? ` — lọc theo Số x: {<span class="label-chip highlight">${fs.join(',')}</span>}` : ' — lọc theo Số x';

                // determine baseline rank/occ for the first displayed group
                let rankText = '';
                if (arr.length > 0 && baselineArrAll && baselineArrAll.length > 0) {
                    const firstKey = arr[0][0];
                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === firstKey);
                    if (idxInBaseline >= 0) {
                        const occ = baselineArrAll[idxInBaseline][1].length;
                        rankText = ` — vị trí ${idxInBaseline + 1}/${baselineArrAll.length} (\u00A0${occ} kỳ)`;
                    }
                }

                // BEFORE rendering, ensure groups are ordered by visible counts
                try {
                    // Determine effective trash mode and trashed set
                    let trashModeEl = null;
                    try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                    if (!trashModeEl) { try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; } }
                    const trashMode = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';
                    let trashedSet = null;
                    if (String(trashMode) === 'exclude') {
                        const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                        trashedSet = new Set((trashed || []).map(n => Number(n)));
                    }

                    if (trashedSet && trashedSet.size && Array.isArray(arr)) {
                        // build a temporary array of { key, origList, visibleList }
                        const tmp = arr.map(([key, list]) => {
                            const visible = (list || []).filter(r => {
                                try {
                                    if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                    for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                    return true;
                                } catch (err) { return true; }
                            });
                            return { key, orig: list, visible };
                        });
                        // sort tmp according to current sortSel but using visible.length for count sorts
                        const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                        tmp.sort((A, B) => {
                            if (currentSort === 'value_asc') return compareKey(A.key, B.key);
                            if (currentSort === 'value_desc') return compareKey(B.key, A.key);
                            if (currentSort === 'count_asc') return (A.visible ? A.visible.length : 0) - (B.visible ? B.visible.length : 0);
                            return (B.visible ? B.visible.length : 0) - (A.visible ? A.visible.length : 0);
                        });
                        // replace arr with visible lists in sorted order
                        arr = tmp.map(t => [t.key, t.visible]);
                    }
                } catch (e) { /* ignore ordering errors */ }

                wrap.innerHTML = `<div class='muted header-summary' style='flex-basis:100%;margin-bottom:8px'>${baselineTotal} nhóm (>=2 kỳ)${filterText}${rankText}</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');
                const headerEl = wrap.querySelector('.header-summary');
                // number of rows per page used by each group's table
                const pageSizeRows = 15;
                const updateHeaderCount = () => {
                    try {
                        // Count one table per group (even if a group's table would paginate)
                        const totalTables = Array.isArray(arr) ? arr.length : 0;
                        // Simplified display: only show group count, filter and total tables
                        // Show current displayed table count and also indicate full baseline total
                        headerEl.innerHTML = `${baselineTotal} nhóm (>=2 kỳ)${filterText} — Số bảng (hiện tại): <span class="euclid-total-pill">${totalTables}</span>`;
                    } catch (e) { /* ignore */ }
                };

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160;
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    // build a display list that respects recency selection; default is 'asc' (old->new)
                    let displayList = (list && list.slice) ? list.slice() : [];
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }

                    // SAFETY FILTER: remove any rows that contain trashed numbers when trash mode is 'exclude'
                    try {
                        // Determine effective trash mode (prefer cell6_6 selector when present)
                        let trashModeEl = null;
                        try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                        if (!trashModeEl) {
                            try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                        }
                        const trashMode = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';
                        if (String(trashMode) === 'exclude') {
                            const trashedArr = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                            const trashedSet = new Set((trashedArr || []).map(n => Number(n)));
                            if (trashedSet.size) {
                                displayList = displayList.filter(r => {
                                    try {
                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                        return true;
                                    } catch (err) { return true; }
                                });
                            }
                        }
                    } catch (e) { /* ignore safety-filter errors */ }

                    const totalPages = Math.max(1, Math.ceil(displayList.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        // Build per-card header (rendered inside mounted body) to mirror Cell6.6
                        const visibleCount = (displayList && Array.isArray(displayList)) ? displayList.length : 0;
                        let baselineCount = visibleCount;
                        try {
                            if (baselineCountsMap && typeof baselineCountsMap.get === 'function') {
                                const c = baselineCountsMap.get(key);
                                if (Number.isFinite(c)) baselineCount = c;
                            }
                        } catch (e) { baselineCount = visibleCount; }
                        // If trash 'exclude' is active, show only visible count (user requested)
                        let occDisplay;
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) === 'exclude') occDisplay = `${visibleCount} kỳ`;
                            else occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`;
                        } catch (e) { occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`; }
                        // compute within-x and global ranks when available
                        let rankDisplay = `${idx + 1}/${arr.length}`;
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) !== 'exclude') {
                                if (baselineAllKeys && Array.isArray(baselineAllKeys)) {
                                    const idxInBaseline = baselineAllKeys.indexOf(key);
                                    if (idxInBaseline >= 0) rankDisplay = `${idxInBaseline + 1}/${baselineAllKeys.length}`;
                                }
                            }
                        } catch (e) { }
                        let globalRankDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (baselineGlobalKeys && Array.isArray(baselineGlobalKeys)) {
                                let keysArr = baselineGlobalKeys.slice();
                                if (String(tMode) === 'exclude') {
                                    const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                                    if (trashed && trashed.length && Array.isArray(trashed)) {
                                        const trashedSet = new Set((trashed || []).map(v => Number(v)));
                                        keysArr = keysArr.filter(k => {
                                            const parts = String(k).split('-').map(p => Number(p));
                                            for (const p of parts) if (trashedSet.has(p)) return false;
                                            return true;
                                        });

                                        // compute visible counts safely from baselineArrGlobal
                                        const visibleMap = new Map();
                                        try {
                                            if (Array.isArray(baselineArrGlobal)) {
                                                baselineArrGlobal.forEach(([k, list]) => {
                                                    if (!k || !Array.isArray(list)) { visibleMap.set(k, 0); return; }
                                                    let c = 0;
                                                    for (const r of list) {
                                                        if (!r || !r.nums || !Array.isArray(r.nums)) continue;
                                                        let ok = true;
                                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) { ok = false; break; }
                                                        if (ok) c++;
                                                    }
                                                    visibleMap.set(k, c);
                                                });
                                            }
                                        } catch (e) { }

                                        const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                                        keysArr.sort((a, b) => {
                                            if (currentSort === 'value_asc') return compareKey(a, b);
                                            if (currentSort === 'value_desc') return compareKey(b, a);
                                            const va = visibleMap.has(a) ? visibleMap.get(a) : 0;
                                            const vb = visibleMap.has(b) ? visibleMap.get(b) : 0;
                                            if (currentSort === 'count_asc') return va - vb;
                                            return vb - va;
                                        });
                                    }
                                }
                                const idxInGlobal = keysArr.indexOf(key);
                                if (idxInGlobal >= 0) globalRankDisplay = `${idxInGlobal + 1}/${keysArr.length}`;
                            }
                        } catch (e) { }
                        let leftRankHtml = '';
                        if (globalRankDisplay && baselineArrAll && baselineArrGlobal && baselineArrGlobal.length !== baselineArrAll.length) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                                `<span class='muted' title='Toàn bộ' style='font-weight:800;margin-left:6px'>${globalRankDisplay}</span>`;
                        } else if (globalRankDisplay) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${globalRankDisplay}</span>`;
                        } else {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>`;
                        }

                        const headerHtml = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `${leftRankHtml}` +
                            `<span class='badge'>${occDisplay}</span>` +
                            `</div>` +
                            `</div>`;

                        const navHtml = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        inner = headerHtml + navHtml;
                        inner += `<table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        // If there are rows to render, compute per-row `k` using the same
                        // greedy trash-popup semantics so we can annotate each <tr>
                        if (slice.length === 0) {
                            inner += `<tr><td colspan='4' class='muted'>Không có kết quả</td></tr>`;
                        } else {
                            // Build mapping from stable row key -> global indices
                            const rowKeyToIndices = new Map();
                            try {
                                rows.forEach((rr, gi) => {
                                    try {
                                        const rk = (rr.nums && Array.isArray(rr.nums) ? rr.nums.join(',') : '') + '|' + (rr.date || '');
                                        if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                                        rowKeyToIndices.get(rk).push(gi);
                                    } catch (err) { }
                                });
                            } catch (err) { }

                            // Determine pool (use numberPickerTable order if available)
                            let pool = [];
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                if (npTable) {
                                    const tds = Array.from(npTable.querySelectorAll('td[data-number]'));
                                    pool = tds.map(td => Number(td.dataset.number)).filter(n => Number.isFinite(n));
                                }
                            } catch (e) { }
                            if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);

                            // Greedy simulation: compute first-k when each global row becomes excluded
                            const rowFirstExcludedAt = new Array(rows.length).fill(null);
                            const chosen = new Set();
                            const maxK = pool.length;
                            for (let kIdx = 1; kIdx <= maxK; kIdx++) {
                                let best = null; let bestNew = Infinity;
                                for (const cand of pool) {
                                    if (chosen.has(cand)) continue;
                                    let newExcl = 0;
                                    for (let gi = 0; gi < rows.length; gi++) {
                                        if (rowFirstExcludedAt[gi] !== null) continue;
                                        const rr = rows[gi];
                                        if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                        for (const nn of rr.nums) { if (Number(nn) === cand) { newExcl++; break; } }
                                    }
                                    if (newExcl < bestNew) { bestNew = newExcl; best = cand; }
                                }
                                if (best === null) break;
                                for (let gi = 0; gi < rows.length; gi++) {
                                    if (rowFirstExcludedAt[gi] !== null) continue;
                                    const rr = rows[gi];
                                    if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                    for (const nn of rr.nums) { if (Number(nn) === best) { rowFirstExcludedAt[gi] = kIdx; break; } }
                                }
                                chosen.add(best);
                            }

                            // Emit rows with computed t (largest k for which row remains visible)
                            slice.forEach(r => {
                                const orderedSeq = key.split('-').map(Number);
                                const requireOrder = !!(consec.checked && order && order.checked);
                                const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                                const labelHtml = renderHighlightedLabel(r.label, positions);
                                let euclidPartsHtml = [];
                                let euclidTotal = 0;
                                try {
                                    const npTable = document.getElementById('numberPickerTable');
                                    const tbody = npTable ? npTable.querySelector('tbody') : null;
                                    const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                    for (let j = 0; j < 5; j++) {
                                        const n1 = r.nums[j];
                                        const n2 = r.nums[j + 1];
                                        let part = '';
                                        if (npTable && tbodyRows.length > 0) {
                                            const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                            const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                            if (cell1 && cell2) {
                                                const rowElem1 = cell1.parentElement;
                                                const rowElem2 = cell2.parentElement;
                                                const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                                const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                                const logicalRow1 = 7 - rowIdx1;
                                                const logicalRow2 = 7 - rowIdx2;
                                                const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                                const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                                const dx = colIdx2 - colIdx1;
                                                const dy = logicalRow2 - logicalRow1;
                                                const d = Math.sqrt(dx * dx + dy * dy);
                                                part = isFinite(d) ? d.toFixed(2) : '';
                                                euclidTotal += isFinite(d) ? d : 0;
                                            }
                                        }
                                        if (part) euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                        else euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                } catch (e) {
                                    for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                                const totalStr = euclidTotal.toFixed(2);
                                const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;

                                let t = pool.length;
                                try {
                                    const rk = (r.nums && Array.isArray(r.nums) ? r.nums.join(',') : '') + '|' + (r.date || '');
                                    const gids = rowKeyToIndices.get(rk) || [];
                                    const gi = (gids && gids.length) ? gids[0] : null;
                                    if (gi !== null && rowFirstExcludedAt[gi] !== null) t = Math.max(0, rowFirstExcludedAt[gi] - 1);
                                } catch (err) { }

                                inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${t}" data-k="${t}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                            });
                        }
                        if (displayList.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${displayList.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell6_5_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                // remove braces and split on non-digits
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    // remember current highlights so regenerating the popup can reapply
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        // store the card element that produced these highlights so
                                        // we can clear them when the user hovers a different record
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights even when the mouse leaves the tbody.
                                // No-op.
                                return;
                            });

                            // Ctrl+click a row: switch to cell6_6, paste its 6 numbers, and mark row with yellow border
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    // parse numbers (use existing helper)
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    // clear any previous ctrl-selected rows globally and mark this one
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    // persist selection so it survives remounts/navigation
                                    try { localStorage.setItem('cell6_5_ctrl_selected', result); } catch (e) { }

                                    // Ensure target section is rendered then navigate to it after a short delay
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            // apply numbers after nav; give a small delay to allow render
                                            setTimeout(() => {
                                                try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { }
                                            }, 220);
                                        }, 200);
                                    } else {
                                        // fallback: apply even if nav button missing
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { /* ignore */ }
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    try { updateHeaderCount(); } catch (e) { }
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    try { updateHeaderCount(); } catch (e) { }
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // Prefer baseline (pre-trash) values for rank/occurrence when available
                        let rankDisplay = `${i + 1}/${totalGroups}`;
                        // visibleCount = number of rows currently displayed for this group (after trash filter)
                        const visibleCount = (list && list.length) ? list.length : 0;
                        let baselineCount = visibleCount;
                        try {
                            if (baselineCountsMap && typeof baselineCountsMap.get === 'function') {
                                const c = baselineCountsMap.get(key);
                                if (Number.isFinite(c)) baselineCount = c;
                            }
                        } catch (e) { baselineCount = visibleCount; }
                        // show as visible/baseline when they differ, otherwise single number
                        let occDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) === 'exclude') occDisplay = `${visibleCount} kỳ`;
                            else occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`;
                        } catch (e) { occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`; }
                        try {
                            // within-x rank: use baselineAllKeys (captured before trash exclude)
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) !== 'exclude') {
                                if (baselineAllKeys && Array.isArray(baselineAllKeys)) {
                                    const idxInBaseline = baselineAllKeys.indexOf(key);
                                    if (idxInBaseline >= 0) rankDisplay = `${idxInBaseline + 1}/${baselineAllKeys.length}`;
                                }
                            }
                        } catch (e) { }

                        // Compute global rank (before main-x filter) if available using baselineGlobalKeys
                        let globalRankDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (baselineGlobalKeys && Array.isArray(baselineGlobalKeys)) {
                                let keysArr = baselineGlobalKeys;
                                if (String(tMode) === 'exclude') {
                                    const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                                    if (trashed && trashed.length && Array.isArray(trashed)) {
                                        const trashedSet = new Set(trashed.map(v => String(Number(v))));
                                        keysArr = baselineGlobalKeys.filter(k => {
                                            const parts = String(k).split('-').map(p => String(Number(p)));
                                            for (const p of parts) if (trashedSet.has(p)) return false;
                                            return true;
                                        });
                                    }
                                }
                                const idxInGlobal = keysArr.indexOf(key);
                                if (idxInGlobal >= 0) globalRankDisplay = `${idxInGlobal + 1}/${keysArr.length}`;
                            }
                        } catch (e) { }

                        // Decide what to show: if global differs from filtered, show both (filtered then global).
                        // Otherwise show just the global (or filtered fallback).
                        let leftRankHtml = '';
                        if (globalRankDisplay && baselineArrAll && baselineArrGlobal && baselineArrGlobal.length !== baselineArrAll.length) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                                `<span class='muted' title='Toàn bộ' style='font-weight:800;margin-left:6px'>${globalRankDisplay}</span>`;
                        } else if (globalRankDisplay) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${globalRankDisplay}</span>`;
                        } else {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>`;
                        }

                        // Create an empty card body; header will be rendered inside mount
                        card.innerHTML = `<div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    // refresh header count after building a new chunk
                    try { updateHeaderCount(); } catch (e) { }
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                // After chunked creation completes, scroll viewport to 240px so
                // the `.controls` area and new results are visible. Use a small
                // timeout + rAF to wait for layout/paint to settle.
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try {
                            window.scrollTo({ top: 240, behavior: 'auto' });
                        } catch (e) {
                            try { document.scrollingElement.scrollTop = 240; } catch (err) { }
                        }
                    });
                }, 160);

            }

            const debouncedGroup = createDebounce(group, 300);
            // expose the current debouncedGroup on the section so external listeners
            // can call the latest function even if this renderer re-runs
            try {
                const sec = document.getElementById('cell6_5');
                if (sec) {
                    sec.__group = debouncedGroup;
                    // provide an invalidate helper so external listeners can clear
                    // internal caches and force a fresh compute/render
                    sec.__invalidate = function () {
                        try { groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null; isComputing = false; } catch (e) { }
                        try { if (wrap) wrap.innerHTML = ''; } catch (e) { }
                    };
                }
            } catch (e) { }
            // Add a local listener on the section to respond to popup trash changes.
            // Using a section-scoped listener avoids depending solely on a global lookup
            // and ensures the current renderer instance handles updates reliably.
            try {
                if (body && !body.__trash_listener_added) {
                    body.addEventListener('trashchange', () => {
                        try {
                            try { console.debug('cell6_5: section-local trashchange received'); } catch (e) { }
                            // Invalidate renderer state then trigger recompute like other inputs
                            try { const sec = document.getElementById('cell6_5'); if (sec && typeof sec.__invalidate === 'function') sec.__invalidate(); } catch (e) { }
                            if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                        } catch (err) { /* ignore */ }
                    });
                    body.__trash_listener_added = true;
                }
            } catch (e) { /* ignore */ }
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; debouncedGroup(); };
            xSel.onchange = sortSel.onchange = order.onchange = recencySel.onchange = trashSel.onchange = debouncedGroup;
            xFilter.onchange = debouncedGroup;
            if (recencySel) recencySel.onchange = debouncedGroup;
            // Register a single global listener to respond to popup trash changes.
            // It looks up the current selector (`cell6_5_trashSel`) and calls the
            // section's `__group` function so the call targets the latest instance.
            try {
                if (!window.__cell6_5_trash_watch) {
                    document.addEventListener('trashchange', () => {
                        try {
                            try { console.debug('cell6_5: global trashchange received'); } catch (e) { }
                            const sec = document.getElementById('cell6_5');
                            if (sec && typeof sec.__invalidate === 'function') {
                                try { sec.__invalidate(); } catch (e) { }
                            }
                            // Recompute visible rows per group based on current trash mode
                            try {
                                // determine effective trash mode (prefer cell6_6 selector)
                                let trashModeEl = null;
                                try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                                if (!trashModeEl) {
                                    try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                                }
                                const trashValue = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';

                                if (groupCache && Array.isArray(groupCache)) {
                                    if (String(trashValue) === 'exclude') {
                                        const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                                        const trashedSet = new Set((trashed || []).map(n => Number(n)));
                                        if (trashedSet.size) {
                                            groupCache = groupCache.map(([key, list]) => {
                                                const filtered = (list || []).filter(r => {
                                                    try {
                                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                                        return true;
                                                    } catch (err) { return true; }
                                                });
                                                return [key, filtered];
                                            });
                                        }
                                    } else {
                                        // include mode: restore visible lists from baseline (if available)
                                        if (baselineArrAll && Array.isArray(baselineArrAll)) {
                                            try { groupCache = baselineArrAll.map(([k, l]) => [k, (l && l.slice) ? l.slice() : []]); } catch (e) { /* ignore */ }
                                        }
                                    }
                                }
                                // Ensure groups are re-ordered according to current sort selection
                                try {
                                    const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                                    if (groupCache && Array.isArray(groupCache)) {
                                        if (currentSort === 'value_asc') groupCache.sort((a, b) => compareKey(a[0], b[0]));
                                        else if (currentSort === 'value_desc') groupCache.sort((a, b) => compareKey(b[0], a[0]));
                                        else if (currentSort === 'count_asc') groupCache.sort((a, b) => (a[1] ? a[1].length : 0) - (b[1] ? b[1].length : 0));
                                        else groupCache.sort((a, b) => (b[1] ? b[1].length : 0) - (a[1] ? a[1].length : 0));
                                    }
                                } catch (e) { /* ignore sort errors */ }
                            } catch (e) { /* ignore recompute errors */ }

                            // Force a fresh render by clearing cacheKey so group() will
                            // re-evaluate sorting and pagination using current controls.
                            try { cacheKey = null; isComputing = false; } catch (e) { }
                            const fn = sec && sec.__group ? sec.__group : null;
                            if (typeof fn === 'function') fn();
                        } catch (e) { /* ignore */ }
                    });
                    window.__cell6_5_trash_watch = true;
                }
            } catch (e) { /* ignore */ }

            group();
        }

        // Cell7: reverse query by label pattern (6 chars, _ wildcard)
        function renderCell7() {
            const body = sectionShell("cell8", "Cell8 · Tìm kiếm theo Label", "Nhập 6 ký tự label (1-6 hoặc _) để tìm các kỳ có label khớp. Có thể kéo thả giữa các vị trí.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs and add small up/down arrows inside the input on the right
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                // container sized to the input; buttons will be absolutely positioned inside it
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                // small left-side grip so it doesn't cover the whole input and block typing
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // keep input as text to allow wildcard '_', but visually reserve space for buttons
                inp.type = 'text';
                inp.maxLength = 1;
                inp.placeholder = '_';
                inp.size = 1;
                inp.style.width = '70px';
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';
                inp.style.position = 'relative';
                inp.style.zIndex = '1';

                // small vertical arrow buttons inside the input, right-aligned
                const btnGroup = document.createElement('div');
                // absolutely position the buttons so they sit inside the input's right edge
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';

                // make arrows compact so they don't overflow the input border
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';

                const up = document.createElement('button');
                up.type = 'button';
                up.className = 'arrow-up';
                up.innerHTML = '▲';
                up.title = 'Tăng 1';
                up.style.cssText = arrowStyle;

                const down = document.createElement('button');
                down.type = 'button';
                down.className = 'arrow-down';
                down.innerHTML = '▼';
                down.title = 'Giảm 1';
                down.style.cssText = arrowStyle;

                // clamp helper: allow '' and '_' as wildcard, otherwise clamp to [1,6]
                const clampValue = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '' || raw === '_') return;
                    const n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: after 6 -> 1
                    n = n + 1;
                    if (n > 6) n = 1;
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: before 1 -> 6
                    n = n - 1;
                    if (n < 1) n = 6;
                    if (n > 6) n = 6;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '' && v !== '_';
                    container.draggable = hasValue;
                    // only enable pointer events on the small grip (left) so the input remains editable
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    // keep padding and border radius constant so container height doesn't jump
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    // use transparent border when empty to preserve box size, and accent border when filled
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampValue(); updateDraggable(); });
                inp.addEventListener('change', () => { clampValue(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Kéo từ bảng label C1-C6 trực tiếp từ popup
                    if (labelData) {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run();
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                        return;
                    }

                    // Swap với 1 place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                            const incomingRaw = placeVals[srcIdx];
                            const incoming = incomingRaw && popupMode === 'number' ? getCol(parseInt(incomingRaw, 10)) : incomingRaw;
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Nếu kéo cả bộ place (6 giá trị)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                                for (let i = 0; i < 6; i++) {
                                    const val = values[i];
                                    let col = '';
                                    if (val) {
                                        const numVal = parseInt(val, 10);
                                        col = popupMode === 'number' ? getCol(numVal) : numVal;
                                    }
                                    inputs[i].value = col || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                run();
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                draggedIndex = null;
                                return;
                            }
                        } catch (err) { }
                    }
                    // Kéo số trực tiếp từ popup → chuyển sang cột (chỉ nếu không phải internal drag)
                    if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                        const numVal = parseInt(draggedData, 10);
                        if (numVal >= 1 && numVal <= 45) {
                            const col = getCol(numVal);
                            inputs[idx].value = col || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Hoán đổi nội bộ
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const wrapInputs = document.createElement("div"); wrapInputs.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Label:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            wrapInputs.appendChild(labelText);
            containers.forEach(c => wrapInputs.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', run);
            body.appendChild(wrapInputs);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; wrapInputs.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            wrapInputs.appendChild(hint);
            try { wrapInputs.appendChild(recencySel); } catch (e) { }

            function run() {
                const pattern = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : "_"; }).join("");
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                if (pattern.length !== 6) { wrap.innerHTML = "<div class='error'>Cần 6 ký tự</div>"; return; }
                const records = rows.filter(r => {
                    const label = r.label;
                    for (let i = 0; i < 6; i++) if (pattern[i] !== "_" && pattern[i] !== label[i]) return false;
                    return true;
                });
                if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào khớp pattern</div>"; return; }
                let display = records.slice();
                if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < display.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ngày</th><th>Kết quả</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    display.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_"
                            ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                            : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
                        ).join(" ");
                        const labelHtml = r.label.split("").map((ch, idx) => pattern[idx] === "_" ? `<span>${ch}</span>` : `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`).join(" ");
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell8
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach delegated hover + Ctrl+click handlers so rows can be highlighted and Ctrl-clicked
                (function attachRowHoverAndCtrlClick_cell8_labelMode() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const res = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                            if (!res) return;
                            const nums = res.split(/[^0-9]+/).map(s => parseInt(s, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = tr.closest('.card') || wrap; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;

                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell8_ctrl_selected', result); } catch (e) { }

                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) {
                                    setTimeout(() => {
                                        try { navBtn.click(); } catch (e) { }
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220);
                                    }, 200);
                                } else {
                                    setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                }
                            } catch (e) { /* ignore */ }
                        });
                    } catch (err) { /* ignore */ }
                })();

                // scroll to 240px so the controls sit under header consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        // Cell8: group by same number set size x
        function renderCell8() {
            const body = sectionShell("cell6", "Cell6 · Cặp phổ biến", "Chọn kích thước bộ số (1-6), tùy chọn liền kề, sắp xếp.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `Bộ ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement("select");[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';
            controls.append("Bộ số:", xSel, consecLabel, orderLabel, "Sắp xếp:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            let isComputing = false;

            // If recency selection changes, clear caches and recompute groups
            if (recencySel) recencySel.addEventListener('change', () => {
                try { cacheKey = null; groupCache = null; } catch (e) { }
                try { group(); } catch (e) { }
            });

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }

                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return; // Tránh multiple requests
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>Đang xử lý (trên background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                // Nếu x <= 2 hoặc consec=true, tính nhanh trên main thread
                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    // Nếu x > 2 và consec=false, dùng worker
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        const arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                wrap.innerHTML = `<div class='muted'>${arr.length} nhóm (>=2 kỳ)</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160; // increase because we store per-page
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        // only drop if not currently mounted
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                // Lazy mount/unmount per-card table using viewport observation
                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(list.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        // build a display list that respects recency selection; default is 'asc' (old->new)
                        let displayList = (list && list.slice) ? list.slice() : [];
                        try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        inner += `<table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        slice.forEach(r => {
                            const orderedSeq = key.split('-').map(Number);
                            const requireOrder = !!(consec.checked && order && order.checked);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                // ignore euclid errors, leave parts empty
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            // Let CSS handle centering and fixed width; avoid left-padding with NBSPs
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `</tbody></table>`;
                        // duplicate pagination controls under the table so users can navigate from bottom
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights until another record hover updates them.
                                return;
                            });

                            // Ctrl+click a row: switch to cell6_6, paste its 6 numbers, and mark row with yellow border
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell8_ctrl_selected', result); } catch (e) { }

                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            setTimeout(() => {
                                                try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { }
                                            }, 220);
                                        }, 200);
                                    } else {
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { /* ignore */ }
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    // attach pagination handlers (attach to both top and bottom controls)
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${list.length} kỳ</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                // scroll to 240px after chunked creation (wait for layout)
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } }
                    });
                }, 160);
            }

            const debouncedGroup = createDebounce(group, 300);
            // enable/disable order checkbox depending on consec
            consec.onchange = () => {
                order.disabled = !consec.checked;
                if (!consec.checked) order.checked = false;
                debouncedGroup();
            };
            xSel.onchange = sortSel.onchange = order.onchange = debouncedGroup;
            group();
        }
        function compareKey(a, b) {
            const pa = a.split("-").map(Number); const pb = b.split("-").map(Number);
            for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; }
            return pa.length - pb.length;
        }
        function findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            if (requireConsecutive) {
                for (let i = 0; i <= nums.length - blockSize; i++) {
                    const block = nums.slice(i, i + blockSize);
                    if (block.length !== blockSize) continue;
                    if (requireOrder && Array.isArray(orderedSeq) && orderedSeq.length === blockSize) {
                        let matches = true;
                        for (let k = 0; k < blockSize; k++) {
                            if (block[k] !== orderedSeq[k]) { matches = false; break; }
                        }
                        if (matches) return Array.from({ length: blockSize }, (_, k) => i + k);
                    } else {
                        if (block.every(v => setValues.has(v)) && new Set(block).size === setValues.size) {
                            return Array.from({ length: blockSize }, (_, k) => i + k);
                        }
                    }
                }
            }
            const positions = [];
            nums.forEach((v, idx) => { if (setValues.has(v)) positions.push(idx); });
            return positions;
        }
        function renderHighlightedNums(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            const positions = findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder);
            const posSet = new Set(positions);
            const html = nums.map((v, idx) => posSet.has(idx)
                ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
            ).join(" ");
            return { html, positions };
        }
        function renderHighlightedLabel(labelStr, highlightPositions) {
            const posSet = new Set(highlightPositions);
            return labelStr.split("").map((ch, idx) => posSet.has(idx)
                ? `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`
                : `<span>${ch}</span>`
            ).join(" ");
        }

        // Helper for main thread combos (same algorithm available inside worker)
        function kCombinations(set, k) {
            const combs = [];
            const n = set.length;
            function pick(start, acc) {
                if (acc.length === k) { combs.push(acc.slice()); return; }
                for (let i = start; i < n; i++) { acc.push(set[i]); pick(i + 1, acc); acc.pop(); }
            }
            pick(0, []);
            return combs;
        }

        // Cell9: draws containing user set
        function renderCell9() {
            const body = sectionShell("cell9", "Cell9 · Tổ hợp chứa bộ số hoặc label", "Chọn tìm theo bộ số (1-45) hoặc label (1-6). Có thể kéo thả giữa các vị trí.");

            // Mode toggle integrated with Number Picker
            const getNumberPickerMode = window.getNumberPickerMode || (() => "number");
            const setNumberPickerMode = window.setNumberPickerMode || (() => { });
            const onNumberPickerModeChange = window.onNumberPickerModeChange || (() => () => { });
            let cell9ModeState = getNumberPickerMode();
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell9ModeState === 'number' ? 'Bộ số (1-45)' : 'Label (1-6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === "number") {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });
                }
            };

            let inputs = createInputs(cell9ModeState);

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                    container.draggable = false;

                    // small left-side grip so it doesn't cover the whole input and block typing
                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                    // reserve space on the right for buttons
                    inp.style.position = "relative";
                    inp.style.zIndex = "1";
                    inp.style.paddingRight = '40px';
                    inp.style.boxSizing = 'border-box';

                    // button group inside input, right-aligned
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                    // helpers per mode
                    const clampForNumberMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 45) inp.value = '45';
                        else inp.value = String(n);
                    };

                    const clampForLabelMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '' || raw === '_') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 6) inp.value = '6';
                        else inp.value = String(n);
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 45) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 6) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 45; // wrap
                            if (n > 45) n = 45;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 6; // wrap
                            if (n > 6) n = 6;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });

                    btnGroup.appendChild(up);
                    btnGroup.appendChild(down);

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const hasValue = inp.type === 'number' ? v !== '' : (v !== '' && v !== '_');
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                        dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                        container.style.borderRadius = '10px';
                        container.style.padding = '2px';
                        container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                        container.style.opacity = hasValue ? '1' : '0.85';
                    };

                    // attach input handlers depending on mode
                    inp.addEventListener('input', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    inp.addEventListener('change', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    updateDraggable();

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    return container;
                });
            };
            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;


            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    // Track drag-over state to avoid redundant style updates
                    let isDragOverThis = false;

                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        dropHandled = false;
                        container.style.opacity = "0.4";
                        container.style.cursor = "grabbing";
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        container.style.cursor = "grab";
                        // If drop didn't happen (dragged outside), delete the value
                        if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                            inputs[idx].value = "";
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                        }
                        draggedIndex = null;
                        dropHandled = false;
                        isDragOverThis = false;
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";

                        // Only update styles if not already in drag-over state
                        if (!isDragOverThis) {
                            isDragOverThis = true;
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        isDragOverThis = false;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        dropHandled = true;
                        const draggedData = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        isDragOverThis = false;

                        // Swap with a single place box
                        if (placeIndexData !== null && placeIndexData !== '') {
                            const srcIdx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                                const incoming = placeVals[srcIdx];
                                const outgoing = inputs[idx].value;
                                inputs[idx].value = incoming || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                placeVals[srcIdx] = outgoing || '';
                                if (window.setPlaceValues) window.setPlaceValues(placeVals);
                                if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                                if (run) run();
                                draggedIndex = null;
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                return;
                            }
                        }
                        // Accept place set (6 numbers)
                        if (placeSetData) {
                            try {
                                let values = JSON.parse(placeSetData);
                                if (Array.isArray(values) && values.length === 6) {
                                    // In label mode, reverse values to match reversed display
                                    if (cell9ModeState === 'label') {
                                        values = values.reverse();
                                    }
                                    for (let i = 0; i < 6; i++) {
                                        inputs[i].value = values[i] || '';
                                        inputs[i].dispatchEvent(new Event("input"));
                                    }
                                    if (run) run();
                                }
                            } catch (err) { }
                        }
                        // Kéo số/label trực tiếp từ popup (chỉ nếu không phải internal drag)
                        else if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                            const numVal = parseInt(draggedData, 10);
                            if (cell9ModeState === 'number' && numVal >= 1 && numVal <= 45) {
                                inputs[idx].value = numVal;
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            } else if (cell9ModeState === 'label') {
                                const col = getCol(numVal);
                                inputs[idx].value = col || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            }
                        }
                        // Kéo label từ header popup khi mode = label
                        else if (draggedIndex === null && labelData && cell9ModeState === 'label') {
                            inputs[idx].value = labelData.replace('C', '');
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                            draggedIndex = null;
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            return;
                        }
                        // Otherwise swap
                        else if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            if (run) run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề"));
            const controls = document.createElement("div"); controls.className = "controls";

            // Add mode toggle button
            controls.appendChild(modeBtn);

            const inputLabel = document.createElement("span"); inputLabel.textContent = cell9ModeState === "number" ? "Bộ số:" : "Label:"; inputLabel.style.fontWeight = "700"; inputLabel.style.fontSize = "14px"; inputLabel.style.marginLeft = "12px";
            controls.appendChild(inputLabel);

            // For label mode, reverse the containers for proper left-to-right display
            const containersToAdd = cell9ModeState === "label" ? [...containers].reverse() : containers;
            containersToAdd.forEach(c => controls.appendChild(c));
            controls.append(consecLabel);
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            try { controls.appendChild(recencySel); } catch (e) { }

            function run() {
                const mode = cell9ModeState;

                if (mode === "number") {
                    const vals = inputs.map(i => parseInt(i.value, 10)).filter(v => !isNaN(v) && v >= 1 && v <= 45);
                    if (!vals.length) { wrap.innerHTML = "<div class='loader'>Điền ít nhất 1 số...</div>"; return; }
                    const inputFreq = {};
                    vals.forEach(v => { inputFreq[v] = (inputFreq[v] || 0) + 1; });
                    const setVals = new Set(vals);
                    const records = rows.filter(r => {
                        const rowFreq = {};
                        r.nums.forEach(v => { rowFreq[v] = (rowFreq[v] || 0) + 1; });
                        for (const num in inputFreq) {
                            if ((rowFreq[num] || 0) < inputFreq[num]) return false;
                        }
                        if (consec.checked) return hasConsecutiveBlock(r.nums, setVals);
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào phù hợp</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setVals, setVals.size, consec.checked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell9
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell9_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = wrap.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // Attach Ctrl+click handler for cell9 (use delegation on wrap so all inner cards/tables are covered)
                    (function attachRowHoverAndCtrlClick_cell9() {
                        try {
                            wrap.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                                if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                            });

                            wrap.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell9_ctrl_selected', result); } catch (e) { }
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                    else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell8
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = wrap.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // Attach Ctrl+click handler for cell8
                    (function attachRowHoverAndCtrlClick_cell8() {
                        try {
                            const _tbody = wrap.querySelector('tbody');
                            if (!_tbody) return;
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                                if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                            });
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell8_ctrl_selected', result); } catch (e) { }
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                    else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                } else {
                    const labels = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : null; }).filter(v => v !== null);
                    if (!labels.length) { wrap.innerHTML = "<div class='loader'>Điền ít nhất 1 ký tự...</div>"; return; }
                    const inputFreq = {};
                    labels.forEach(ch => { inputFreq[ch] = (inputFreq[ch] || 0) + 1; });
                    const totalCount = labels.length;
                    const inputKeys = Object.keys(inputFreq);
                    const keySet = new Set(inputKeys);

                    const records = rows.filter(r => {
                        const labelStr = r.label;
                        const rowFreq = {};
                        for (const ch of labelStr) rowFreq[ch] = (rowFreq[ch] || 0) + 1;
                        for (const ch of inputKeys) {
                            if ((rowFreq[ch] || 0) < inputFreq[ch]) return false;
                        }
                        if (consec.checked) {
                            for (let i = 0; i <= labelStr.length - totalCount; i++) {
                                const block = labelStr.slice(i, i + totalCount);
                                const blockFreq = {};
                                for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                let ok = true;
                                for (const ch of inputKeys) {
                                    if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                }
                                if (ok) return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào phù hợp</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const labelStr = r.label;
                            let highlightPos = [];
                            if (consec.checked) {
                                let start = -1;
                                for (let s = 0; s <= labelStr.length - totalCount && start === -1; s++) {
                                    const block = labelStr.slice(s, s + totalCount);
                                    const blockFreq = {};
                                    for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                    let ok = true;
                                    for (const ch of inputKeys) {
                                        if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                    }
                                    if (ok) start = s;
                                }
                                if (start !== -1) {
                                    highlightPos = Array.from({ length: totalCount }, (_, k) => start + k);
                                }
                            }
                            if (!highlightPos.length) {
                                for (let pos = 0; pos < labelStr.length; pos++) {
                                    if (keySet.has(labelStr[pos])) highlightPos.push(pos);
                                }
                            }
                            // Create a set of highlighted column numbers from label chars
                            const highlightedLabelChars = new Set(highlightPos.map(pos => labelStr[pos]));
                            // Convert column chars to numbers 1-45 that belong to those columns
                            const highlightedNums = new Set();
                            for (let num = 1; num <= 45; num++) {
                                if (highlightedLabelChars.has(String(getCol(num)))) {
                                    highlightedNums.add(num);
                                }
                            }
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, highlightedNums, totalCount, consec.checked);
                            const labelHtml = renderHighlightedLabel(labelStr, highlightPos);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                }
            }

            const applyCell9Mode = (mode, { notify = true } = {}) => {
                if (mode !== 'number' && mode !== 'label') return;
                if (!notify && cell9ModeState === mode) return;

                cell9ModeState = mode;
                modeBtn.textContent = cell9ModeState === 'number' ? 'Bộ số (1-45)' : 'Label (1-6)';

                // Clear old drag listeners by removing and recreating containers
                document.querySelectorAll(".drag-input-container").forEach(c => {
                    c.style.opacity = "1";
                    c.style.transform = "";
                });

                inputs = createInputs(mode);
                containers = createContainers(inputs);

                // Reset draggedIndex to prevent stale references
                draggedIndex = null;

                setupDragListeners(containers);
                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                inputLabel.textContent = mode === "number" ? "Bộ số:" : "Label:";

                // Insert containers in visual order (avoid accidental reversal)
                const containersToAdd = mode === "label" ? [...containers].reverse() : containers;
                let anchor = inputLabel;
                containersToAdd.forEach(c => {
                    anchor.parentNode.insertBefore(c, anchor.nextSibling);
                    anchor = c;
                });

                // Navigation based on visual order (containersToAdd defines on-screen order)
                const navOrder = containersToAdd.map(c => parseInt(c.dataset.index, 10));
                const attachKeyHandlers = () => {
                    inputs.forEach((inp, logicalIdx) => {
                        inp.oninput = run;
                        inp.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const pos = navOrder.indexOf(logicalIdx);
                            if (pos === -1) return;
                            const nextPos = e.key === 'ArrowLeft'
                                ? (pos > 0 ? pos - 1 : navOrder.length - 1)
                                : (pos < navOrder.length - 1 ? pos + 1 : 0);
                            const targetIdx = navOrder[nextPos];
                            inputs[targetIdx]?.focus();
                        };
                    });
                };
                attachKeyHandlers();

                if (notify) setNumberPickerMode(mode);
                run();
            };

            // Toggle button click to switch modes and notify popup
            modeBtn.addEventListener('click', () => {
                const next = cell9ModeState === 'number' ? 'label' : 'number';
                applyCell9Mode(next, { notify: false });
            });

            // Initial handlers for first render: use current visual order
            const initialContainers = cell9ModeState === "label" ? [...containers].reverse() : containers;
            const initialNavOrder = initialContainers.map(c => parseInt(c.dataset.index, 10));
            inputs.forEach((inp, logicalIdx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                    e.preventDefault();
                    const pos = initialNavOrder.indexOf(logicalIdx);
                    if (pos === -1) return;
                    const nextPos = e.key === 'ArrowLeft'
                        ? (pos > 0 ? pos - 1 : initialNavOrder.length - 1)
                        : (pos < initialNavOrder.length - 1 ? pos + 1 : 0);
                    const targetIdx = initialNavOrder[nextPos];
                    inputs[targetIdx]?.focus();
                };
            });
            consec.onchange = run; clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function setValsIsSubset(setVals, arr) { for (const v of setVals) if (!arr.includes(v)) return false; return true; }
        function hasConsecutiveBlock(nums, setVals) {
            const k = setVals.size;
            for (let i = 0; i <= nums.length - k; i++) {
                const block = nums.slice(i, i + k);
                if (block.length === k && setValsIsSubset(setVals, block) && new Set(block).size === setVals.size) return true;
            }
            return false;
        }

        // Cell10: analyze other positions given value at order
        function renderCell10() {
            const body = sectionShell("cell10", "Cell10 · Phân tích các vị trí khác", "Điền 1 giá trị vào 1 ô để xem phân bố ở 5 vị trí còn lại. Có thể kéo thả giữa các vị trí.");
            // Mode toggle: Number (1–45) vs Column (1–6)
            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : "number";
            let cell10ModeState = popupMode === "label" ? "column" : "number";
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // per-input scroll memory and last active index for cell10
            window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
            window._cell10LastIndex = window._cell10LastIndex ?? null;

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };
                const clampForColumn = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 45) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 6) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 45;
                        if (n > 45) n = 45;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 6;
                        if (n > 6) n = 6;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                inp.addEventListener('change', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            if (run) run(idx);
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run(0);
                            }
                        } catch (err) { }
                    }
                    // Kéo số trực tiếp từ popup (chỉ nếu không phải internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (cell10ModeState === 'number' && num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        } else if (cell10ModeState === 'column' && num >= 1 && num <= 45) {
                            const col = getCol(num);
                            inputs[idx].value = col;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // Kéo label từ header popup khi mode = column
                    else if (draggedIndex === null && labelData && cell10ModeState === 'column') {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run(idx);
                        draggedIndex = null;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        return;
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        if (run) run(idx);
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            // Add mode toggle button
            controls.append(modeBtn);
            containers.forEach(c => controls.appendChild(c)); body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run(changeIdx) {
                const prevScroll = window.scrollY;
                try {
                    if (changeIdx !== undefined && changeIdx !== null) {
                        window._cell10LastIndex = changeIdx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(changeIdx, prevScroll);
                    }
                } catch (e) { }

                const filled = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).filter(x => !isNaN(x.val));
                if (filled.length > 1 && changeIdx !== undefined) {
                    filled.filter(f => f.idx !== changeIdx).forEach(f => {
                        inputs[f.idx].value = "";
                        // Refresh drag visuals when value is cleared programmatically
                        inputs[f.idx].dispatchEvent(new Event("input"));
                    });
                }
                const single = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).find(x => !isNaN(x.val));
                if (!single) {
                    wrap.innerHTML = cell10ModeState === "number"
                        ? "<div class='loader'>Điền 1 số (1–45) vào 1 ô...</div>"
                        : "<div class='loader'>Điền 1 cột (1–6) vào 1 ô...</div>";
                    // restore scroll for same-input edits
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const order = single.idx + 1; const value = single.val;
                const posCols = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] }; const posMaps = { 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {} };
                let total = 0, hit = 0;
                const selectedPosNumbers = []; // Collect numbers at selected position for column mode
                rows.forEach(r => {
                    if (r.nums.length !== 6) return; total++;
                    const matched = (cell10ModeState === "number") ? (r.nums[order - 1] === value) : (getCol(r.nums[order - 1]) === value);
                    if (!matched) return; hit++;
                    if (cell10ModeState === "column") selectedPosNumbers.push(r.nums[order - 1]);
                    for (let pos = 1; pos <= 6; pos++) { if (pos === order) continue; const v = r.nums[pos - 1]; const c = getCol(v); posCols[pos].push(c); (posMaps[pos][c] ||= []).push(v); }
                });
                if (!hit) {
                    const what = cell10ModeState === "number" ? value : `cột ${value}`;
                    wrap.innerHTML = `<div class='error'>Không có kỳ nào với ${what} ở vị trí ${order}</div>`;
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const pattern = Array(6).fill("_"); pattern[order - 1] = (cell10ModeState === "number") ? value : `C${value}`;
                let html = `<div class='muted'>${hit}/${total} kỳ (${(hit / total * 100).toFixed(2)}%) · Pattern: ${pattern.join(',')}</div>`;

                // Show numbers at selected position for column mode
                if (cell10ModeState === "column" && selectedPosNumbers.length > 0) {
                    const numCounts = countMap(selectedPosNumbers);
                    const numsHtml = Object.entries(numCounts).sort((a, b) => b[1] - a[1]).map(([num, count]) =>
                        `<strong>${num}</strong><span style='font-weight:400'>(${count})</span>`
                    ).join(', ');
                    html += `<div style='margin-top:8px;font-weight:700;color:var(--text-strong);'>${numsHtml}</div>`;
                }

                const positionsBefore = [1, 2, 3, 4, 5, 6].filter(p => p < order);
                const positionsAfter = [1, 2, 3, 4, 5, 6].filter(p => p > order);
                const renderPosTable = (pos) => {
                    const counts = countMap(posCols[pos]);
                    let rowsHtml = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([c, n]) => {
                        const vals = countMap(posMaps[pos][c] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        return `<tr><td style='font-weight:700'>Cột ${c}</td><td style='text-align:right;font-weight:700'>${n}</td><td style='text-align:right;font-weight:700'>${fmtPct(n / posCols[pos].length)}</td><td style='font-weight:700'>${valsHtml || '—'}</td></tr>`;
                    }).join("");
                    return `<div class='card'><h4>Vị trí ${pos}</h4><table><thead><tr><th>Cột</th><th>Số lần</th><th>Tỷ lệ</th><th>Số hay đi cùng</th></tr></thead><tbody>${rowsHtml}</tbody></table></div>`;
                };
                // Column-mode: compact 4-column table (Column | Count | Percentage | Numbers), 6 rows ranked
                const renderPosTableColumn = (pos) => {
                    const counts = countMap(posCols[pos]);
                    const totalPos = posCols[pos].length || 1;
                    const items = [1, 2, 3, 4, 5, 6].map(c => ({ col: c, count: counts[c] || 0, pct: (counts[c] || 0) / totalPos }));
                    items.sort((a, b) => b.count - a.count || a.col - b.col);
                    // Ensure each card is at most 1/3 of the row and centered
                    let t = `<div class='card' style='flex:0 1 calc(33.333% - 10px);'><h4 style='margin:0 0 8px;'>Vị trí ${pos}</h4><table><thead><tr><th>Cột</th><th>Số lần</th><th>Tỷ lệ</th><th>Số hay xuất hiện</th></tr></thead><tbody>`;
                    items.forEach((it, idx) => {
                        const vals = countMap(posMaps[pos][it.col] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        t += `<tr><td style='font-weight:700'>${it.col}</td><td style='text-align:right;font-weight:700'>${it.count}</td><td style='text-align:right;font-weight:700'>${fmtPct(it.pct)}</td><td style='font-weight:700'>${valsHtml || '—'}</td></tr>`;
                    });
                    t += "</tbody></table></div>";
                    return t;
                };
                if (positionsBefore.length) html += `<h4>Vị trí trước</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsBefore.map(renderPosTable) : positionsBefore.map(renderPosTableColumn)).join('')}</div>`;
                if (positionsAfter.length) html += `<h4>Vị trí sau</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsAfter.map(renderPosTable) : positionsAfter.map(renderPosTableColumn)).join('')}</div>`;
                wrap.innerHTML = html;
                // restore scroll for same-input edits (prevent jump-to-top)
                if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                    // small timeout to let layout settle
                    setTimeout(() => window.scrollTo(0, prevScroll), 0);
                }
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
                inp.addEventListener('focus', () => {
                    try {
                        window._cell10LastIndex = idx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(idx, window.scrollY);
                    } catch (e) { }
                });
            });
            clearBtn.onclick = () => {
                inputs.forEach(i => {
                    i.value = "";
                    // Refresh drag visuals after clear
                    i.dispatchEvent(new Event("input"));
                });
                run();
            };
            // Toggle button: adjust constraints, notify popup, clear values, rerun
            modeBtn.addEventListener('click', () => {
                cell10ModeState = cell10ModeState === 'number' ? 'column' : 'number';
                modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
                const newPopupMode = cell10ModeState === 'column' ? 'label' : 'number';
                if (window.setNumberPickerMode) window.setNumberPickerMode(newPopupMode);
                inputs.forEach(inp => {
                    if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                    else { inp.min = 1; inp.max = 6; inp.placeholder = '1–6'; }
                    inp.value = '';
                    inp.dispatchEvent(new Event('input'));
                });
                run();
            });
            // Subscribe to external mode changes
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    cell10ModeState = mode === 'label' ? 'column' : 'number';
                    modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
                    inputs.forEach(inp => {
                        if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                        else { inp.min = 1; inp.max = 6; inp.placeholder = '1–6'; }
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                    });
                    run();
                });
            }
            run();
        }
        function countMap(arr) { const m = {}; arr.forEach(v => m[v] = (m[v] || 0) + 1); return m; }

        // Cell11: pattern search 6 positions with commas, _ wildcard
        function renderCell11() {
            const body = sectionShell("cell11", "Cell11 · Tìm kỳ theo Pattern số", "Nhập số (1-45) vào từng vị trí để tìm kỳ khớp. Có thể kéo thả số giữa các vị trí bằng chuột. Bỏ trống vị trí nào thì vị trí đó chấp nhận số bất kỳ.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                // small left-side grip so it doesn't cover the whole input and block typing
                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                // clamp to [1,45]
                const clampNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    if (n > 45) n = 45;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampNumber(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run();
                            }
                        } catch (err) { }
                    }
                    // Kéo số trực tiếp từ popup (chỉ nếu không phải internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Pattern:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            controls.appendChild(labelText);
            containers.forEach(c => controls.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });
            body.appendChild(controls);

            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            // Add hint text
            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            // place recency select at end of controls
            controls.appendChild(recencySel);

            function run(changeIdx) {
                const pattern = inputs.map(inp => {
                    const v = inp.value.trim();
                    if (!v) return "_";
                    const n = parseInt(v, 10);
                    return (n >= 1 && n <= 45) ? String(n) : "_";
                });
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                if (pattern.every(p => p === "_")) { wrap.innerHTML = "<div class='loader'>Nhập vào 1 ô để tìm kiếm...</div>"; return; }
                const results = rows.filter(r => pattern.every((p, i) => p === "_" || r.nums[i] === Number(p)));
                if (!results.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào khớp pattern</div>"; return; }
                const patternStr = pattern.join(',');
                let display = results.slice();
                if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                let html = `<div class='muted'>${results.length} kỳ · pattern ${patternStr}</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < display.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    display.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_" ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        const highlightPositions = pattern.map((p, i) => p === "_" ? -1 : i).filter(i => i >= 0);
                        const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        async function bootstrap() {
            // Number picker popup
            const htmlBadge = document.getElementById('htmlBadge');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');
            const placesGrid = document.getElementById('placesGrid');
            let isPopupVisible = false;

            // Place state: [value1, value2, value3, value4, value5, value6]
            const placeValues = ['', '', '', '', '', ''];
            let draggedNumber = null;
            let draggedPlaceIndex = null;
            let draggedPlaceValue = null;
            let lastDropInsidePlace = false; // track if a place drag was dropped back into place
            let currentMode = 'number'; // 'number' or 'label'
            const modeListeners = new Set();

            const notifyModeChange = (mode, source) => {
                modeListeners.forEach(fn => fn(mode, source));
            };

            const setNumberPickerMode = (mode, source = 'picker') => {
                if (mode !== 'number' && mode !== 'label') return;
                if (currentMode === mode) return;
                currentMode = mode;
                modeSelector.value = mode;
                // Clear place values when switching mode
                placeValues.fill('');
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                notifyModeChange(mode, source);

                // Update connection toggle state when mode changes
                if (window.updateConnectionToggleState) {
                    window.updateConnectionToggleState();
                }

                // Update label cell styling based on new mode and place values
                updateLabelCellStyles();
            };

            window.setNumberPickerMode = (mode) => setNumberPickerMode(mode, 'external');
            window.getNumberPickerMode = () => currentMode;
            window.onNumberPickerModeChange = (cb) => {
                modeListeners.add(cb);
                return () => modeListeners.delete(cb);
            };

            // Quick-place toggle: two modes -> 'normal' (default) and 'hover' (hover a record to fill places)
            const quickPlaceToggleEl = document.getElementById('quickPlaceToggle');
            let quickPlaceMode = localStorage.getItem('quickPlaceMode') || 'normal';
            const setQuickPlaceMode = (mode) => {
                quickPlaceMode = mode === 'hover' ? 'hover' : 'normal';
                if (quickPlaceToggleEl) {
                    quickPlaceToggleEl.textContent = quickPlaceMode === 'normal' ? 'Normal' : 'Hover';
                    quickPlaceToggleEl.title = quickPlaceMode === 'normal'
                        ? "Normal: dblclick copies record to clipboard (existing behavior)"
                        : "Hover: hovering a record fills the place boxes (dblclick-copy disabled)";
                }
                localStorage.setItem('quickPlaceMode', quickPlaceMode);
                // When switching back to normal mode, remove any popup highlights
                try {
                    if (quickPlaceMode !== 'hover' && typeof clearPopupHighlights === 'function') clearPopupHighlights();
                } catch (e) { /* ignore */ }
            };
            window.getQuickPlaceMode = () => quickPlaceMode;
            // initialize
            setQuickPlaceMode(quickPlaceMode);
            if (quickPlaceToggleEl) {
                quickPlaceToggleEl.addEventListener('click', () => {
                    setQuickPlaceMode(quickPlaceMode === 'normal' ? 'hover' : 'normal');
                });
            }

            // Hover handler: when in 'hover' mode, moving mouse over any record row (tr[data-result])
            // will populate the placeValues and refresh place boxes. Throttled to avoid excessive updates.
            const hoverToPlaceHandler = createThrottle((e) => {
                try {
                    if (quickPlaceMode !== 'hover') return;
                    const tr = e.target.closest && e.target.closest('tr[data-result]');
                    if (!tr) return;
                    const text = tr.dataset.result;
                    if (!text) return;
                    const arr = text.split(',').map(s => (s || '').trim());
                    if (arr.length !== 6) return;

                    // Normalize and compare to avoid unnecessary work
                    let identical = true;
                    for (let i = 0; i < 6; i++) {
                        const v = arr[i] || '';
                        if ((placeValues[i] || '') !== v) { identical = false; break; }
                    }
                    if (identical) return;

                    // Clear previous visual highlights and overlays first to avoid stale backgrounds
                    try {
                        if (numberPickerTable) {
                            const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                            prev.forEach(p => p.classList.remove('selected-number'));
                            const disabledCells = numberPickerTable.querySelectorAll('td.number-cell.disabled');
                            disabledCells.forEach(c => c.classList.remove('selected-number'));
                        }
                        const existingOverlays = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                        existingOverlays.forEach(n => n.remove());
                        const placeBoxes = placesGrid.querySelectorAll('.place-box');
                        placeBoxes.forEach(pb => {
                            pb.classList.remove('filled');
                            const val = pb.querySelector('.place-box-value');
                            if (val) val.textContent = '_';
                            pb.style.removeProperty('backgroundColor');
                            pb.style.removeProperty('borderColor');
                        });
                    } catch (err) { /* ignore visual cleanup errors */ }

                    // Apply hovered values (replace all previous values)
                    for (let i = 0; i < 6; i++) placeValues[i] = arr[i] || '';

                    // Re-render and sync highlights/connections
                    generateNumberPickerTable();
                    generatePlaceBoxes();
                    try { if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights(); } catch (e) { }
                    drawConnections();
                } catch (err) { /* ignore */ }
            }, 80);
            document.addEventListener('mousemove', hoverToPlaceHandler, true);

            // Popup scale state
            const popupScaleState = { scale: 1.0 };

            const savePopupScale = () => {
                localStorage.setItem('popupScale', JSON.stringify(popupScaleState.scale));
            };

            const loadPopupScale = () => {
                const saved = localStorage.getItem('popupScale');
                if (saved) {
                    popupScaleState.scale = parseFloat(saved);
                }
            };

            const applyPopupScale = () => {
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
            };

            const applyPopupScaleInstant = () => {
                // Apply scale instantly without transition animation
                const oldTransition = numberPickerPopup.style.transition;
                numberPickerPopup.style.transition = 'none';
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
                // Force browser to process the change
                void numberPickerPopup.offsetHeight;
                numberPickerPopup.style.transition = oldTransition;
            };

            const addPopupScaleHandle = () => {
                let handle = numberPickerPopup.querySelector('.popup-scale-handle');
                if (handle) handle.remove();

                handle = document.createElement('div');
                handle.className = 'popup-scale-handle';

                let isScaling = false;
                let startX = 0;
                let startScale = popupScaleState.scale;

                handle.addEventListener('mousedown', (e) => {
                    isScaling = true;
                    startX = e.clientX;
                    startScale = popupScaleState.scale;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScaling) return;
                    const diff = e.clientX - startX;
                    const newScale = Math.max(0.5, Math.min(2, startScale + diff * 0.0025));
                    popupScaleState.scale = parseFloat(newScale.toFixed(3));
                    applyPopupScale();
                    // update trash popup while scaling so its size/position follows immediately
                    try { if (typeof adjustTrashPosition === 'function') adjustTrashPosition(); } catch (err) { }
                });

                document.addEventListener('mouseup', () => {
                    if (isScaling) {
                        isScaling = false;
                        savePopupScale();
                    }
                });

                numberPickerPopup.appendChild(handle);
            };

            loadPopupScale();

            // Generate number picker table (rotated 90° counter-clockwise)
            function generateNumberPickerTable() {
                const numbersInPlace = currentMode === 'number'
                    ? new Set(placeValues.filter(v => v && v.trim() && !isNaN(v)))
                    : new Set();

                // Preserve trashed numbers by reading existing DOM state before we overwrite it.
                // This avoids relying on `trashItems` being in scope here.
                const existingTrash = new Set();
                try {
                    if (numberPickerTable) {
                        Array.from(numberPickerTable.querySelectorAll('td.in-trash')).forEach(td => {
                            const v = td.dataset && td.dataset.number ? Number(td.dataset.number) : NaN;
                            if (!isNaN(v)) existingTrash.add(v);
                        });
                    }
                } catch (e) { /* ignore */ }

                const numbersByCol = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
                for (let i = 1; i <= 45; i++) {
                    const col = getCol(i);
                    numbersByCol[col].push(i);
                }

                const tbodyDisabled = currentMode === 'label' ? ' class="disabled"' : '';
                const tfootDisabled = currentMode === 'number' ? ' class="disabled"' : '';

                let html = `<tbody${tbodyDisabled}>`;
                for (let row = 7; row >= 0; row--) {
                    html += '<tr>';
                    for (let col = 1; col <= 6; col++) {
                        const nums = numbersByCol[col];
                        const num = nums[row] || '_';
                        if (num === '_') {
                            html += `<td style="color:var(--muted);opacity:0.5;">_</td>`;
                        } else {
                            const isDisabled = numbersInPlace.has(String(num));
                            const disabledClass = isDisabled ? ' disabled' : '';
                            const inTrashFlag = existingTrash.has(Number(num));
                            // If a number is both in trash and present in the place boxes,
                            // mark it with an additional class so we can render a 50% dimmed
                            // overlay instead of the full solid red used for trashed-only items.
                            const inTrashDim = inTrashFlag && numbersInPlace.has(String(num));
                            const inTrashClass = inTrashDim ? ' in-trash in-trash-dim' : (inTrashFlag ? ' in-trash' : '');
                            let draggable = (isDisabled || currentMode === 'label' || inTrashFlag) ? 'false' : 'true';
                            // Check rank toggle; when enabled, show [#x] inside the same cell, left-aligned,
                            // while keeping the number centered.
                            const rankToggleEl = document.getElementById('rankToggle');
                            const rankEnabled = !!rankToggleEl && rankToggleEl.textContent.trim() === 'rank';
                            if (rankEnabled) {
                                const rankMap = window.rankByTotal || {};
                                const r = rankMap[num] ?? '';
                                // Only render badge when we have a rank value
                                let badgeHtml = '';
                                if (r !== '' && r !== null && r !== undefined) {
                                    const rankNum = Number(r);
                                    let color = 'var(--muted)';
                                    if (!isNaN(rankNum)) {
                                        if (rankNum >= 1 && rankNum <= 9) color = '#08eb56';
                                        else if (rankNum >= 10 && rankNum <= 18) color = '#00E5FF';
                                        else if (rankNum >= 19 && rankNum <= 27) color = '#1a62ea';
                                        else if (rankNum >= 28 && rankNum <= 36) color = '#ea3ade';
                                        else if (rankNum >= 37 && rankNum <= 45) color = '#ea0313';
                                    }
                                    badgeHtml = `<span class="rank-in-cell" style="position:absolute;left:6px;top:50%;transform:translateY(-50%);font-size:0.92em;font-weight:900;color:${color};background:transparent;opacity:1;z-index:2;-webkit-text-stroke:0.4px rgba(0,0,0,0.6);text-shadow:0 0 1px rgba(0,0,0,0.22);letter-spacing:0.6px;">#${rankNum}</span>`;
                                }
                                html += `<td class="number-cell${disabledClass}${inTrashClass}" draggable="${draggable}" data-number="${num}" style="position:relative;min-height:44px;">` +
                                    `${badgeHtml}` +
                                    `<span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span>` +
                                    `</td>`;
                            } else {
                                html += `<td class="number-cell${disabledClass}${inTrashClass}" draggable="${draggable}" data-number="${num}"><span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span></td>`;
                            }
                        }
                    }
                    html += '</tr>';
                }
                html += '</tbody>';

                html += `<tfoot${tfootDisabled}><tr>`;
                for (let col = 1; col <= 6; col++) {
                    html += `<th class="label-cell" data-label="C${col}" draggable="true" style="cursor: grab;">C${col}</th>`;
                }
                html += '</tr></tfoot>';

                numberPickerTable.innerHTML = html;
                // If there is an active hover-driven highlight set, reapply after regeneration
                try {
                    if (window.__popupHighlights && Array.isArray(window.__popupHighlights) && window.__popupHighlights.length) {
                        applyPopupHighlights(window.__popupHighlights);
                    }
                } catch (e) { /* ignore */ }

                // Draw connections after table is rendered
                requestAnimationFrame(() => drawConnections());
            }

            // Draw connections between consecutive numbers in place boxes
            function drawConnections() {
                const connectionToggle = document.getElementById('connectionToggle');
                const connectionsEnabled = !!connectionToggle && connectionToggle.textContent.trim() === 'Hiện';
                const euclidToggle = document.getElementById('euclidToggle');
                const euclidEnabled = !!euclidToggle && euclidToggle.textContent.trim() === 'Hiện';
                // Only draw in number mode and when connections are enabled
                if (currentMode !== 'number' || !connectionsEnabled) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Find consecutive pairs in placeValues
                const pairs = [];
                for (let i = 0; i < placeValues.length - 1; i++) {
                    const curr = placeValues[i];
                    const next = placeValues[i + 1];
                    if (curr && curr.trim() && !isNaN(curr) && next && next.trim() && !isNaN(next)) {
                        pairs.push([parseInt(curr, 10), parseInt(next, 10)]);
                    }
                }

                if (pairs.length === 0) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Get or create canvas
                let canvas = document.getElementById('connectionCanvas');
                const wrapper = numberPickerTable.parentElement;

                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.id = 'connectionCanvas';
                    canvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:1';
                    wrapper.appendChild(canvas);
                }

                const tableRect = numberPickerTable.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();

                // Get current popup scale
                const scale = popupScaleState.scale;

                // Get device pixel ratio for sharp rendering
                const dpr = window.devicePixelRatio || 1;

                // Canvas should match unscaled table size (divide by scale)
                const canvasWidth = tableRect.width / scale;
                const canvasHeight = tableRect.height / scale;

                // Set canvas display size (CSS pixels, unscaled)
                canvas.style.width = canvasWidth + 'px';
                canvas.style.height = canvasHeight + 'px';

                // Set canvas actual size (device pixels)
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;

                // Position canvas to align with table within wrapper (unscaled coordinates)
                canvas.style.left = '0px';
                canvas.style.top = '0px';

                const ctx = canvas.getContext('2d');
                // Scale context to match device pixel ratio
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Store circle centers for line drawing
                const circleCenters = {};
                const circleRadius = 9;

                // Theme-aware colors
                const cssVars = getComputedStyle(document.documentElement);
                const lineColor = (cssVars.getPropertyValue('--connection-line-color') || '#00cc00').trim();
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const circleColor = currentTheme === 'light' ? lineColor : '#667eea';

                // Draw circles around all numbers in placeValues
                const allNumbers = placeValues
                    .filter(v => v && v.trim() && !isNaN(v))
                    .map(v => parseInt(v, 10));

                allNumbers.forEach(num => {
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (!cell) return;

                    const cellRect = cell.getBoundingClientRect();

                    // Apply scale factor to coordinates
                    const x = (cellRect.left - tableRect.left) / scale + (cellRect.width / scale) / 2;
                    const y = (cellRect.top - tableRect.top) / scale + (cellRect.height / scale) / 2;

                    // Store center for line drawing
                    circleCenters[num] = { x, y };

                    // Draw circle (stroke, not fill)
                    ctx.strokeStyle = circleColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                // Draw lines between consecutive pairs, starting from circle edge
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);

                pairs.forEach(([num1, num2]) => {
                    const center1 = circleCenters[num1];
                    const center2 = circleCenters[num2];
                    if (!center1 || !center2) return;

                    const x1 = center1.x;
                    const y1 = center1.y;
                    const x2 = center2.x;
                    const y2 = center2.y;

                    // Calculate angle from center1 to center2
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    // Start line from the edge of circle1, pointing toward circle2
                    const startX = x1 + circleRadius * Math.cos(angle);
                    const startY = y1 + circleRadius * Math.sin(angle);

                    // End line at the edge of circle2, pointing back toward circle1
                    const endX = x2 - circleRadius * Math.cos(angle);
                    const endY = y2 - circleRadius * Math.sin(angle);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // --- Draw Euclidean distance (in grid cell units) near the middle of the line ---
                    try {
                        // Find grid row/col indices by inspecting tbody rows and cell positions
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${num1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${num2}"]`);
                        if (cell1 && cell2 && tbodyRows.length > 0) {
                            const rowElem1 = cell1.parentElement;
                            const rowElem2 = cell2.parentElement;
                            const rowIdx1 = tbodyRows.indexOf(rowElem1); // 0..n-1 (top -> bottom)
                            const rowIdx2 = tbodyRows.indexOf(rowElem2);

                            // In generator rows are created from row=7 down to 0, so logicalRow = 7 - rowIndex
                            const logicalRow1 = 7 - rowIdx1;
                            const logicalRow2 = 7 - rowIdx2;

                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1); // 0..5 left->right
                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);

                            const dx = colIdx2 - colIdx1;
                            const dy = logicalRow2 - logicalRow1;
                            const gridDistance = Math.sqrt(dx * dx + dy * dy);

                            // Midpoint of drawn segment
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;

                            // Place label directly on the line midpoint (overlay the connection)
                            const labelX = midX;
                            const labelY = midY;

                            // Draw label background for readability (only when euclid toggle enabled)
                            if (euclidEnabled) {
                                const labelText = gridDistance.toFixed(2);
                                ctx.save();
                                ctx.setLineDash([]);
                                ctx.font = '12px Inter, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                // measure
                                const metrics = ctx.measureText(labelText);
                                const paddingX = 6;
                                const paddingY = 3;
                                const rectW = metrics.width + paddingX * 2;
                                const rectH = 12 + paddingY * 2;

                                // Semi-transparent background
                                ctx.fillStyle = currentTheme === 'light' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.7)';
                                ctx.beginPath();
                                ctx.roundRect
                                    ? ctx.roundRect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH, 4)
                                    : ctx.rect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH);
                                ctx.fill();

                                // Draw text
                                ctx.fillStyle = currentTheme === 'light' ? '#000' : '#fff';
                                ctx.fillText(labelText, labelX, labelY);
                                ctx.restore();
                            }
                        }
                    } catch (e) {
                        // ignore label drawing errors to avoid breaking connections
                    }
                });
            }

            // Generate place boxes - 6 individual boxes
            function generatePlaceBoxes() {
                placesGrid.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const placeBox = document.createElement('div');
                    placeBox.className = `place-box ${placeValues[i] ? 'filled' : ''}`;
                    placeBox.dataset.placeIndex = i;
                    // Always allow dragging so an empty slot can receive a swapped value
                    placeBox.draggable = true;

                    // Dblclick to paste clipboard into all 6 slots (number mode only)
                    placeBox.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        pasteClipboardToPlaces();
                    });

                    const value = document.createElement('div');
                    value.className = 'place-box-value';
                    value.textContent = placeValues[i] || '_';
                    placeBox.appendChild(value);

                    placeBox.addEventListener('dragstart', (e) => {
                        draggedPlaceIndex = i;
                        draggedPlaceValue = placeValues[i];
                        lastDropInsidePlace = false;
                        e.dataTransfer.effectAllowed = 'copyMove';
                        e.dataTransfer.setData('text/plain', placeValues[i] || '');
                        e.dataTransfer.setData('application/x-place-index', String(i));
                        e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    });

                    placeBox.addEventListener('dragend', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        if (!lastDropInsidePlace && draggedPlaceValue) {
                            placeValues[draggedPlaceIndex] = '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                        draggedPlaceIndex = null;
                        draggedPlaceValue = null;
                    });

                    placeBox.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                        placeBox.style.borderColor = 'var(--accent-2)';
                        placeBox.style.backgroundColor = 'rgba(102, 126, 234, 0.25)';
                    });

                    placeBox.addEventListener('dragleave', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';
                    });

                    placeBox.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        lastDropInsidePlace = true;
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';

                        if (draggedPlaceIndex !== null && draggedPlaceIndex !== i) {
                            const tmp = placeValues[i];
                            placeValues[i] = draggedPlaceValue || '';
                            placeValues[draggedPlaceIndex] = tmp || '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            document.querySelectorAll('.place-box').forEach(box => {
                                box.style.removeProperty('borderColor');
                                box.style.removeProperty('backgroundColor');
                                box.style.removeProperty('opacity');
                            });
                            const placeContainer = numberPickerPopup.querySelector('.place-container');
                            if (placeContainer) {
                                placeContainer.style.removeProperty('borderColor');
                                placeContainer.style.removeProperty('backgroundColor');
                                placeContainer.style.removeProperty('opacity');
                            }
                            return;
                        }

                        let data = e.dataTransfer.getData('application/x-place-set');
                        if (data) {
                            try {
                                const values = JSON.parse(data);
                                for (let j = 0; j < 6; j++) {
                                    placeValues[j] = values[j] || '';
                                }
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                                return;
                            } catch (err) { }
                        }

                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData && currentMode === 'label') {
                            const colNum = labelData.replace('C', '');
                            placeValues[i] = colNum;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                            return;
                        }

                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num) && currentMode === 'number') {
                            placeValues[i] = num;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                    });

                    placesGrid.appendChild(placeBox);
                }
                // remove old overlays if any
                const existing = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                existing.forEach(n => n.remove());

                // helper: compute grid distance like drawConnections does
                function computeGridDistance(n1, n2) {
                    try {
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${n1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${n2}"]`);
                        if (!cell1 || !cell2 || tbodyRows.length === 0) return null;
                        const rowElem1 = cell1.parentElement;
                        const rowElem2 = cell2.parentElement;
                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                        const logicalRow1 = 7 - rowIdx1;
                        const logicalRow2 = 7 - rowIdx2;
                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                        const dx = colIdx2 - colIdx1;
                        const dy = logicalRow2 - logicalRow1;
                        return Math.sqrt(dx * dx + dy * dy);
                    } catch (e) { return null; }
                }

                // For each adjacent pair, if both filled and euclid enabled, create overlay
                const boxes = placesGrid.querySelectorAll('.place-box');
                // position overlays relative to the places grid so they sit centered
                // between the .place-box elements even when the popup is scrolled
                const containerRect = placesGrid.getBoundingClientRect();
                for (let i = 0; i < boxes.length - 1; i++) {
                    const a = placeValues[i];
                    const b = placeValues[i + 1];
                    if (currentMode === 'number' && euclidState && a && b && !isNaN(a) && !isNaN(b)) {
                        const boxA = boxes[i];
                        const boxB = boxes[i + 1];
                        if (!boxA || !boxB) continue;
                        // compute centers relative to placesGrid using offset values
                        const aCenterX = boxA.offsetLeft + boxA.offsetWidth / 2;
                        const bCenterX = boxB.offsetLeft + boxB.offsetWidth / 2;
                        const aCenterY = boxA.offsetTop + boxA.offsetHeight / 2;
                        const bCenterY = boxB.offsetTop + boxB.offsetHeight / 2;
                        const midX = (aCenterX + bCenterX) / 2;
                        const midY = (aCenterY + bCenterY) / 2;
                        const overlay = document.createElement('div');
                        overlay.className = 'place-distance-overlay';
                        const dist = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                        overlay.textContent = dist === null ? '' : dist.toFixed(2);
                        // set position inside placesGrid (no viewport -> container conversion needed)
                        overlay.style.left = midX + 'px';
                        overlay.style.top = midY + 'px';
                        placesGrid.appendChild(overlay);
                    }
                }
                // Compute total Euclidean distance for adjacent pairs and update display
                try {
                    const euclidTotalEl = document.getElementById('euclidTotal');
                    let total = 0;
                    for (let j = 0; j < boxes.length - 1; j++) {
                        const a = placeValues[j];
                        const b = placeValues[j + 1];
                        if (currentMode === 'number' && a && b && !isNaN(a) && !isNaN(b)) {
                            const d = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                            if (d !== null) total += d;
                        }
                    }
                    if (euclidTotalEl) {
                        // update nested value span if present
                        const valEl = document.getElementById('euclidTotalValue');
                        if (valEl) {
                            valEl.textContent = total.toFixed(2);
                            // ensure accent green emphasis remains
                            valEl.style.color = '#38ef7d';
                        } else {
                            euclidTotalEl.textContent = `Σ: ${total.toFixed(2)}`;
                        }
                        euclidTotalEl.style.opacity = (euclidState && currentMode === 'number') ? '1' : '0.5';
                    }
                } catch (e) { /* ignore */ }
                // Sync label and number highlights and redraw connections
                try {
                    updateLabelCellStyles();
                } catch (e) { /* ignore */ }
                try {
                    if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights();
                } catch (e) { /* ignore */ }
                try { drawConnections(); } catch (e) { /* ignore */ }
                try { if (typeof updateRankSummary === 'function') updateRankSummary(); } catch (e) { /* ignore */ }
            }

            function setupPlaceContainerListeners() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                placeContainer.draggable = true;

                placeContainer.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.dataTransfer.setData('text/plain', JSON.stringify(placeValues));
                    e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    placeContainer.style.opacity = '0.6';
                });

                placeContainer.addEventListener('dragend', () => {
                    placeContainer.style.opacity = '1';
                });

                placeContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                });

                placeContainer.addEventListener('dragleave', (e) => {
                    if (e.target === placeContainer) {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }
                });

                placeContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    lastDropInsidePlace = true;
                    placeContainer.style.borderColor = 'var(--accent)';
                    placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';

                    if (currentMode === 'number') {
                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num)) {
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = num;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                            }
                        }
                    } else if (currentMode === 'label') {
                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData) {
                            const colNum = labelData.replace('C', '');
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = colNum;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                            }
                        }
                    }
                });
            }

            function setupNumberCellDragDrop() {
                // Use event delegation on the table to ensure handlers work
                // after the table is re-rendered and to avoid duplicate listeners.
                if (!numberPickerTable) return;
                if (numberPickerTable.dataset.dragDelegation === 'true') return;
                numberPickerTable.dataset.dragDelegation = 'true';

                numberPickerTable.addEventListener('dragstart', (e) => {
                    const cell = e.target.closest('.number-cell');
                    if (!cell) return;
                    // Respect explicit draggable attribute set on cells
                    const draggableAttr = cell.getAttribute('draggable');
                    if (draggableAttr === 'false') return;
                    draggedNumber = cell.dataset.number;
                    try {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', draggedNumber);
                    } catch (err) {
                        // Some environments may restrict dataTransfer; fail silently
                    }
                });

                numberPickerTable.addEventListener('dragend', () => {
                    draggedNumber = null;
                });
            }

            function setupLabelCellDragDrop() {
                if (!numberPickerTable) return;
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    // Skip if already setup (has data attribute)
                    if (cell.dataset.dragSetup === 'true') return;

                    // Clone to remove all old event listeners
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    // Explicitly set draggable to ensure it works after cloneNode
                    newCell.draggable = true;
                    newCell.dataset.dragSetup = 'true';

                    newCell.addEventListener('dragstart', (e) => {
                        const label = newCell.dataset.label;
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('application/x-label', label);
                        newCell.style.opacity = '0.5';
                    });

                    newCell.addEventListener('dragend', () => {
                        newCell.style.opacity = '1';
                    });
                });
            }

            // Update label cell styling based on place values
            function updateLabelCellStyles() {
                if (!numberPickerTable) return;
                const tfoot = numberPickerTable.tFoot;

                if (currentMode !== 'number') {
                    // In label mode, make all label cells bright and draggable (only inside popup)
                    const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                    labelCells.forEach(cell => cell.classList.add('with-values'));
                    if (tfoot) tfoot.classList.remove('disabled');
                    return;
                }

                // In number mode, determine which columns have values in placeValues
                const columnsWithValues = new Set();
                placeValues.forEach(val => {
                    if (val && val.trim() && !isNaN(val)) {
                        const num = parseInt(val, 10);
                        const col = getCol(num); // Use existing getCol helper
                        columnsWithValues.add(col);
                    }
                });

                // If any columns have values, remove disabled class from tfoot to show labels bright
                if (columnsWithValues.size > 0) {
                    if (tfoot) tfoot.classList.remove('disabled');
                } else {
                    if (tfoot) tfoot.classList.add('disabled');
                }

                // Update label cell styling
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    const label = cell.dataset.label; // e.g., "C1", "C2", ...
                    const colNum = parseInt(label.substring(1), 10); // Extract column number
                    if (columnsWithValues.has(colNum)) {
                        cell.classList.add('with-values');
                    } else {
                        cell.classList.remove('with-values');
                    }
                });
            }

            // Update number-cell highlights to match placeValues
            function updateNumberCellHighlights() {
                if (!numberPickerTable) return;
                // remove previous highlights
                const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                prev.forEach(p => p.classList.remove('selected-number'));

                if (currentMode !== 'number') return;

                // add highlight for each placed number
                placeValues.forEach(v => {
                    if (!v || v === '' || isNaN(v)) return;
                    const num = String(parseInt(v, 10));
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (cell) cell.classList.add('selected-number');
                });
            }

            // Render a compact summary of place values by rank color/type
            function updateRankSummary() {
                const el = document.getElementById('rankSummary');
                if (!el) return;
                const mapping = {
                    Green: '#08eb56',
                    Cyan: '#00E5FF',
                    Blue: '#1a62ea',
                    Pink: '#ea3ade',
                    Red: '#ea0313'
                };
                const counts = { Green: 0, Cyan: 0, Blue: 0, Pink: 0, Red: 0 };
                const order = ['Green', 'Cyan', 'Blue', 'Pink', 'Red'];

                for (let i = 0; i < placeValues.length; i++) {
                    const v = placeValues[i];
                    if (!v || v === '' || isNaN(v)) continue;
                    const num = parseInt(v, 10);
                    const rankMap = window.rankByTotal || {};
                    const rankNum = rankMap[num] || null;
                    let name = null;
                    if (rankNum !== null && rankNum !== undefined) {
                        if (rankNum >= 1 && rankNum <= 9) name = 'Green';
                        else if (rankNum >= 10 && rankNum <= 18) name = 'Cyan';
                        else if (rankNum >= 19 && rankNum <= 27) name = 'Blue';
                        else if (rankNum >= 28 && rankNum <= 36) name = 'Pink';
                        else if (rankNum >= 37 && rankNum <= 45) name = 'Red';
                    }
                    if (name) counts[name] = (counts[name] || 0) + 1;
                }

                // Build display
                const parts = [];
                order.forEach((nm) => {
                    const c = counts[nm];
                    if (c && c > 0) {
                        const color = mapping[nm] || 'var(--muted)';
                        parts.push(`<span style="color:${color};font-weight:900">${c}${nm}</span>`);
                    }
                });
                if (parts.length === 0) {
                    el.innerHTML = '<span style="color:var(--muted)">—</span>';
                } else {
                    // join with muted separator
                    el.innerHTML = parts.join('<span style="color:var(--muted);margin:0 6px"> - </span>');
                }
            }

            const modeSelector = document.getElementById('modeSelector');
            let modeState = 'number';
            modeSelector.addEventListener('click', () => {
                modeState = modeState === 'number' ? 'label' : 'number';
                modeSelector.textContent = modeState === 'number' ? 'Số (1-45)' : 'Label (C1-C6)';
                setNumberPickerMode(modeState, 'picker');
            });

            const modeRows = document.getElementById('modeRows');
            // Sync mode button when mode changes from external sources (cell9/10)
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    modeState = mode;
                    modeSelector.textContent = mode === 'number' ? 'Số (1-45)' : 'Label (C1-C6)';
                });
            }

            // Connection toggle
            const connectionToggle = document.getElementById('connectionToggle');
            const connectionToggleLabel = document.getElementById('connectionToggleLabel');
            const euclidToggle = document.getElementById('euclidToggle');
            const euclidToggleLabel = document.getElementById('euclidToggleLabel');

            const updateConnectionToggleState = () => {
                const isNumberMode = currentMode === 'number';
                connectionToggle.disabled = !isNumberMode;
                if (connectionToggleLabel) {
                    connectionToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                }
                connectionToggle.style.opacity = isNumberMode ? '1' : '0.5';
                connectionToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Euclid toggle should follow same availability rules as connection toggle
                if (euclidToggle) euclidToggle.disabled = !isNumberMode;
                if (euclidToggleLabel) euclidToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Update Euclid total display availability
                const euclidTotalEl = document.getElementById('euclidTotal');
                if (euclidTotalEl) euclidTotalEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';
                // also dim the numeric value if present
                const euclidValEl = document.getElementById('euclidTotalValue');
                if (euclidValEl) euclidValEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';

                // Redraw when toggled
                drawConnections();
            };

            // Expose globally for mode change callback
            window.updateConnectionToggleState = updateConnectionToggleState;

            let connectionState = true;
            connectionToggle.addEventListener('click', () => {
                connectionState = !connectionState;
                connectionToggle.textContent = connectionState ? 'Hiện' : 'Ẩn';
                drawConnections();
            });

            // Euclid toggle state and handler
            let euclidState = true; // default visible
            if (euclidToggle) {
                euclidToggle.textContent = euclidState ? 'Hiện' : 'Ẩn';
                euclidToggle.addEventListener('click', () => {
                    euclidState = !euclidState;
                    euclidToggle.textContent = euclidState ? 'Hiện' : 'Ẩn';
                    drawConnections();
                    // Refresh place overlays and Euclid total display
                    try { generatePlaceBoxes(); } catch (e) { /* ignore if not ready */ }
                });
            }

            // Initialize connection toggle state
            updateConnectionToggleState();

            // Paste clipboard into place (dblclick on any place box) when in number mode
            async function pasteClipboardToPlaces() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                const flashFail = (reason) => {
                    console.log('Paste failed:', reason);
                    if (!placeContainer) return;
                    placeContainer.style.borderColor = '#ef4444';
                    placeContainer.style.backgroundColor = 'rgba(239, 68, 68, 0.14)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 450);
                };

                if (currentMode !== 'number') {
                    flashFail('wrong mode: ' + currentMode);
                    return;
                }

                const readClipboard = async () => {
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        return navigator.clipboard.readText();
                    }
                    if (window.clipboardData && window.clipboardData.getData) {
                        return window.clipboardData.getData('Text');
                    }
                    return null;
                };

                let txt = null;
                try {
                    txt = await readClipboard();
                    console.log('Raw clipboard result:', JSON.stringify(txt));
                } catch (err) {
                    console.error('Clipboard read error:', err);
                    flashFail('clipboard error: ' + err.message);
                    return;
                }

                if (txt === null || txt === undefined) {
                    console.error('Clipboard returned null - API blocked or not available');
                    flashFail('clipboard blocked (chạy qua http:// thay vì file://)');
                    return;
                }

                txt = txt.trim();
                if (!txt) {
                    flashFail('clipboard empty');
                    return;
                }

                const parts = txt.split(',').map(s => s.trim());
                console.log('Parts after split:', parts, 'length:', parts.length);
                if (parts.length !== 6) {
                    flashFail(`expected 6 parts, got ${parts.length}`);
                    return;
                }
                const next = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i];
                    if (p === '' || p === '_') { next.push(''); continue; }
                    const n = parseInt(p, 10);
                    console.log(`Part ${i}: "${p}" -> ${n}, valid: ${Number.isFinite(n) && n >= 1 && n <= 45}`);
                    if (!Number.isFinite(n) || n < 1 || n > 45) {
                        flashFail(`invalid number at position ${i + 1}: "${p}"`);
                        return;
                    }
                    next.push(String(n));
                }

                console.log('Paste successful:', next);
                for (let i = 0; i < 6; i++) placeValues[i] = next[i] || '';
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
                if (placeContainer) {
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 400);
                }
            }

            const clearPlaceBtn = document.getElementById('clearPlaceBtn');
            clearPlaceBtn.addEventListener('click', () => {
                for (let i = 0; i < placeValues.length; i++) {
                    placeValues[i] = '';
                }
                // Also clear any popup highlights (orange outline) and popup state
                try {
                    clearPopupHighlights();
                    window.__popupHighlights = null;
                    window.__popupHighlightSource = null;
                } catch (e) { /* ignore */ }

                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
            });

            // Optional color picker (removed from UI) — attach listener only if element exists
            const cellColorPicker = document.getElementById('cellColorPicker');
            if (cellColorPicker) {
                cellColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    // Update CSS variable instead of inline style to preserve hover effects
                    document.documentElement.style.setProperty('--cell-bg-color', color);
                });
            }

            // Wrap table in a relative-positioned container
            const tableWrapper = document.createElement('div');
            tableWrapper.style.position = 'relative';
            numberPickerTable.parentElement.insertBefore(tableWrapper, numberPickerTable);
            tableWrapper.appendChild(numberPickerTable);

            generateNumberPickerTable();
            generatePlaceBoxes();
            setupPlaceContainerListeners();
            setupNumberCellDragDrop();
            setupLabelCellDragDrop();

            // Rank toggle handler: toggles between 'unnank' and 'rank' and re-renders the table
            const rankToggleBtn = document.getElementById('rankToggle');
            if (rankToggleBtn) {
                rankToggleBtn.addEventListener('click', () => {
                    const cur = rankToggleBtn.textContent.trim();
                    const next = cur === 'rank' ? 'unnank' : 'rank';
                    rankToggleBtn.textContent = next;
                    // Re-generate table to show/hide ranks
                    try { generateNumberPickerTable(); setupNumberCellDragDrop(); } catch (e) { console.warn(e); }
                });
            }

            // Apply saved scale and add scale handle
            applyPopupScale();
            addPopupScaleHandle();

            // Helper: desired popup alpha based on inline slider (preserve across open/close)
            const __POPUP_MIN_ALPHA = 0.15;
            function __desiredPopupAlpha() {
                try {
                    const el = document.getElementById('popupOpacityRangeInline');
                    if (!el) return 1;
                    const pct = Number(el.value || 0);
                    if (pct === 0) return 1;
                    return 1 - (pct / 100) * (1 - __POPUP_MIN_ALPHA);
                } catch (e) { return 1; }
            }

            // Close button
            const closeNumberPickerBtn = document.getElementById('closeNumberPickerBtn');
            closeNumberPickerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Clear any orange popup highlights and related state
                try {
                    clearPopupHighlights();
                    window.__popupHighlights = null;
                    window.__popupHighlightSource = null;
                } catch (err) { /* ignore */ }

                isPopupVisible = false;
                numberPickerPopup.style.opacity = '0';
                setTimeout(() => {
                    numberPickerPopup.style.display = 'none';
                }, 300);
                // also hide trash popup when picker closes
                try { const t = document.getElementById('trashPopup'); if (t) t.style.display = 'none'; } catch (e) { }
                // Hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.remove('visible');
                }
            });

            // Toggle popup on click
            htmlBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                isPopupVisible = !isPopupVisible;

                if (isPopupVisible) {
                    // Apply scale BEFORE showing to prevent flash
                    applyPopupScaleInstant();

                    const savedPos = localStorage.getItem('popupPosition');
                    if (savedPos) {
                        const { top, left } = JSON.parse(savedPos);
                        numberPickerPopup.style.top = `${top}px`;
                        numberPickerPopup.style.left = `${left}px`;
                    } else {
                        const rect = htmlBadge.getBoundingClientRect();
                        numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                        numberPickerPopup.style.left = `${rect.left}px`;
                    }

                    // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                    numberPickerPopup.style.display = 'block';
                    numberPickerPopup.style.opacity = '0';

                    requestAnimationFrame(() => {
                        numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                    });
                } else {
                    numberPickerPopup.style.opacity = '0';
                    setTimeout(() => {
                        numberPickerPopup.style.display = 'none';
                    }, 300);
                    // hide trash popup when picker is programmatically hidden via toggle
                    try { const t = document.getElementById('trashPopup'); if (t) t.style.display = 'none'; } catch (e) { }
                }

                // Show/hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.toggle('visible', isPopupVisible);
                }
            });

            // Toggle popup with Ctrl
            let ctrlPressed = false;
            let ctrlWithOtherKey = false;
            // New: detect mouse interaction (click/mousedown) while Ctrl is held so
            // Ctrl+mouse actions (e.g., Ctrl+click to select a row) don't also toggle popup
            let ctrlHadMouseInteraction = false;

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control' && !e.repeat) {
                    ctrlPressed = true;
                    ctrlWithOtherKey = false;
                    ctrlHadMouseInteraction = false;
                } else if (ctrlPressed && e.key !== 'Control') {
                    ctrlWithOtherKey = true;
                }
            });

            // mark any mouse interaction while ctrl is pressed
            document.addEventListener('mousedown', (e) => {
                try { if (ctrlPressed) ctrlHadMouseInteraction = true; } catch (err) { }
            }, true);
            document.addEventListener('touchstart', (e) => {
                try { if (ctrlPressed) ctrlHadMouseInteraction = true; } catch (err) { }
            }, true);

            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control' && ctrlPressed && !ctrlWithOtherKey && !ctrlHadMouseInteraction) {
                    isPopupVisible = !isPopupVisible;
                    if (isPopupVisible) {
                        // Apply scale BEFORE showing
                        applyPopupScaleInstant();

                        const savedPos = localStorage.getItem('popupPosition');
                        if (savedPos) {
                            const { top, left } = JSON.parse(savedPos);
                            numberPickerPopup.style.top = `${top}px`;
                            numberPickerPopup.style.left = `${left}px`;
                        } else {
                            const rect = htmlBadge.getBoundingClientRect();
                            numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                            numberPickerPopup.style.left = `${rect.left}px`;
                        }

                        // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                        numberPickerPopup.style.display = 'block';
                        numberPickerPopup.style.opacity = '0';

                        requestAnimationFrame(() => {
                            numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                        });
                    } else {
                        numberPickerPopup.style.opacity = '0';
                        setTimeout(() => {
                            numberPickerPopup.style.display = 'none';
                        }, 300);
                        // hide trash popup when picker is programmatically hidden via Ctrl toggle
                        try { const t = document.getElementById('trashPopup'); if (t) t.style.display = 'none'; } catch (e) { }
                    }

                    // Show/hide scale handle
                    const handle = document.querySelector('.popup-scale-handle');
                    if (handle) {
                        handle.classList.toggle('visible', isPopupVisible);
                    }
                }
                if (e.key === 'Control') {
                    ctrlPressed = false;
                    ctrlWithOtherKey = false;
                    ctrlHadMouseInteraction = false;
                }
            });

            // Make popup draggable by background
            let popupOffsetX = 0, popupOffsetY = 0, isDraggingPopup = false;
            // track last mouse positions during popup drag so trash can follow the same movement
            let lastDragClientX = 0, lastDragClientY = 0;
            numberPickerPopup.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on close button
                if (e.target.closest('.number-picker-close-btn')) {
                    return;
                }
                if (e.target === numberPickerPopup) {
                    isDraggingPopup = true;
                    const rect = numberPickerPopup.getBoundingClientRect();
                    popupOffsetX = e.clientX - rect.left;
                    popupOffsetY = e.clientY - rect.top;
                    // initialize last drag mouse pos
                    lastDragClientX = e.clientX;
                    lastDragClientY = e.clientY;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (isDraggingPopup) {
                    const newLeft = e.clientX - popupOffsetX;
                    const newTop = e.clientY - popupOffsetY;
                    numberPickerPopup.style.left = newLeft + 'px';
                    numberPickerPopup.style.top = newTop + 'px';
                    localStorage.setItem('popupPosition', JSON.stringify({ top: newTop, left: newLeft }));
                    // Move trash popup by the same pointer delta when trash is attached to body
                    try {
                        const t = document.getElementById('trashPopup');
                        if (t && t.style.display === 'block' && t.parentElement === document.body) {
                            // compute pointer delta
                            const dx = e.clientX - lastDragClientX;
                            const dy = e.clientY - lastDragClientY;
                            // ensure numeric left/top values
                            let curLeft = parseFloat(t.style.left);
                            let curTop = parseFloat(t.style.top);
                            if (isNaN(curLeft) || isNaN(curTop)) {
                                // initialize via adjustTrashPosition then read values
                                if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                                curLeft = parseFloat(t.style.left) || 0;
                                curTop = parseFloat(t.style.top) || 0;
                            }
                            t.style.left = (curLeft + dx) + 'px';
                            t.style.top = (curTop + dy) + 'px';
                        } else {
                            // fallback: if trash is child of popup or not visible, keep regular adjust behavior
                            if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                        }
                    } catch (err) { /* ignore */ }
                    // update last drag mouse pos for next delta
                    lastDragClientX = e.clientX;
                    lastDragClientY = e.clientY;
                }
            });
            document.addEventListener('mouseup', () => { isDraggingPopup = false; });

            // Expose placeValues globally
            window.getPlaceValues = () => placeValues;
            window.markPlaceDropHandled = () => { lastDropInsidePlace = true; };
            window.setPlaceValues = (values) => {
                if (Array.isArray(values)) {
                    for (let i = 0; i < 6; i++) {
                        const v = values[i];
                        placeValues[i] = (v === undefined || v === null) ? '' : v;
                    }
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
            };
            window.applyPlaceValuesToInputs = (inputArray) => {
                if (inputArray && inputArray.length >= 6) {
                    for (let i = 0; i < 6; i++) {
                        const val = placeValues[i];
                        if (val && !isNaN(val)) {
                            inputArray[i].value = val;
                            inputArray[i].dispatchEvent(new Event('input'));
                        }
                    }
                }
            };

            // Scroll to top button
            const scrollBtn = document.getElementById('scrollToTop');
            scrollBtn.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'flex';
                    scrollBtn.style.alignItems = 'center';
                    scrollBtn.style.justifyContent = 'center';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });

            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            const root = document.documentElement;
            const savedTheme = localStorage.getItem('theme') || 'light';
            root.setAttribute('data-theme', savedTheme);
            themeToggle.onclick = () => {
                const current = root.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                // Redraw connection lines to apply theme-specific colors
                try { drawConnections(); } catch { }
            };

            // Tải dữ liệu TRƯỚC khi render các cell
            await loadData();

            // Compute global rank (by total count) so popup can show ranks
            try {
                const totalCounts = Array(46).fill(0);
                rows.forEach(r => { if (r.nums && r.nums.length === 6) r.nums.forEach(v => { totalCounts[v] = (totalCounts[v] || 0) + 1; }); });
                const ranked = [];
                for (let v = 1; v <= 45; v++) ranked.push({ v, cnt: totalCounts[v] || 0 });
                ranked.sort((a, b) => b.cnt - a.cnt || a.v - b.v);
                const rankByTotal = {};
                ranked.forEach((r, idx) => { rankByTotal[r.v] = idx + 1; });
                window.rankByTotal = rankByTotal;
                // Regenerate the number picker table now that ranks are available
                try {
                    if (typeof generateNumberPickerTable === 'function') generateNumberPickerTable();
                    if (typeof updateRankSummary === 'function') updateRankSummary();
                } catch (e) { console.warn('regen number picker after rank compute', e); }
            } catch (e) { window.rankByTotal = {}; }

            const showSection = createSectionSwitcher();
            // Renderer map for lazy section mounting
            const renderers = {
                cell4: renderCell4,
                cell5: renderCell5,
                cell5_5: renderCell5_5,
                // Note: mismatched creators – keep ids aligned with sections created inside
                cell6: renderCell8, // Phân nhóm theo bộ số
                cell6_5: renderCell6_5, // Truy x (lọc theo số x)
                cell6_6: renderCell6_6, // Mổ pattern (6 số cố định)
                cell7: renderCell6, // Nhóm theo label
                cell8: renderCell7, // Tìm kiếm theo Label
                cell9: renderCell9,
                cell10: renderCell10,
                cell11: renderCell11,
            };

            // Expose ensureRendered globally for nav handlers
            window.ensureRendered = function ensureRendered(id) {
                if (!document.getElementById(id)) {
                    const fn = renderers[id];
                    if (typeof fn === 'function') fn();
                }
            };

            buildNav(showSection);
            // Hiển thị section theo hash (nếu hợp lệ), mặc định cell4
            const initial = (location.hash || "#cell4").replace("#", "");
            // Lazy mount only the initial section
            window.ensureRendered(initial || "cell4");
            showSection(initial || "cell4");
            window.addEventListener("hashchange", () => {
                const id = (location.hash || "#cell4").replace("#", "");
                window.ensureRendered(id || "cell4");
                showSection(id || "cell4");
            });
        }

        // Tag nested cards inside `.card.card-inner` with `card-inner-child`.
        (function markInnerChildCards() {
            function mark() {
                document.querySelectorAll('.card.card-inner').forEach(wrapper => {
                    wrapper.querySelectorAll('.card').forEach(child => {
                        if (!child.classList.contains('card-inner-child')) child.classList.add('card-inner-child');
                    });
                    // If the wrapper contains exactly one descendant marked as card-inner-child,
                    // mark the wrapper with `single-child` so CSS can target descendant-only cases.
                    try {
                        const innerChildren = wrapper.querySelectorAll('.card-inner-child');
                        if (innerChildren.length === 1) wrapper.classList.add('single-child');
                        else wrapper.classList.remove('single-child');
                    } catch (e) { /* ignore */ }
                });
            }
            // initial pass
            try { mark(); } catch (e) { }
            // watch for future additions
            try {
                const mo = new MutationObserver(mark);
                mo.observe(document.body, { childList: true, subtree: true });
                // expose for debugging if needed
                window.__markInnerChildObserver = mo;
            } catch (e) { }
        })();

        // Setup inline opacity slider next to Σ and bind it to popup background alpha
        (function setupInlineOpacityControl() {
            const euclidTotal = document.getElementById('euclidTotal');
            const popup = document.getElementById('numberPickerPopup');
            if (!euclidTotal) return;

            // create container next to Σ if not exists
            if (!document.getElementById('popupOpacityRangeInline')) {
                const container = document.createElement('span');
                container.className = 'inline-opacity-container';
                container.innerHTML = `
                    <input id="popupOpacityRangeInline" type="range" min="0" max="100" value="0">
                    <div class="inline-percent" id="popupOpacityInlineValue">0%</div>
                `;
                euclidTotal.parentNode.insertBefore(container, euclidTotal.nextSibling);

                const range = container.querySelector('#popupOpacityRangeInline');
                const label = container.querySelector('#popupOpacityInlineValue');

                function parseRGB(str) {
                    const m = String(str).match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                    if (m) return [m[1], m[2], m[3]];
                    return [255, 255, 255];
                }

                function updateAlpha(v) {
                    label.textContent = `${v}%`;
                    const pct = Number(v);
                    if (!popup) return;

                    // Prevent fully transparent popup: reserve a minimum visible alpha.
                    const MIN_ALPHA = 0.15; // keep at least 15% opacity so popup never fully hides

                    // 0% should preserve the original visuals exactly (no inline overrides)
                    if (pct === 0) {
                        popup.style.backgroundColor = '';
                        popup.style.borderColor = '';
                        popup.style.boxShadow = '';
                        // If popup is currently displayed, ensure it remains visible (opacity 1).
                        // Otherwise clear inline opacity so it falls back to CSS when hidden.
                        try {
                            const csDisp = getComputedStyle(popup).display;
                            if (csDisp && csDisp !== 'none') {
                                popup.style.opacity = '1';
                            } else {
                                popup.style.opacity = '';
                            }
                        } catch (e) {
                            popup.style.opacity = '';
                        }
                        return;
                    }

                    // Map slider 0..100 -> alpha 1..MIN_ALPHA (linear)
                    const alpha = 1 - (pct / 100) * (1 - MIN_ALPHA);

                    const cs = getComputedStyle(popup);
                    const bg = cs.backgroundColor || 'rgb(255,255,255)';
                    const [r, g, b] = parseRGB(bg);

                    // Apply opacity to the whole popup so all children fade together
                    popup.style.opacity = String(alpha);
                    // Also set background rgba to preserve backdrop color when semi-transparent
                    popup.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    // Soften border and shadow proportionally (keep a minimum subtle border)
                    try {
                        const bc = cs.borderColor || 'rgb(0,0,0)';
                        const [br, bg2, bb] = parseRGB(bc);
                        const borderAlpha = Math.max(0.08, alpha * 0.9);
                        popup.style.borderColor = `rgba(${br}, ${bg2}, ${bb}, ${borderAlpha})`;
                    } catch (e) { }

                    try {
                        const shadowAlpha = 0.28 * alpha + 0.02;
                        popup.style.boxShadow = `0 8px 24px rgba(0,0,0,${shadowAlpha})`;
                    } catch (e) { }
                }

                // initialize
                updateAlpha(range.value);
                range.addEventListener('input', (e) => updateAlpha(e.target.value));
            }
        })();

        // Run bootstrap then enable sticky fallback for multiple sections
        bootstrap().then(() => {
            (function enableStickyFallbackForSections() {
                const SECTIONS = ['cell6_5', 'cell6_6', 'cell8', 'cell9', 'cell10', 'cell11'];
                const HEADER_OFFSET = 64; // matches CSS top

                SECTIONS.forEach(sectionId => {
                    const sec = document.getElementById(sectionId);
                    if (!sec) return;
                    const controls = sec.querySelector('.controls');
                    if (!controls) return;

                    let placeholder = null;

                    function update() {
                        const secRect = sec.getBoundingClientRect();
                        const ctrlRect = controls.getBoundingClientRect();
                        const shouldPin = secRect.top < HEADER_OFFSET && (secRect.bottom > (HEADER_OFFSET + ctrlRect.height));

                        if (shouldPin && !controls.classList.contains('stuck')) {
                            // create placeholder to preserve layout
                            placeholder = document.createElement('div');
                            placeholder.style.height = ctrlRect.height + 'px';
                            controls.parentNode.insertBefore(placeholder, controls);

                            controls.classList.add('stuck');
                            controls.style.position = 'fixed';
                            controls.style.top = HEADER_OFFSET + 'px';
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                            controls.style.zIndex = 1100;
                        } else if (!shouldPin && controls.classList.contains('stuck')) {
                            controls.classList.remove('stuck');
                            controls.style.position = '';
                            controls.style.top = '';
                            controls.style.left = '';
                            controls.style.width = '';
                            controls.style.zIndex = '';
                            if (placeholder) { placeholder.remove(); placeholder = null; }
                        }
                    }

                    // listeners
                    window.addEventListener('scroll', update, { passive: true });
                    window.addEventListener('resize', () => {
                        if (controls.classList.contains('stuck')) {
                            const secRect = sec.getBoundingClientRect();
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                        }
                    });

                    // mutation observer to handle dynamic content
                    const mo = new MutationObserver(() => setTimeout(update, 50));
                    mo.observe(sec, { childList: true, subtree: true });

                    // initial check
                    setTimeout(update, 120);
                });
            })();
        });
    </script>
    <script>
        // JS shim: add a compatibility class for `td:has(.pill)` so older editors/linters
        // won't complain and dynamic tables get the same behavior.
        (function markTdHasPill() {
            function markAll() {
                document.querySelectorAll('td').forEach(td => {
                    try {
                        if (td.querySelector && td.querySelector('.pill')) td.classList.add('td-has-pill');
                        else td.classList.remove('td-has-pill');
                    } catch (e) { /* ignore */ }
                });
            }
            // Initial pass
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', markAll);
            else markAll();
            // Watch for DOM changes (tables regenerated dynamically)
            const mo = new MutationObserver(() => { markAll(); });
            mo.observe(document.body, { childList: true, subtree: true });
        })();
    </script>
    <script>
        // Ctrl+Shift toggle between two most-recently-clicked sections (cells)
        (function () {
            const lastTwo = []; // keep up to 2 most recent section ids
            let lastClicked = null; // the most recently clicked section id
            let toggleLocked = false; // avoid repeat triggers while keys held

            function recordSectionClick(secId) {
                if (!secId) return;
                const idx = lastTwo.indexOf(secId);
                if (idx !== -1) lastTwo.splice(idx, 1);
                lastTwo.push(secId);
                if (lastTwo.length > 2) lastTwo.shift();
                lastClicked = secId;
            }

            // Delegate clicks: any click inside a section with an id counts
            document.addEventListener('click', function (ev) {
                try {
                    const sec = ev.target.closest('section[id]');
                    if (sec && sec.id) recordSectionClick(sec.id);
                    // Also treat clicks on nav buttons as selecting their target section
                    const navBtn = ev.target.closest('.nav-btn');
                    if (navBtn && navBtn.dataset && navBtn.dataset.target) recordSectionClick(navBtn.dataset.target);
                } catch (e) { /* ignore */ }
            }, true);

            function gotoSection(secId) {
                if (!secId) return;
                const sec = document.getElementById(secId);
                if (!sec) return;
                // Try to activate nav button if present (non-invasive)
                const selectors = [
                    '.nav-btn[data-target="' + secId + '"]',
                    '.nav-btn[data-section="' + secId + '"]',
                    '.nav-btn[href="#' + secId + '"]'
                ];
                let clicked = false;
                for (const s of selectors) {
                    const btn = document.querySelector(s);
                    if (btn) { btn.click(); clicked = true; break; }
                }
                // Fallback: scroll into view and focus safely
                if (!clicked) {
                    sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    try { if (typeof safeFocus === 'function') safeFocus(sec); else sec.focus(); } catch (e) { }
                }
                lastClicked = secId;
            }

            function toggleLastTwo() {
                if (lastTwo.length < 2) return;
                const older = lastTwo[0], newer = lastTwo[1];
                const target = (lastClicked === newer) ? older : newer;
                gotoSection(target);
            }

            // Trigger when Ctrl is held and Shift is tapped (allow repeated taps while Ctrl held)
            document.addEventListener('keydown', function (e) {
                try {
                    // only respond to physical Shift key down to avoid repeats from holding
                    if (e.key === 'Shift' && e.ctrlKey && !toggleLocked) {
                        toggleLocked = true; // lock until Shift is released
                        toggleLastTwo();
                        e.preventDefault();
                    }
                } catch (err) { }
                try { draggingNumber = null; } catch (e) { }
            }, true);
            document.addEventListener('keyup', function (e) {
                try {
                    // release the lock when Shift is released so another tap can trigger
                    if (e.key === 'Shift') toggleLocked = false;
                } catch (err) { }
            }, true);

            // Initialize by recording the first section in document (if any)
            (function init() {
                const first = document.querySelector('main section[id]');
                if (first && first.id) recordSectionClick(first.id);
            })();
        })();
    </script>
    <script>
        // More robust auto-scroll: MutationObserver + polling to handle slow loads.
        (function () {
            try {
                const toTop = document.getElementById('scrollToTop');
                const toBottom = document.getElementById('scrollToBottom');
                if (!toTop || !toBottom) return;

                let autoScrollActive = false;
                let mo = null;
                let pollIntervalId = null;
                let lastDocumentHeight = document.documentElement.scrollHeight;
                let lastScrollY = window.scrollY || window.pageYOffset || 0;

                function showHideButtons() {
                    const sc = window.scrollY || window.pageYOffset || 0;
                    const max = document.documentElement.scrollHeight - window.innerHeight;
                    toTop.style.display = (sc > 200) ? 'block' : 'none';
                    toBottom.style.display = (sc < max - 200) ? 'block' : 'none';
                }

                function scrollToBottomImmediate() {
                    const top = document.documentElement.scrollHeight - window.innerHeight;
                    window.scrollTo({ top: top, behavior: 'auto' });
                }

                function startPolling() {
                    if (pollIntervalId) return;
                    pollIntervalId = setInterval(() => {
                        const h = document.documentElement.scrollHeight;
                        if (h !== lastDocumentHeight) {
                            lastDocumentHeight = h;
                            // keep the viewport at the bottom when content grows
                            scrollToBottomImmediate();
                            // refresh button visibility after layout change
                            setTimeout(showHideButtons, 40);
                        }
                    }, 400); // check ~2.5 times/sec
                }

                function stopPolling() {
                    if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }
                }

                function startAutoScroll() {
                    if (autoScrollActive) return;
                    autoScrollActive = true;
                    // initial jump to bottom
                    scrollToBottomImmediate();
                    lastDocumentHeight = document.documentElement.scrollHeight;

                    // MutationObserver for immediate updates
                    const targetNode = document.querySelector('main') || document.documentElement;
                    mo = new MutationObserver((mutations) => {
                        if (!autoScrollActive) return;
                        const h = document.documentElement.scrollHeight;
                        if (h !== lastDocumentHeight) {
                            lastDocumentHeight = h;
                            scrollToBottomImmediate();
                            setTimeout(showHideButtons, 40);
                        }
                    });
                    try {
                        mo.observe(targetNode, { childList: true, subtree: true, attributes: true, characterData: false });
                    } catch (e) {
                        try { mo.observe(document.documentElement, { childList: true, subtree: true, attributes: true }); } catch (e) { }
                    }

                    // polling fallback to handle slow layout/async image loads
                    startPolling();
                    setTimeout(showHideButtons, 40);
                }

                function stopAutoScroll(reason) {
                    autoScrollActive = false;
                    if (mo) { try { mo.disconnect(); } catch (e) { } mo = null; }
                    stopPolling();
                    setTimeout(showHideButtons, 40);
                }

                // stop on user upward scroll or explicit interactions
                window.addEventListener('scroll', function () {
                    const sc = window.scrollY || window.pageYOffset || 0;
                    const delta = sc - lastScrollY;
                    if (autoScrollActive && delta < -2) stopAutoScroll('user-scrolled-up');
                    lastScrollY = sc;
                    showHideButtons();
                }, { passive: true });

                // wheel/touch/keyboard interruptions
                window.addEventListener('wheel', (e) => { if (autoScrollActive && e.deltaY < 0) stopAutoScroll('user-wheel-up'); }, { passive: true });
                window.addEventListener('touchstart', () => { if (autoScrollActive) stopAutoScroll('user-touch'); }, { passive: true });
                window.addEventListener('keydown', (e) => { if (!autoScrollActive) return; const upKeys = ['ArrowUp', 'PageUp', 'Home']; if (upKeys.includes(e.key)) stopAutoScroll('user-key-up'); }, true);

                window.addEventListener('resize', showHideButtons);
                setTimeout(showHideButtons, 120);

                toTop.addEventListener('click', function () { stopAutoScroll('user-request-top'); window.scrollTo({ top: 0, behavior: 'smooth' }); });

                toBottom.addEventListener('click', function () {
                    if (autoScrollActive) { stopAutoScroll('toggled-off'); return; }
                    startAutoScroll();
                });
            } catch (e) { /* ignore */ }
        })();
    </script>
    <script>
        // Trash / drag-drop helper for the number-picker popup
        (function () {
            const trashBtn = document.getElementById('trashBtn');
            const trashToggle = document.getElementById('trashToggle');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');

            if (!numberPickerPopup || !numberPickerTable || !trashBtn || !trashToggle) return;

            // create trash popup element and attach to document.body so it's not clipped
            const trashPopup = document.createElement('div');
            trashPopup.id = 'trashPopup';
            trashPopup.style.position = 'fixed';
            trashPopup.style.zIndex = '10001';
            // minimal UI: single numeric input for k (1..45). on submit it will compute and move numbers to trash.
            trashPopup.innerHTML = `
                <div style="padding:8px;display:flex;gap:8px;align-items:center;">
                    <label id="trashKLabel" style="font-weight:700;color:var(--text);display:inline-flex;align-items:center;height:32px;padding:0 4px 0 0;">ktrash:</label>
                    <div style="position:relative;display:inline-block;vertical-align:middle;">
                        <input id="trashKInput" type="number" min="1" max="39" step="1" value="3" style="width:56px;padding:6px 26px 6px 8px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);box-sizing:border-box;" />
                        <div style="position:absolute;right:4px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:2px;z-index:3;pointer-events:auto;width:22px;align-items:center;">
                            <button type="button" class="trash-k-up" title="Tăng 1" style="width:18px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;">▲</button>
                            <button type="button" class="trash-k-down" title="Giảm 1" style="width:18px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;">▼</button>
                        </div>
                    </div>
                </div>
                <div style="padding:6px 8px;max-height:calc(var(--trash-row-height,36px) * 15);overflow:visible;">
                    <table><tbody></tbody></table>
                </div>`;
            document.body.appendChild(trashPopup);

            // drag state for trash -> fallback restore when dragend occurs without drop
            let draggingFromTrash = null;
            let draggingNumber = null; // current number being dragged (from popup or trash)
            let lastDragClientX = 0;
            let lastDragClientY = 0;

            let trashEnabled = true;
            let trashItems = [];

            function setTrashButtonState() {
                trashBtn.classList.toggle('disabled', !trashEnabled);
                trashToggle.textContent = trashEnabled ? 'On' : 'Off';
            }

            trashToggle.addEventListener('click', (ev) => {
                trashEnabled = !trashEnabled;
                setTrashButtonState();
                // When trash is turned off, hide the trash popup and clear all trashed numbers.
                try {
                    if (!trashEnabled) {
                        // hide popup
                        trashPopup.style.display = 'none';
                        // clear tracked trash items
                        trashItems.length = 0;
                        // notify listeners that trash changed
                        try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        // remove in-trash class from any table cells
                        try {
                            const inTrashCells = numberPickerTable.querySelectorAll('td.in-trash');
                            inTrashCells.forEach(c => c.classList.remove('in-trash'));
                        } catch (innerErr) { /* ignore */ }
                        // re-render the (now-empty) trash popup
                        renderTrash();
                    }
                } catch (e) { /* ignore */ }
            });

            trashBtn.addEventListener('click', (ev) => {
                if (!trashEnabled) return; // only clickable when enabled
                trashPopup.style.display = (trashPopup.style.display === 'block') ? 'none' : 'block';
                adjustTrashPosition();
            });

            function adjustTrashPosition() {
                const sample = numberPickerTable.querySelector('tbody tr td');
                const cellW = sample ? Math.max(28, Math.round(sample.getBoundingClientRect().width)) : 80;
                const trashW = 3 * cellW + 80; // add extra width to avoid horizontal scrollbar
                const trashH = Math.round(trashW / 1.732);
                trashPopup.style.setProperty('--trash-width', trashW + 'px');
                trashPopup.style.width = trashW + 'px';
                trashPopup.style.height = trashH + 'px';

                // position relative to the picker popup but in viewport coords
                const pickerRect = numberPickerPopup.getBoundingClientRect();
                const gap = 12;
                // prefer left side if there's space, otherwise place on the right
                let left = pickerRect.left - trashW - gap;
                if (left < 4) left = pickerRect.right + gap; // place to right if not enough left space
                // ensure popup stays within viewport horizontally
                left = Math.max(4, Math.min(left, window.innerWidth - trashW - 4));
                // vertical: align near top of picker, but keep within viewport
                let top = pickerRect.top + 8;
                if (top + trashH > window.innerHeight - 8) top = Math.max(8, window.innerHeight - trashH - 8);
                trashPopup.style.left = left + 'px';
                trashPopup.style.top = top + 'px';
            }

            function renderTrash() {
                const tbody = trashPopup.querySelector('tbody');
                tbody.innerHTML = '';
                for (let i = 0; i < trashItems.length; i += 3) {
                    const tr = document.createElement('tr');
                    for (let j = 0; j < 3; j++) {
                        const idx = i + j;
                        const td = document.createElement('td');
                        if (idx < trashItems.length) {
                            const n = trashItems[idx];
                            td.className = 'trash-number';
                            td.dataset.number = String(n);
                            // try to clone inside markup if available, otherwise plain text
                            const src = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                            if (src) {
                                // preserve the exact inner markup (numbers, rank pills, spans)
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                // copy innerHTML so the nested spans and pills keep their classes
                                inner.innerHTML = src.innerHTML;
                                // copy relevant attributes from source td to trash td (except id)
                                try {
                                    for (const cls of Array.from(src.classList || [])) {
                                        if (!td.classList.contains(cls)) td.classList.add(cls);
                                    }
                                    // ensure trash-number class remains present
                                    if (!td.classList.contains('trash-number')) td.classList.add('trash-number');
                                    // copy inline style if present, but strip visual properties
                                    // (background/color/box-shadow/outline) so highlights
                                    // from the source don't override the trash popup visuals.
                                    const s = src.getAttribute('style');
                                    if (s) {
                                        try {
                                            let sanitized = String(s)
                                                .replace(/background[^;]*;?/gi, '')
                                                .replace(/color[^;]*;?/gi, '')
                                                .replace(/box-shadow[^;]*;?/gi, '')
                                                .replace(/outline[^;]*;?/gi, '')
                                                .replace(/border-color[^;]*;?/gi, '');
                                            if (sanitized.trim()) {
                                                td.setAttribute('style', (td.getAttribute('style') || '') + ';' + sanitized);
                                            }
                                        } catch (err) { /* ignore sanitize errors */ }
                                    }
                                } catch (err) { /* ignore */ }
                                td.appendChild(inner);
                            } else {
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                inner.textContent = String(n);
                                td.appendChild(inner);
                            }
                            td.draggable = true;
                            td.addEventListener('dragstart', (e) => {
                                e.dataTransfer.setData('text/plain', String(n));
                                e.dataTransfer.setData('source', 'trash');
                                e.dataTransfer.effectAllowed = 'move';
                            });
                            td.addEventListener('dblclick', () => { restoreFromTrash(n); });
                        } else {
                            td.innerHTML = '';
                        }
                        tr.appendChild(td);
                    }
                    tbody.appendChild(tr);
                }
                adjustTrashPosition();
                // After rendering trash cells update their tooltips (x<>y)
                try { updateTrashTooltips(); } catch (e) { /* ignore */ }
            }

            // Helper: read current average k (try header span, fallback to visible rows)
            function getCurrentAvgK() {
                try {
                    if (typeof window.__lastAvgK === 'number' && !Number.isNaN(window.__lastAvgK)) return window.__lastAvgK;
                } catch (e) { }
                try {
                    const tp = document.getElementById('trashPopup');
                    if (tp) {
                        const span = tp.querySelector('.avg-k');
                        if (span) {
                            const m = String(span.textContent || '').match(/([0-9]+(?:\.[0-9]+)?)/);
                            if (m) return Number(m[1]);
                        }
                    }
                } catch (e) { }
                // fallback: compute avg from full filtered rows (no scrolling) using row cache
                try {
                    const filtered = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                    const ks = filtered.map(r => {
                        try { return (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(r)) : NaN; } catch (e) { return NaN; }
                    }).filter(v => Number.isFinite(v));
                    if (!ks.length) return 0;
                    return ks.reduce((a, b) => a + b, 0) / ks.length;
                } catch (e) { return 0; }
            }

            // Return array of row objects matching current Cell5.5 filters (year/month/trash)
            window.getCell5_5FilteredRows = function () {
                try {
                    const section = document.getElementById('cell5_5');
                    if (!section) return rows.slice();
                    const controls = section.querySelector('.controls');
                    if (!controls) return rows.slice();
                    const selects = Array.from(controls.querySelectorAll('select'));
                    // selects order in renderCell5_5: [sortSel, yearSel, monthSel, (maybe) trashSel]
                    const yearSel = selects[1] || null;
                    const monthSel = selects[2] || null;
                    const trashSel = selects[3] || null;
                    const yearVal = yearSel ? yearSel.value : 'all';
                    const monthVal = monthSel ? monthSel.value : 'all';
                    const trashVal = trashSel ? trashSel.value : 'include';

                    // filter rows similar to buildCountsHtml/populateMonths
                    const filtered = rows.filter(r => {
                        try {
                            const s = String(r.date || '');
                            if (!s) return false;
                            if (yearVal && yearVal !== 'all') {
                                if (s.length < 4 || s.slice(-4) !== yearVal) return false;
                            }
                            if (monthVal && monthVal !== 'all') {
                                // parse dd/mm/yyyy or other common formats similar to renderCell5_5.parseDateSortable
                                let ts = 0;
                                let m1 = s.match(/^\s*(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s*$/);
                                if (m1) {
                                    let dd = Number(m1[1]), mm = Number(m1[2]), yy = Number(m1[3]);
                                    if (yy < 100) yy += 2000;
                                    const dt = new Date(yy, mm - 1, dd);
                                    if (!isNaN(dt)) ts = dt.getTime();
                                }
                                if (!ts) {
                                    const digits = s.replace(/\D/g, '');
                                    if (/^\d+$/.test(digits)) {
                                        if (digits.length === 8) {
                                            const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                                            const dt2 = new Date(yyyy, mm - 1, dd);
                                            if (!isNaN(dt2)) ts = dt2.getTime();
                                        } else {
                                            const d6 = digits.padStart(6, '0');
                                            const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy2 = 2000 + Number(d6.slice(4, 6));
                                            const dt3 = new Date(yy2, mm - 1, dd);
                                            if (!isNaN(dt3)) ts = dt3.getTime();
                                        }
                                    }
                                }
                                if (!ts) {
                                    const dtf = new Date(s);
                                    if (!isNaN(dtf)) ts = dtf.getTime();
                                }
                                if (!ts) return false;
                                const dtFinal = new Date(ts);
                                const m = String(dtFinal.getMonth() + 1).padStart(2, '0');
                                if (m !== monthVal) return false;
                            }
                            // if trashSel == 'exclude', filter out rows that do not contain any number currently in trash
                            if (trashVal === 'exclude') {
                                // when excluding, keep rows that DO NOT contain any trashed number
                                try {
                                    if (!Array.isArray(r.nums)) return true;
                                    for (const v of (r.nums || [])) if (trashItems.includes(Number(v))) return false;
                                } catch (e) { }
                            }
                            return true;
                        } catch (e) { return false; }
                    });
                    return filtered;
                } catch (e) { return rows.slice(); }
            };

            // Update tooltip (title) on each trash-number cell to show x<>y
            function updateTrashTooltips() {
                try {
                    const tp = document.getElementById('trashPopup');
                    if (!tp) return;
                    const avg = getCurrentAvgK();
                    const tds = Array.from(tp.querySelectorAll('td.trash-number'));
                    // get the full set of filtered rows (not just DOM-mounted pages)
                    const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                    for (const td of tds) {
                        try {
                            const n = Number(td.dataset.number);
                            if (!n) { td.removeAttribute('title'); continue; }
                            let x = 0, y = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const nums = rowObj.nums || [];
                                    const has = nums.some(v => Number(v) === n);
                                    if (!has) continue;
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) x++; else if (kVal > avg) y++;
                                } catch (e) { }
                            }
                            // store aggregated counts on a data attribute instead of `title`
                            td.setAttribute('data-agg', `${x}<>${y}`);
                            td.removeAttribute('title');
                        } catch (e) { /* per-td ignore */ }
                    }
                    // also update avg-k header span to show aggregate counts across visible rows
                    try {
                        const firstDiv = tp.querySelector('div');
                        if (firstDiv) {
                            const avgSpan = firstDiv.querySelector('.avg-k');
                            if (avgSpan) {
                                // compute aggregated x/y across filteredRows
                                let aggX = 0, aggY = 0;
                                for (const rowObj of filteredRows) {
                                    try {
                                        const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                        if (!Number.isFinite(kVal)) continue;
                                        if (kVal < avg) aggX++; else if (kVal > avg) aggY++;
                                    } catch (e) { }
                                }
                                // store aggregated counts on a data attribute to avoid native tooltip
                                avgSpan.setAttribute('data-agg', `${aggX}<>${aggY}`);
                                avgSpan.removeAttribute('title');
                                // ensure tooltip updates on hover: attach recompute handler once
                                try {
                                    if (!avgSpan.__aggTooltipBound) {
                                        avgSpan.addEventListener('mouseenter', (ev) => {
                                            try {
                                                // recompute against full filtered rows
                                                let ax = 0, ay = 0;
                                                const curFiltered = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                                                for (const r2 of curFiltered) {
                                                    try {
                                                        const kv = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(r2)) : NaN;
                                                        if (!Number.isFinite(kv)) continue;
                                                        if (kv < avg) ax++; else if (kv > avg) ay++;
                                                    } catch (ee) { }
                                                }
                                                // update data-agg for the styled tooltip fallback
                                                avgSpan.setAttribute('data-agg', `${ax}<>${ay}`);
                                            } catch (ee) { }
                                        });
                                        avgSpan.__aggTooltipBound = true;
                                        // make span focusable so tooltip can appear on keyboard focus too
                                        if (!avgSpan.hasAttribute('tabindex')) avgSpan.setAttribute('tabindex', '0');
                                    }
                                } catch (e) { }
                            }
                        }
                    } catch (e) { }
                } catch (e) { }
            }

            // Observe changes to Cell5.5 so tooltips recalc after user changes year/month or pages
            try {
                const cell55 = document.getElementById('cell5_5');
                if (cell55 && !cell55.__trashTooltipObserverAdded) {
                    const mo55 = new MutationObserver(() => { try { updateTrashTooltips(); } catch (e) { } });
                    mo55.observe(cell55, { childList: true, subtree: true, attributes: true });
                    cell55.__trashTooltipObserverAdded = true;
                }
            } catch (e) { }

            // Also recalc when trash content changes
            try { (document.getElementById('trashPopup') || document.body).addEventListener('trashchange', () => { try { updateTrashTooltips(); } catch (e) { } }); } catch (e) { }

            // Create floating tooltip element and delegated handlers as a robust fallback
            try {
                function ensureTrashAggTooltip() {
                    if (document.getElementById('trashAggTooltip')) return document.getElementById('trashAggTooltip');
                    const t = document.createElement('div');
                    t.id = 'trashAggTooltip';
                    t.style.position = 'fixed';
                    t.style.zIndex = 12000;
                    t.style.padding = '6px 8px';
                    t.style.borderRadius = '6px';
                    t.style.background = 'rgba(0,0,0,0.8)';
                    t.style.color = '#fff';
                    t.style.fontWeight = '700';
                    t.style.fontSize = '12px';
                    t.style.pointerEvents = 'none';
                    t.style.transition = 'opacity 0.12s';
                    t.style.opacity = '0';
                    t.style.whiteSpace = 'nowrap';
                    document.body.appendChild(t);
                    return t;
                }

                const aggTip = ensureTrashAggTooltip();

                let aggHideTimeout = null;
                let aggMoveHandler = null;
                function showAggTipAt(text, rect, followCursor = false) {
                    try {
                        aggTip.textContent = text;
                        aggTip.style.opacity = '1';
                        if (aggHideTimeout) { clearTimeout(aggHideTimeout); aggHideTimeout = null; }

                        // If requested, follow the cursor: install a document-level mousemove handler
                        if (followCursor) {
                            if (!aggMoveHandler) {
                                aggMoveHandler = (ev) => {
                                    try {
                                        const pad = 12;
                                        let left = ev.clientX + 12;
                                        let top = ev.clientY + 18;
                                        // prevent going offscreen horizontally
                                        if (left + aggTip.offsetWidth + 8 > window.innerWidth) left = ev.clientX - aggTip.offsetWidth - 12;
                                        if (left < 8) left = 8;
                                        // prevent going offscreen vertically
                                        if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = ev.clientY - aggTip.offsetHeight - 12;
                                        if (top < 8) top = 8;
                                        aggTip.style.left = Math.round(left) + 'px';
                                        aggTip.style.top = Math.round(top) + 'px';
                                    } catch (e) { }
                                };
                                document.addEventListener('mousemove', aggMoveHandler, true);
                            }
                            // position immediately based on provided rect or cursor fallback
                            if (rect && rect.left != null) {
                                aggTip.style.left = Math.round(rect.left + (rect.width / 2) - aggTip.offsetWidth / 2) + 'px';
                                let top = rect.bottom + 8;
                                if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = rect.top - aggTip.offsetHeight - 8;
                                aggTip.style.top = Math.round(top) + 'px';
                            }
                        } else {
                            // position relative to element rectangle (centered)
                            if (rect && rect.left != null) {
                                const pad = 8;
                                let left = Math.round(rect.left + (rect.width / 2) - aggTip.offsetWidth / 2);
                                if (Number.isNaN(left)) left = rect.left + pad;
                                left = Math.max(8, Math.min(left, window.innerWidth - aggTip.offsetWidth - 8));
                                let top = rect.bottom + 8;
                                if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = rect.top - aggTip.offsetHeight - 8;
                                aggTip.style.left = left + 'px';
                                aggTip.style.top = top + 'px';
                            }
                        }
                    } catch (e) { }
                }
                function hideAggTipSoon(delay = 100) {
                    try {
                        if (aggHideTimeout) { clearTimeout(aggHideTimeout); aggHideTimeout = null; }
                        // remove mousemove handler when hiding
                        if (aggMoveHandler) { try { document.removeEventListener('mousemove', aggMoveHandler, true); } catch (e) { } aggMoveHandler = null; }
                        if (!delay || Number(delay) <= 0) {
                            try { aggTip.style.opacity = '0'; } catch (e) { }
                        } else {
                            aggHideTimeout = setTimeout(() => { try { aggTip.style.opacity = '0'; } catch (e) { } }, Number(delay));
                        }
                    } catch (e) { }
                }

                document.addEventListener('mouseover', (ev) => {
                    try {
                        const td = ev.target.closest && ev.target.closest('td.trash-number');
                        const avgEl = ev.target.closest && ev.target.closest('#trashPopup > div:nth-child(1) > span');
                        if (td) {
                            // compute x<>y for this specific number
                            const n = Number(td.dataset.number);
                            if (!n) return;
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let x = 0, y = 0;
                            const avg = getCurrentAvgK();
                            for (const rowObj of filteredRows) {
                                try {
                                    const nums = rowObj.nums || [];
                                    const has = nums.some(v => Number(v) === n);
                                    if (!has) continue;
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) x++; else if (kVal > avg) y++;
                                } catch (e) { }
                            }
                            const rect = td.getBoundingClientRect();
                            showAggTipAt(`${x}<>${y}`, rect, true);
                            return;
                        }
                        if (avgEl) {
                            const avg = getCurrentAvgK();
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let aggX = 0, aggY = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) aggX++; else if (kVal > avg) aggY++;
                                } catch (e) { }
                            }
                            const rect = avgEl.getBoundingClientRect();
                            showAggTipAt(`${aggX}<>${aggY}`, rect, true);
                            return;
                        }
                    } catch (e) { }
                }, true);

                document.addEventListener('mouseout', (ev) => {
                    try {
                        const related = ev.relatedTarget;
                        const tgt = ev.target;
                        // if leaving to an element inside tooltip or same td/span, ignore
                        // keep tooltip while moving inside the specific header span or the floating tooltip
                        if (related && (related.closest && (related.closest('#trashPopup > div:nth-child(1) > span') || related.closest('#trashAggTooltip')))) return;
                        // if the pointer left the specific header span, hide immediately
                        if (tgt && tgt.closest && tgt.closest('#trashPopup > div:nth-child(1) > span')) {
                            hideAggTipSoon(0);
                        } else {
                            hideAggTipSoon();
                        }
                    } catch (e) { }
                }, true);

                // keyboard focus fallback
                document.addEventListener('focusin', (ev) => {
                    try {
                        const el = ev.target;
                        if (!el) return;
                        if (el.matches && el.matches('#trashPopup > div:nth-child(1) > span')) {
                            const rect = el.getBoundingClientRect();
                            const avg = getCurrentAvgK();
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let aggX = 0, aggY = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) aggX++; else if (kVal > avg) aggY++;
                                } catch (e) { }
                            }
                            showAggTipAt(`${aggX}<>${aggY}`, rect, true);
                        }
                    } catch (e) { }
                }, true);
                document.addEventListener('focusout', () => hideAggTipSoon(), true);
            } catch (e) { }

            function moveToTrash(n) {
                n = Number(n);
                if (!n || trashItems.includes(n)) return;
                const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                if (cell) cell.classList.add('in-trash');
                trashItems.push(n);
                renderTrash();
                // notify listeners that trash changed (do not auto-toggle user selectors)
                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                // also call section invalidate/group directly to ensure immediate update
                try {
                    const sec = document.getElementById('cell6_5');
                    if (sec && typeof sec.__invalidate === 'function') sec.__invalidate();
                    if (sec && typeof sec.__group === 'function') sec.__group();
                } catch (err) { }
            }

            function restoreFromTrash(n) {
                n = Number(n);
                const idx = trashItems.indexOf(n);
                if (idx === -1) return;
                trashItems.splice(idx, 1);
                const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                if (cell) cell.classList.remove('in-trash');
                renderTrash();
                // notify listeners that trash changed (do not auto-toggle user selectors)
                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                // also call section invalidate/group directly to ensure immediate update
                try {
                    const sec = document.getElementById('cell6_5');
                    if (sec && typeof sec.__invalidate === 'function') sec.__invalidate();
                    if (sec && typeof sec.__group === 'function') sec.__group();
                } catch (err) { }
            }

            // delegated dragstart to mark source for popup cells and track trash-origin
            document.addEventListener('dragstart', (e) => {
                try {
                    const td = e.target.closest('td');
                    if (!td) return;
                    const num = td.dataset && td.dataset.number ? td.dataset.number : (td.textContent || '').trim();
                    const parsed = parseInt(num);
                    if (!parsed) return;
                    const source = td.closest('#trashPopup') ? 'trash' : (td.closest('#numberPickerTable') ? 'popup' : 'other');
                    e.dataTransfer.setData('text/plain', String(parsed));
                    e.dataTransfer.setData('source', source);
                    e.dataTransfer.effectAllowed = 'move';
                    // track dragged number and whether it originated in the trash
                    draggingNumber = parsed;
                    if (source === 'trash') draggingFromTrash = parsed;
                    else draggingFromTrash = null;
                } catch (err) { }
            }, true);

            // allow drops everywhere so we can detect drops outside popup and record pointer position
            document.addEventListener('dragover', (e) => {
                try {
                    lastDragClientX = e.clientX || lastDragClientX;
                    lastDragClientY = e.clientY || lastDragClientY;
                } catch (err) { }
                e.preventDefault();
            }, true);

            document.addEventListener('drop', (e) => {
                try {
                    e.preventDefault();
                    const data = e.dataTransfer.getData('text/plain');
                    const source = e.dataTransfer.getData('source');
                    const num = parseInt(data);
                    if (!num) return;
                    const dropOnTrash = !!e.target.closest('#trashPopup');
                    const dropOnNumberTable = !!e.target.closest('#numberPickerTable');
                    const dropInsidePopup = !!e.target.closest('#numberPickerPopup');

                    if (dropOnTrash) {
                        if (source === 'popup') moveToTrash(num);
                        return;
                    }

                    if (dropOnNumberTable) {
                        if (source === 'trash') restoreFromTrash(num);
                        return;
                    }

                    // drop outside popup area:
                    // - if dragged FROM trash and dropped anywhere outside the trash, restore it back to the popup
                    // - if dragged FROM popup and dropped outside the popup, treat as move-to-trash (existing behavior)
                    if (!dropInsidePopup) {
                        if (source === 'trash') {
                            restoreFromTrash(num);
                            return;
                        }
                        if (trashEnabled && source === 'popup') {
                            moveToTrash(num);
                            return;
                        }
                    }
                } catch (err) { }
            }, true);

            // dragend fallback: if user dragged from trash but didn't drop over a restore target,
            // restore the item when drag ends outside the trash popup (fixes intermittent "stuck" behavior)
            document.addEventListener('dragend', (e) => {
                try {
                    if (!draggingFromTrash) return;
                    // prefer last known dragover coords, fallback to dragend client coords
                    const x = lastDragClientX || e.clientX || 0;
                    const y = lastDragClientY || e.clientY || 0;
                    const el = document.elementFromPoint(x, y);
                    const endedOverTrash = el && el.closest && el.closest('#trashPopup');
                    if (!endedOverTrash) {
                        // restore the item if drag ended outside the trash popup
                        restoreFromTrash(draggingFromTrash);
                    }
                } catch (err) { }
                draggingFromTrash = null;
            }, true);

            // When popup content regenerates, ensure positioning updates
            const mo = new MutationObserver(() => { adjustTrashPosition(); });
            mo.observe(numberPickerTable, { childList: true, subtree: true });
            window.addEventListener('resize', adjustTrashPosition);
            window.addEventListener('scroll', adjustTrashPosition, true);

            // initial state
            setTrashButtonState();
            renderTrash();

            // helper: get unique numbers present in the popup table
            function getPopupNumbers() {
                try {
                    const nodes = Array.from(numberPickerTable.querySelectorAll('td[data-number]'));
                    const nums = nodes.map(n => Number(n.dataset.number)).filter(n => Number.isInteger(n) && n >= 1 && n <= 45);
                    return Array.from(new Set(nums)).sort((a, b) => a - b);
                } catch (e) { return []; }
            }

            // compute best k-number removal (exact when combos small, greedy otherwise)
            function computeBestRemoval(k) {
                k = Number(k) || 0; if (k < 1) return null;
                const filtered = rows.slice();
                const total = filtered.length;
                if (!total) return { total: 0, remaining: 0, pages: 0, chosen: [], excludedCount: 0 };

                // build number -> set(rowIndex)
                const pool = getPopupNumbers();
                const poolSet = new Set(pool);
                const numToRows = new Map();
                filtered.forEach((r, idx) => {
                    const nums = r.nums || [];
                    for (let t = 0; t < nums.length; t++) {
                        const v = Number(nums[t]);
                        if (!poolSet.has(v)) continue;
                        if (!numToRows.has(v)) numToRows.set(v, new Set());
                        numToRows.get(v).add(idx);
                    }
                });

                if (pool.length <= k) {
                    const union = new Set();
                    pool.forEach(p => { const s = numToRows.get(p); if (s) for (const i of s) union.add(i); });
                    const excluded = union.size;
                    return { total, remaining: total - excluded, pages: Math.ceil((total - excluded) / 20), chosen: pool.slice(), excludedCount: excluded };
                }

                const comb = (n, r) => { if (r > n) return 0; let res = 1; for (let i = 1; i <= r; i++) { res = res * (n - (r - i)) / i; } return Math.round(res); };
                const combos = comb(pool.length, k);
                const MAX_EXACT = 200000;
                let best = { remaining: -1, chosen: [], excludedCount: 0 };

                if (combos <= MAX_EXACT) {
                    // exact backtrack
                    const idxPool = pool;
                    const stack = [];
                    function backtrack(start) {
                        if (stack.length === k) {
                            const union = new Set();
                            for (const p of stack) {
                                const s = numToRows.get(p);
                                if (s) for (const i of s) union.add(i);
                            }
                            const excluded = union.size; const remaining = total - excluded;
                            if (remaining > best.remaining) best = { remaining, chosen: stack.slice(), excludedCount: excluded };
                            return;
                        }
                        for (let i = start; i < idxPool.length; i++) { stack.push(idxPool[i]); backtrack(i + 1); stack.pop(); }
                    }
                    backtrack(0);
                } else {
                    // greedy approximate: pick candidates that cover fewest new rows
                    const available = new Set(pool);
                    const chosen = [];
                    const excludedSet = new Set();
                    for (let step = 0; step < k; step++) {
                        let bestChoice = null, bestMarginal = Infinity;
                        for (const candidate of Array.from(available)) {
                            const s = numToRows.get(candidate);
                            if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                            let marginal = 0; for (const idx of s) if (!excludedSet.has(idx)) marginal++;
                            if (marginal < bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                        }
                        if (bestChoice === null) break;
                        const s2 = numToRows.get(bestChoice); if (s2) for (const i of s2) excludedSet.add(i);
                        chosen.push(bestChoice); available.delete(bestChoice);
                    }
                    best = { remaining: total - excludedSet.size, chosen, excludedCount: excludedSet.size };
                }

                return { total, remaining: best.remaining, pages: Math.ceil(best.remaining / 20), chosen: best.chosen, excludedCount: best.excludedCount };
            }

            // wire input: when user enters k and presses Enter or blurs, compute and move chosen numbers to trash
            (function wireTrashInput() {
                try {
                    const kInput = trashPopup.querySelector('#trashKInput');
                    if (!kInput) return;
                    const doComputeAndMove = async () => {
                        let k = parseInt(kInput.value, 10);
                        if (!Number.isInteger(k) || k < 1) { k = 1; kInput.value = '1'; }
                        if (k > 39) { k = 39; kInput.value = '39'; }
                        // compute
                        const res = computeBestRemoval(k);
                        // clear existing trash items first (replace behavior)
                        try {
                            if (trashItems && trashItems.length) {
                                // remove in-trash class from popup cells
                                try {
                                    for (const old of trashItems.slice()) {
                                        const c = numberPickerTable.querySelector('td[data-number="' + old + '"]');
                                        if (c) c.classList.remove('in-trash');
                                    }
                                } catch (e) { }
                                trashItems.length = 0;
                                renderTrash();
                                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                            }
                        } catch (e) { }
                        if (res && Array.isArray(res.chosen) && res.chosen.length) {
                            for (const n of res.chosen) {
                                try { moveToTrash(n); } catch (e) { }
                            }
                        }
                    };
                    kInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { ev.preventDefault(); doComputeAndMove(); } });
                    kInput.addEventListener('change', () => { doComputeAndMove(); });

                    // wire spinner buttons: wrap between 1 and 39 and trigger change
                    try {
                        const up = trashPopup.querySelector('.trash-k-up');
                        const down = trashPopup.querySelector('.trash-k-down');
                        const MIN_K = 1, MAX_K = 39;
                        if (up) up.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(kInput.value, 10);
                            if (!Number.isInteger(v)) v = 0; // default to 0 when empty
                            v = v + 1;
                            if (v > MAX_K) v = MIN_K; // wrap
                            kInput.value = String(v);
                            try { doComputeAndMove(); } catch (e) { kInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        });
                        if (down) down.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(kInput.value, 10);
                            if (!Number.isInteger(v)) v = 0; // default to 0 when empty
                            v = v - 1;
                            if (v < MIN_K) v = MAX_K; // wrap
                            kInput.value = String(v);
                            try { doComputeAndMove(); } catch (e) { kInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        });
                    } catch (err) { /* ignore spinner wiring errors */ }
                } catch (e) { }
            })();
            // double-click on trash popup: read clipboard and append valid numbers (tolerant parser)
            trashPopup.addEventListener('dblclick', async (ev) => {
                try {
                    if (!trashEnabled) return;
                    // Ignore dblclicks that originate from UI controls (buttons/inputs/selects)
                    // This prevents spinner clicks or other control interactions from
                    // accidentally triggering the paste/clipboard prompt.
                    try {
                        if (ev.target && (ev.target.closest('button') || ev.target.closest('input') || ev.target.closest('select'))) return;
                    } catch (ee) { }

                    const processText = (text) => {
                        if (!text) return;
                        const parts = String(text).split(/[^0-9]+/).filter(Boolean);
                        if (parts.length === 0) return;
                        const nums = parts.map(s => parseInt(s, 10)).filter(n => Number.isInteger(n) && n >= 1 && n <= 45);
                        if (nums.length === 0) return;
                        const unique = Array.from(new Set(nums));
                        for (const n of unique) {
                            try { moveToTrash(n); } catch (e) { }
                        }
                    };

                    // try modern clipboard API first
                    let text = '';
                    let clipboardTried = false;
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            clipboardTried = true;
                            text = await navigator.clipboard.readText();
                        }
                    } catch (err) { clipboardTried = true; text = ''; }

                    if (text) {
                        processText(text);
                        return;
                    }

                    // If clipboard read failed or empty, show a visible paste UI so user can paste (or retry clipboard)
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.zIndex = 10002;
                    overlay.style.left = '50%';
                    overlay.style.top = '50%';
                    overlay.style.transform = 'translate(-50%,-50%)';
                    overlay.style.background = 'white';
                    overlay.style.border = '2px solid #888';
                    overlay.style.padding = '10px';
                    overlay.style.borderRadius = '8px';
                    overlay.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                    overlay.setAttribute('role', 'dialog');

                    const msg = document.createElement('div');
                    msg.style.marginBottom = '8px';
                    msg.style.color = '#111';
                    msg.textContent = 'Paste numbers here (e.g. 1,2,3) or click "Use clipboard"';
                    const ta = document.createElement('textarea');
                    ta.style.width = '320px';
                    ta.style.height = '80px';
                    ta.style.fontSize = '14px';
                    ta.style.padding = '6px';
                    ta.placeholder = 'Paste (Ctrl+V) or type numbers then press Ctrl+Enter';

                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.marginTop = '8px';

                    const useBtn = document.createElement('button');
                    useBtn.textContent = 'Use clipboard';
                    useBtn.className = 'ghost';
                    const submitBtn = document.createElement('button');
                    submitBtn.textContent = 'Submit';
                    submitBtn.className = 'primary';
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.className = 'clear-btn';

                    row.appendChild(useBtn);
                    row.appendChild(submitBtn);
                    row.appendChild(cancelBtn);

                    overlay.appendChild(msg);
                    overlay.appendChild(ta);
                    overlay.appendChild(row);
                    document.body.appendChild(overlay);
                    ta.focus();

                    let resolved = false;
                    const clean = (v) => {
                        if (resolved) return; resolved = true;
                        try { overlay.remove(); } catch (e) { }
                        if (v) processText(v);
                    };

                    useBtn.addEventListener('click', async () => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                const t = await navigator.clipboard.readText();
                                if (t) { clean(t); return; }
                                alert('Clipboard is empty or not available. Please paste manually.');
                            } else {
                                alert('Clipboard API not available. Please paste manually.');
                            }
                        } catch (e) { alert('Cannot read clipboard. Please paste manually.'); }
                    });

                    submitBtn.addEventListener('click', () => { clean(ta.value || ''); });
                    cancelBtn.addEventListener('click', () => { clean(''); });

                    ta.addEventListener('paste', (e) => {
                        try {
                            e.preventDefault();
                            const d = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : null;
                            if (d) clean(String(d));
                            else setTimeout(() => clean(ta.value || ''), 50);
                        } catch (err) { clean(''); }
                    }, { once: true });

                    ta.addEventListener('keydown', (e) => {
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            clean(ta.value || '');
                        }
                    });

                    // auto-remove after 12s if user doesn't act
                    setTimeout(() => { clean(''); }, 12000);
                } catch (err) { /* ignore overall */ }
            });
            // expose current trash items via a safe global getter for other sections (Cell5.5 uses this)
            try { window.getTrashItems = function () { return trashItems.slice(); }; window.__trashItems = trashItems; } catch (e) { /* ignore */ }

            // Shift-key toggle: when the main number picker popup is open, pressing
            // and releasing the Shift key will toggle the visibility of the trash popup.
            // Only active when trash is enabled and when the picker popup is visible.
            function isPickerOpen() {
                try {
                    if (!numberPickerPopup) return false;
                    if (numberPickerPopup.classList && numberPickerPopup.classList.contains('show')) return true;
                    if (numberPickerPopup.style && numberPickerPopup.style.display === 'block') return true;
                    return getComputedStyle(numberPickerPopup).display !== 'none';
                } catch (e) { return false; }
            }

            function onShiftKeyUp(e) {
                try {
                    if (e.key !== 'Shift') return;
                    if (!isPickerOpen()) return; // only when main popup is open
                    if (!trashEnabled) return; // respect trash enabled state
                    // toggle
                    const wasVisible = trashPopup.style.display === 'block';
                    const nowVisible = wasVisible ? 'none' : 'block';
                    trashPopup.style.display = nowVisible;
                    if (nowVisible === 'block') adjustTrashPosition();

                    // Copy numbers in the trash popup to clipboard in form a,b,c,...
                    // Only copy when Shift action closed the trash popup (nowVisible === 'none')
                    try {
                        if (nowVisible === 'none') {
                            // Use the tracked trashItems (keeps original order)
                            const nums = Array.isArray(trashItems) ? trashItems.slice() : [];
                            const csv = nums.join(',');
                            if (csv.length > 0) {
                                if (navigator.clipboard && navigator.clipboard.writeText) {
                                    navigator.clipboard.writeText(csv).catch(() => {
                                        // fallback to execCommand
                                        const ta = document.createElement('textarea');
                                        ta.value = csv;
                                        document.body.appendChild(ta);
                                        ta.select();
                                        try { document.execCommand('copy'); } catch (e) { }
                                        ta.remove();
                                    });
                                } else {
                                    const ta = document.createElement('textarea');
                                    ta.value = csv;
                                    document.body.appendChild(ta);
                                    ta.select();
                                    try { document.execCommand('copy'); } catch (e) { }
                                    ta.remove();
                                }
                            }
                        }
                    } catch (copyErr) { /* ignore clipboard errors */ }
                } catch (err) { /* ignore */ }
            }
            window.addEventListener('keyup', onShiftKeyUp, true);
        })();
    </script>
    </script>
    <!-- Instant floating tooltip for Cell5.5 / Cell6.5 / Cell6.6 rows: appears immediately and follows the cursor -->
    <script>
        (function () {
            const tooltip = document.createElement('div');
            tooltip.id = 'instantTooltip';
            tooltip.style.cssText = 'position:fixed;pointer-events:none;padding:6px 8px;background:rgba(0,0,0,0.85);color:#fff;border-radius:6px;font-size:13px;z-index:99999;display:none;white-space:nowrap;';
            document.body.appendChild(tooltip);

            let activeTr = null;
            let moveHandler = null;

            function positionClient(e) {
                const pad = 12;
                const w = tooltip.offsetWidth || 80;
                const h = tooltip.offsetHeight || 20;
                let x = e.clientX + 12;
                let y = e.clientY + 12;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                if (x + w + pad > vw) x = Math.max(8, e.clientX - w - 12);
                if (y + h + pad > vh) y = Math.max(8, e.clientY - h - 12);
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function showTooltipFor(e, tr) {
                if (!tr) return;
                activeTr = tr;
                // strip native title to avoid browser delay
                if (tr.getAttribute('title')) {
                    tr.dataset._origTitle = tr.getAttribute('title');
                    tr.removeAttribute('title');
                }
                const k = tr.getAttribute('data-k') || tr.dataset.k;
                tooltip.textContent = k ? `k=${k}` : (tr.dataset._origTitle || '');
                tooltip.style.display = 'block';
                positionClient(e);
                if (!moveHandler) {
                    moveHandler = (ev) => { if (activeTr) positionClient(ev); };
                    document.addEventListener('mousemove', moveHandler);
                }
            }

            function hideTooltip() {
                tooltip.style.display = 'none';
                activeTr = null;
                if (moveHandler) { document.removeEventListener('mousemove', moveHandler); moveHandler = null; }
            }

            // Delegated mouseover / mouseout to detect rows with data-k in the three cells
            document.addEventListener('mouseover', function (ev) {
                try {
                    const tr = ev.target && ev.target.closest && ev.target.closest('tr[data-result][data-k]');
                    if (!tr) return;
                    const container = tr.closest && tr.closest('#cell5_5, #cell6_5, #cell6_6, #cell7, #cell8, #cell9, #cell11');
                    if (container) showTooltipFor(ev, tr);
                } catch (e) {/* ignore */ }
            }, true);

            document.addEventListener('mouseout', function (ev) {
                try {
                    const tr = ev.target && ev.target.closest && ev.target.closest('tr[data-result][data-k]');
                    if (!tr) return;
                    const related = ev.relatedTarget;
                    if (related && tr.contains && tr.contains(related)) return;
                    const container = tr.closest && tr.closest('#cell5_5, #cell6_5, #cell6_6, #cell7, #cell8, #cell9, #cell11');
                    if (container) hideTooltip();
                } catch (e) {/* ignore */ }
            }, true);

            // Hide on scroll/blur to avoid stuck tooltip
            document.addEventListener('scroll', hideTooltip, true);
            window.addEventListener('blur', hideTooltip);

            // Strip native title attributes for existing and newly-added rows in the three containers
            const containers = ['cell5_5', 'cell6_5', 'cell6_6', 'cell7', 'cell8', 'cell9', 'cell11'].map(id => document.getElementById(id)).filter(Boolean);
            for (const c of containers) {
                try { c.querySelectorAll && c.querySelectorAll('tr[title]').forEach(el => { el.dataset._origTitle = el.getAttribute('title'); el.removeAttribute('title'); }); } catch (e) { }
                const mo = new MutationObserver(records => {
                    for (const r of records) {
                        r.addedNodes && r.addedNodes.forEach(node => {
                            try {
                                if (node.querySelectorAll) node.querySelectorAll('tr[title]').forEach(el => { el.dataset._origTitle = el.getAttribute('title'); el.removeAttribute('title'); });
                                if (node.matches && node.matches('tr[title]')) { node.dataset._origTitle = node.getAttribute('title'); node.removeAttribute('title'); }
                            } catch (e) {/* ignore */ }
                        });
                    }
                });
                mo.observe(c, { childList: true, subtree: true });
            }
        })();
    </script>
</body>

</html>
