<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life Notebook ‚Üí Web</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #94a3b8;
            --accent: #38ef7d;
            --accent-2: #667eea;
            --border: #1e293b;
            --card: #0b1220;
            --text: #e2e8f0;
            --text-strong: #fff;
            --highlight-bg: #4CAF50;
            --highlight-text: #0b1220;
            /* Canvas connection line color for dark mode */
            --connection-line-color: #ff5722;
            /* deep orange - contrasts with dark bg and yellow cells */
        }

        [data-theme="light"] {
            --bg: #f8f9ff;
            --panel: #ffffff;
            --muted: #666;
            --accent: #38ef7d;
            --accent-2: #11998e;
            --border: #eee;
            --card: #fafafa;
            --text: #333;
            --text-strong: #000;
            --highlight-bg: #4CAF50;
            --highlight-text: #fff;
            /* Canvas connection line color for light mode */
            --connection-line-color: #00cc00;
            /* keep green in light theme */
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }

        [data-theme="dark"] body {
            background: radial-gradient(circle at 20% 20%, rgba(56, 239, 125, 0.08), transparent 35%),
                radial-gradient(circle at 80% 10%, rgba(102, 126, 234, 0.12), transparent 40%),
                var(--bg);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }

        [data-theme="light"] header {
            background: rgba(248, 250, 252, 0.9);
        }

        .theme-toggle {
            margin-left: auto;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .topbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand span {
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border-radius: 8px;
            font-size: 12px;
            color: var(--highlight-text);
            font-weight: 900;
            cursor: pointer;
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }

        .brand span:hover {
            transform: scale(1.05);
        }

        /* Number Picker Popup and Place Boxes (copied from index.html) */
        .number-picker-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 500px;
            max-height: 800px;
            /* increased to reduce internal scrolling when mode wraps */
            overflow-y: auto;
            left: 0;
            top: 0;
            cursor: move;
            transform-origin: top left;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            opacity: 0;
        }

        .popup-scale-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            display: none;
            background: var(--accent);
            border: 1px solid var(--accent-2);
            opacity: 0.7;
        }

        .popup-scale-handle.visible {
            display: block;
        }

        .number-picker-popup * {
            cursor: default;
        }

        .number-picker-popup .popup-scale-handle {
            cursor: nwse-resize !important;
        }

        [data-theme="dark"] .number-picker-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .number-picker-popup.show {
            display: block;
            opacity: 1;
        }

        /* Inline opacity control placed next to Œ£ */
        .inline-opacity-container {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        .inline-opacity-container input[type="range"] {
            width: 100px;
            max-width: 100%;
            height: 6px;
            accent-color: var(--accent);
        }

        /* Smaller slider when placed inside compact mode rows/selectors */
        .mode-rows .inline-opacity-container input[type="range"],
        .mode-selector .inline-opacity-container input[type="range"] {
            width: 72px;
        }

        .inline-opacity-container .inline-percent {
            min-width: 36px;
            font-weight: 800;
            font-size: 13px;
            color: var(--text-strong);
        }

        .number-picker-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .number-picker-table th {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: center;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table th.label-cell {
            cursor: grab;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            color: white;
        }

        .number-picker-table th.label-cell:active {
            cursor: grabbing;
        }

        .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        .number-picker-table th:nth-child(3) {
            border-right: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset -3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table th:nth-child(4) {
            border-left: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset 3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table td:active {
            cursor: grabbing;
        }

        [data-theme="light"] .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
        }

        [data-theme="light"] .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table th:nth-child(3) {
            border-right: 3px solid #11998e !important;
            box-shadow: inset -3px 0 0 0 #11998e;
        }

        [data-theme="light"] .number-picker-table th:nth-child(4) {
            border-left: 3px solid #11998e !important;
            box-shadow: inset 3px 0 0 0 #11998e;
        }

        .number-picker-table td:hover {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
            color: var(--highlight-text);
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
        }

        /* Highlighted numbers (when placed or hovered via quick-place)
           Use the same (day.html) "placed" visual: a solid/soft green fill
           rather than the gradient. This matches the place-box.filled style. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number {
            /* Use dark placed-background from day.html */
            background: #1a2a3a !important;
            /* Do not set a global text color on the cell so rank badges keep their own color.
               Color for the main number is applied to the number span below. */
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        /* Target only the main number span inside the cell; exclude rank badge spans */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number>span:not(.rank-in-cell) {
            color: #00ff00 !important;
            font-weight: 900;
        }

        #numberPickerPopup #numberPickerTable td.disabled {
            opacity: 1;
            cursor: not-allowed;
            background: #1a2a3a !important;
            pointer-events: none;
            /* avoid changing all nested text color (rank badges must keep their own color) */
            font-weight: 700 !important;
        }

        /* For disabled cells, color only the displayed number span (not the rank badge) */
        #numberPickerPopup #numberPickerTable td.disabled>span:not(.rank-in-cell) {
            color: #00ff00 !important;
        }

        /* If a disabled cell is also selected/placed, show the selected highlight instead
           (override the darker disabled styling). This ensures dragging a number into a place
           will display the same accent highlight as hover/selection and will be cleared
           by the normal highlight-sync logic. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number,
        #numberPickerPopup #numberPickerTable td.selected-number.disabled,
        #numberPickerPopup #numberPickerTable td.number-cell.disabled.selected-number {
            background: #1a2a3a !important;
            color: #00ff00 !important;
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        [data-theme="light"] #numberPickerPopup #numberPickerTable td.disabled {
            background: #e8f4f8 !important;
            color: #1a1a1a !important;
        }

        /* Apply bright label-cell style when column has values */
        .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        [data-theme="light"] .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Dim label cells that don't have values */
        .number-picker-table tfoot:not(.disabled) th.label-cell:not(.with-values) {
            opacity: 0.3 !important;
            pointer-events: none !important;
        }

        .number-picker-table tbody.disabled,
        .number-picker-table tfoot.disabled {
            pointer-events: none;
            opacity: 0.3;
            position: relative;
        }

        .number-picker-table tbody.disabled::after,
        .number-picker-table tfoot.disabled::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.03) 10px,
                    rgba(0, 0, 0, 0.03) 20px);
            pointer-events: none;
        }

        [data-theme="dark"] .number-picker-table tbody.disabled::after,
        [data-theme="dark"] .number-picker-table tfoot.disabled::after {
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px);
        }

        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 60px;
            height: 60px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: var(--accent);
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 4px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        .image-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
        }

        [data-theme="dark"] .image-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .image-popup.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        .image-popup img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            border-radius: 8px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .image-popup img {
                max-width: 200px;
                max-height: 200px;
            }
        }

        nav {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .nav-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn.active {
            border-color: var(--accent);
            color: var(--highlight-text);
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            font-weight: 800;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
        }

        section h2 {
            margin: 0 0 12px;
            color: var(--text-strong);
            letter-spacing: 0.3px;
        }

        section p.lead {
            margin: 6px 0 16px;
            color: var(--muted);
        }

        .card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .card {
            background: var(--card);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 14px;
        }

        select,
        input,
        button {
            border-radius: 10px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            font-size: 13px;
        }

        select:focus,
        input:focus {
            outline: 1px solid var(--accent);
        }

        /* Hide number input spinner arrows */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100());
            border: none;
            color: var(--highlight-text);
            font-weight: 700;
            cursor: pointer;
        }

        button.ghost {
            background: var(--card);
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        [data-theme="dark"] table {
            background: var(--panel);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            z-index: 1;
        }

        th {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        th:last-child {
            border-right: none;
        }

        td {
            padding: 5px 6px;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        [data-theme="dark"] td {
            border-color: var(--border);
        }

        td:last-child {
            border-right: none;
        }

        tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        tbody tr:nth-child(odd) {
            background: white;
        }

        [data-theme="dark"] tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        [data-theme="dark"] tbody tr:nth-child(odd) {
            background: transparent;
        }

        tbody tr:hover {
            background: #ffe6b3 !important;
        }

        [data-theme="dark"] tbody tr:hover {
            background: rgba(255, 230, 179, 0.2) !important;
        }

        /* Keep top ranks in Cell4 readable on dark theme */
        [data-theme="dark"] #cell4 tbody tr.rank-top td {
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr.rank-top .pill {
            background: #fffbea;
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr:nth-child(n+4) td[style*="background:linear-gradient"] {
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.15) 0%, rgba(56, 239, 125, 0.25) 100%) !important;
            color: #fff !important;
        }

        .pill {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: #e6f4ea;
            color: #0b8a60;
            white-space: nowrap;
            margin: 1px;
            font-family: monospace;
        }

        /* Euclid small framed pills (orange) */
        .euclid-pill {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            /* single soft orange for lower glare */
            background: #f8f333;
            color: #000;
            white-space: nowrap;
            margin: 0 1px 0 0;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }

        .euclid-pill.empty {
            opacity: 0.45;
        }

        .euclid-total-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 2px 5px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 800;
            background: #38ef7d;
            color: #072018;
            margin-left: 3px;
            font-family: monospace;
            min-width: 38px;
            text-align: center;
        }

        .label-chip {
            display: inline-block;
            min-width: 18px;
            padding: 2px 5px;
            margin: 1px 2px 1px 0;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-weight: 700;
            background: transparent;
            color: inherit;
        }

        .label-chip.highlight {
            background: var(--highlight-bg);
            color: var(--highlight-text);
        }

        [data-theme="dark"] .pill {
            background: rgba(56, 239, 125, 0.15);
            color: #38ef7d;
        }

        /* Prevent pill containers from wrapping */
        td:has(.pill) {
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .pill {
                font-size: 10px;
                padding: 2px 5px;
                margin: 1px;
            }

            th,
            td {
                padding: 4px 6px;
                font-size: 11px;
            }
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid>* {
            flex: 1 1 350px;
            min-width: 0;
        }

        .grid-centered {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .grid-centered>* {
            flex: 0 1 calc(33.333% - 10px);
            max-width: 600px;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            .grid>* {
                flex: 1 1 100%;
            }

            .grid-centered>* {
                flex: 1 1 100%;
                max-width: none;
            }
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            padding: 3px 8px;
            border-radius: 8px;
            background: var(--accent-2);
            color: white;
            font-weight: 700;
            font-size: 12px;
            opacity: 0.9;
        }

        main {
            padding: 16px 12px 32px;
        }

        section {
            margin: 20px 0;
            padding: 16px;
        }

        /* Performance: skip rendering offscreen content like large apps do */
        section {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 800px 600px;
        }

        .card {
            content-visibility: auto;
            contain: content;
        }

        /* Marker for cards nested inside "card-inner" wrappers.
           JS will add the class 'card-inner-child' to any .card inside .card.card-inner.
           Use this selector to style inner cards separately. */
        .card-inner-child {
            /* empty by default; add overrides as needed */
            box-sizing: border-box;
            /* harmless default to avoid empty-selector warning */
        }

        /* Layout rule: make the inner wrapper a flex container so we can
           enforce max 2 child cards per row. Each child gets up to 50%
           width and will be centered when it's the only child. */
        .card.card-inner {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-start;
        }

        .card.card-inner>.card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* Some renderers create .card elements nested deeper than direct children.
           Ensure any descendant marked with .card-inner-child gets the same sizing. */
        .card.card-inner .card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* When a .card.card-inner contains exactly one inner card, center that
           inner card horizontally and allow it to size to its content (up to
           the wrapper width). This centers narrow tables while still allowing
           wider tables to grow up to the container. */
        .card.card-inner.single-child {
            justify-content: center;
        }

        .card.card-inner.single-child .card-inner-child {
            flex: 0 1 auto !important;
            max-width: 100% !important;
            width: auto !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* Prefer intrinsic table width inside a centered single child; allow
           the table to grow up to the wrapper width but not force 100% width. */
        .card.card-inner.single-child .card-inner-child table {
            width: auto !important;
            max-width: 100% !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* If a wrapper contains a single child, center it horizontally */
        .card.card-inner>.card-inner-child:only-child {
            margin-left: auto;
            margin-right: auto;
        }

        /* Small screens: stack to single column */
        @media (max-width: 768px) {
            .card.card-inner>.card-inner-child {
                flex: 0 0 100%;
                max-width: 100%;
            }
        }

        /* Reduce paint/layout when card bodies are offscreen */
        .card-body {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 200px 120px;
        }

        @media (min-width: 768px) {
            main {
                padding: 24px 18px 48px;
            }

            section {
                margin: 32px 0;
                padding: 22px;
            }
        }

        .error {
            color: #fca5a5;
            font-weight: 600;
        }

        .success {
            color: #34d399;
            font-weight: 700;
        }

        .loader {
            text-align: center;
            color: var(--muted);
            padding: 16px 0;
        }

        .flex {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        a.anchor {
            color: inherit;
            text-decoration: none;
        }

        .hidden {
            display: none;
        }

        /* Flash highlight after copying a row */
        tr.copied-row {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Floating scroll-to-top button */
        #scrollToTop {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToTop:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToTop:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #scrollToTop {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }

        /* Close button for number picker popup */
        .number-picker-close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255, 67, 67, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .number-picker-close-btn:hover {
            background: rgba(255, 67, 67, 1);
            transform: scale(1.1);
        }

        .number-picker-close-btn:active {
            transform: scale(0.95);
        }

        /* Canvas overlay for drawing connections */
        #connectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Make controls inside Cell8/9/10/11 stick under the header when scrolling.
           Keep them in normal flow so they match other sections visually.
        */
        #cell8 .controls,
        #cell9 .controls,
        #cell10 .controls,
        #cell11 .controls {
            position: sticky;
            top: 64px;
            /* space for sticky header */
            z-index: 11;
            /* blue-gray ‚Üí dark-gray gradient to match normal section look */
            background: linear-gradient(135deg, #334155 0%, #1f2937 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px 12px;
            margin: 0 0 14px 0;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        /* Mode selector two-row layout + swap control */
        .mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .mode-rows {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-row {
            display: flex;
            gap: 8px;
            align-items: center;
            /* Keep controls on a single row; allow horizontal scroll when space is tight */
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .mode-rows.reversed {
            flex-direction: column-reverse;
        }

        #swapRowsBtn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
        }

        /* === Exact place styles copied from day.html to match visuals === */
        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 60px;
            height: 60px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: var(--accent);
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 4px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        /* === End copied styles === */
    </style>
</head>

<body>
    <header>
        <div class="topbar">
            <div class="brand">Life Notebook
                <span id="htmlBadge">HTML</span>
            </div>
            <nav id="nav"></nav>
            <button class="theme-toggle" id="themeToggle" title="Chuy·ªÉn giao di·ªán">üåì</button>
        </div>
    </header>
    <div class="image-popup" id="imagePopup">
        <img src="anh.png" alt="Preview">
    </div>
    <!-- Number Picker Popup (copied from index.html) -->
    <div class="number-picker-popup" id="numberPickerPopup">
        <button class="number-picker-close-btn" id="closeNumberPickerBtn" title="ƒê√≥ng">‚úï</button>
        <table class="number-picker-table" id="numberPickerTable">
            <!-- Generated by JS -->
        </table>
        <div class="place-container">
            <div class="places-grid" id="placesGrid">
                <!-- Generated by JS: 6 place boxes V1-V6 -->
            </div>
        </div>
        <div class="mode-selector" id="modeSelectorContainer">
            <div class="mode-rows reversed" id="modeRows">
                <div class="mode-row" id="modeRowTop">
                    <label style="font-size: 12px;">Mode:</label>
                    <button id="modeSelector"
                        style="width: 100px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);">S·ªë
                        (1-45)</button>
                    <button id="clearPlaceBtn" class="clear-btn" title="X√≥a to√†n b·ªô place"
                        style="padding: 6px 10px; font-size: 12px;">X√≥a</button>
                    <label style="margin-left:6px;font-size:12px;">Rank:</label>
                    <button id="rankToggle"
                        style="width:80px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">rank</button>
                    <label style="margin-left:6px;font-size:12px;">Hover:</label>
                    <button id="quickPlaceToggle"
                        style="width:auto;min-width:48px;font-size:11px;padding:6px 4px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);box-sizing:border-box;max-width:100%;"
                        title="Toggle hover mode: 'Normal' = dblclick copies; 'Hover' = hover fills places">Normal</button>
                </div>
                <div class="mode-row" id="modeRowBottom">
                    <label style="margin-left: 6px; font-size: 12px;" id="connectionToggleLabel">N·ªëi:</label>
                    <button id="connectionToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hi·ªán/·∫©n ƒë∆∞·ªùng n·ªëi gi·ªØa c√°c s·ªë li√™n ti·∫øp">Hi·ªán</button>
                    <label style="font-size: 12px;" id="euclidToggleLabel">Euclid:</label>
                    <button id="euclidToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hi·ªán/·∫©n hi·ªÉn th·ªã kho·∫£ng c√°ch Euclid">Hi·ªán</button>
                    <span id="euclidTotal"
                        style="margin-left:8px;font-size:13px;font-weight:700;color:var(--text-strong);opacity:1;">Œ£:&nbsp;&nbsp;
                        <span id="euclidTotalValue"
                            style="color:#38ef7d;font-weight:900;margin-left:8px;font-size:16px;text-shadow:0 0 8px rgba(56,239,125,0.22);">0.00</span>
                    </span>
                </div>
            </div>
        </div>
    </div>
    <button id="scrollToTop" title="Quay v·ªÅ ƒë·∫ßu trang">‚Üë</button>
    <main>
        <div id="status" class="card" style="margin-bottom:18px;">ƒêang t·∫£i d·ªØ li·ªáu...</div>
        <!-- Sections injected by JS -->
    </main>

    <script>
        // ===== Helpers from notebook =====
        const COL_MAP = { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 2, 10: 2, 11: 2, 12: 2, 13: 2, 14: 2, 15: 2, 16: 2, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 3, 23: 3, 24: 3, 25: 4, 26: 4, 27: 4, 28: 4, 29: 4, 30: 4, 31: 4, 32: 5, 33: 5, 34: 5, 35: 5, 36: 5, 37: 5, 38: 5, 39: 6, 40: 6, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6 };
        const getCol = (v) => COL_MAP[v] ?? 0;

        // Safe focus helper: prefer preventing scroll when moving focus programmatically
        function safeFocus(el) {
            if (!el) return;
            try {
                el.focus({ preventScroll: true });
            } catch (e) {
                try { el.focus(); } catch (e2) { /* ignore */ }
            }
        }
        // ===== Web Worker Setup =====
        // T·∫°o web worker inline ƒë·ªÉ x·ª≠ l√Ω t√≠nh to√°n n·∫∑ng
        const workerCode = `
            // Helpers for worker
            const compareKey = (a, b) => {
                const pa = a.split("-").map(Number); 
                const pb = b.split("-").map(Number);
                for (let i = 0; i < Math.min(pa.length, pb.length); i++) { 
                    if (pa[i] !== pb[i]) return pa[i] - pb[i]; 
                } 
                return pa.length - pb.length;
            };

            function kCombinations(set, k) {
                const combs = [];
                const recur = (start, combo) => {
                    if (combo.length === k) { combs.push([...combo]); return; }
                    for (let i = start; i < set.length; i++) { combo.push(set[i]); recur(i + 1, combo); combo.pop(); }
                };
                recur(0, []); 
                return combs;
            }

            self.onmessage = (e) => {
                const { rows, xSel, consec, sortSel, workerType } = e.data;
                
                if (workerType === 'groupBySet') {
                    const x = parseInt(xSel, 10);
                    const groups = new Map();
                    
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = slice.sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            // Optimize: skip large combos calculation
                            if (x > 4) {
                                for (let i = 0; i <= nums.length - x; i++) {
                                    const slice = nums.slice(i, i + x).slice();
                                    const key = slice.sort((a, b) => a - b).join("-");
                                    if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                }
                            } else {
                                const indexed = nums.map((v, i) => [i, v]);
                                const combos = kCombinations(indexed, x);
                                combos.forEach(combo => {
                                    const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                    const key = values.join("-");
                                    if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                });
                            }
                        }
                    });
                    
                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, indices])
                        .filter(([, indices]) => indices.size >= 2)
                        .sort((a, b) => {
                            const sort = sortSel;
                            if (sort === "value_asc") return compareKey(a[0], b[0]);
                            if (sort === "value_desc") return compareKey(b[0], a[0]);
                            if (sort === "count_asc") return a[1].size - b[1].size;
                            return b[1].size - a[1].size;
                        });

                    self.postMessage({ result: arr.map(([k, v]) => [k, Array.from(v)]) });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        let worker = null;

        const getWorker = () => {
            if (!worker) worker = new Worker(workerUrl);
            return worker;
        };

        // ===== Data Loading =====
        let rows = [];
        async function loadData() {
            const status = document.getElementById("status");
            try {
                // Expect data.json in format: [{"date": "2024-01-01", "Result": "1,2,3,4,5,6"}, ...]
                const res = await fetch("data.json");
                if (!res.ok) throw new Error("Kh√¥ng t√¨m th·∫•y data.json. H√£y xu·∫•t t·ª´ Excel tr∆∞·ªõc.");
                const raw = await res.json();
                rows = raw
                    .map(r => {
                        if (!r.Result || typeof r.Result !== "string") return null;
                        const nums = r.Result.split(",").map(x => parseInt(x.trim(), 10)).filter(Number.isInteger);
                        if (nums.length !== 6) return null;
                        return { date: r.date ?? "", nums, label: nums.map(getCol).join("") };
                    })
                    .filter(Boolean);
                status.innerHTML = `<span class="success">ƒê√£ t·∫£i ${rows.length} d√≤ng</span> ¬∑ file: data.json`;
            } catch (err) {
                status.innerHTML = `<span class="error">${err.message}</span><br/><span class="muted">T·∫°o file data.json t·ª´ Excel b·∫±ng script python: <code>python - <<'PY'\nimport pandas as pd, json\ndf = pd.read_excel('data.xlsx')\nout = df[['date','Result']]\nout.to_json('data.json', orient='records', force_ascii=False, indent=2)\nPY</code></span>`;
            }
        }

        // ===== Utilities =====
        let decimalPlaces = 2; // default decimal places for percentage
        const fmtPct = (v) => `${(v * 100).toFixed(decimalPlaces)}%`;
        const fmtPctCustom = (v, decimals) => `${(v * 100).toFixed(decimals)}%`;
        const MATCH_STYLE = "background:#2e7d32;color:#fff;"; // dark green with white text for matched values

        // Debounce helper to prevent excessive function calls
        const createDebounce = (fn, delay = 100) => {
            let timeout;
            return function debounced(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        };

        // Throttle helper for smoother updates
        const createThrottle = (fn, delay = 100) => {
            let lastCall = 0;
            return function throttled(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return fn.apply(this, args);
                }
            };
        };

        // Double-click any table row that has data-result to copy its result string (format: 1,2,3,4,5,6)
        const handleRowCopyDblClick = (e) => {
            const row = e.target.closest("tr[data-result]");
            if (!row || !row.dataset.result) return;
            // Only allow dblclick-copy when quick-place mode is 'normal' (if toggle exists)
            if (window.getQuickPlaceMode && window.getQuickPlaceMode() !== 'normal') return;
            const text = row.dataset.result;

            const flash = () => {
                row.classList.add("copied-row");
                setTimeout(() => row.classList.remove("copied-row"), 500);
            };

            const fallbackCopy = () => {
                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.top = "-9999px";
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    document.execCommand("copy");
                    document.body.removeChild(ta);
                    flash();
                } catch (_) { /* ignore */ }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(flash).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        };

        // Global listener to catch all dynamic tables
        document.addEventListener('dblclick', handleRowCopyDblClick, true);

        const anchorNav = [
            { id: "cell4", label: "Cell4 ¬∑ T·ª∑ l·ªá theo v·ªã tr√≠" },
            { id: "cell5", label: "Cell5 ¬∑ X·∫øp h·∫°ng v·ªã tr√≠" },
            { id: "cell6", label: "Cell6 ¬∑ C·∫∑p ph·ªï bi·∫øn" },
            { id: "cell6_5", label: "Cell6.5 ¬∑ Truy x" },
            { id: "cell7", label: "Cell7 ¬∑ Nh√≥m label" },
            { id: "cell8", label: "Cell8 ¬∑ T√¨m label" },
            { id: "cell9", label: "Cell9 ¬∑ T·ªï h·ª£p t√πy ch·ªçn" },
            { id: "cell10", label: "Cell10 ¬∑ Ph√¢n t√≠ch v·ªã tr√≠" },
            { id: "cell11", label: "Cell11 ¬∑ Pattern s·ªë" },
        ];

        function buildNav(showSection) {
            const nav = document.getElementById("nav");
            anchorNav.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "nav-btn";
                btn.textContent = item.label;
                btn.dataset.target = item.id;
                btn.onclick = () => {
                    // Lazy render the section only when needed
                    if (typeof ensureRendered === 'function') {
                        ensureRendered(item.id);
                    }
                    showSection(item.id);
                    history.replaceState(null, "", `#${item.id}`);
                };
                nav.appendChild(btn);
            });
        }

        // ===== Renderers =====
        function sectionShell(id, title, lead = "") {
            const sec = document.createElement("section");
            sec.id = id;
            sec.dataset.section = id;
            const h2 = document.createElement("h2");
            h2.textContent = title;
            sec.appendChild(h2);
            if (lead) {
                const p = document.createElement("p");
                p.className = "lead";
                p.textContent = lead;
                sec.appendChild(p);
            }
            const body = document.createElement("div");
            sec.appendChild(body);
            document.querySelector("main").appendChild(sec);
            return body;
        }

        // Qu·∫£n l√Ω hi·ªÉn th·ªã t·ª´ng "trang" (section) m√† kh√¥ng m·∫•t state
        function createSectionSwitcher() {
            const main = document.querySelector("main");
            const buttons = () => Array.from(document.querySelectorAll(".nav-btn"));
            const sections = () => Array.from(main.querySelectorAll("section"));
            const scrollPositions = new Map(); // L∆∞u v·ªã tr√≠ scroll cho t·ª´ng section

            function setActive(id) {
                // L∆∞u v·ªã tr√≠ scroll hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn
                const currentSection = sections().find(sec => !sec.classList.contains("hidden"));
                if (currentSection) {
                    scrollPositions.set(currentSection.id, window.scrollY);
                }

                buttons().forEach(btn => {
                    const active = btn.dataset.target === id;
                    btn.classList.toggle("active", active);
                });
                sections().forEach(sec => {
                    sec.classList.toggle("hidden", sec.id !== id);
                });

                // Restore v·ªã tr√≠ scroll c·ªßa section m·ªõi
                requestAnimationFrame(() => {
                    // Prefer per-input saved scroll for cell10 when available
                    let savedPosition;
                    try {
                        if (id === 'cell10' && window._cell10LastIndex !== undefined && window._cell10LastIndex !== null && window._cell10ScrollByIndex instanceof Map) {
                            const p = window._cell10ScrollByIndex.get(window._cell10LastIndex);
                            if (p !== undefined) savedPosition = p;
                        }
                    } catch (e) { }

                    if (savedPosition === undefined) savedPosition = scrollPositions.get(id);
                    if (savedPosition !== undefined) {
                        window.scrollTo(0, savedPosition);
                    } else {
                        window.scrollTo(0, 0); // Scroll v·ªÅ ƒë·∫ßu n·∫øu ch∆∞a c√≥ l·ªãch s·ª≠
                    }
                });
            }

            function showSection(id) {
                const target = sections().find(sec => sec.id === id);
                const fallback = "cell4";
                const finalId = target ? id : fallback;
                setActive(finalId);
            }

            return showSection;
        }


        function renderCell4() {
            const body = sectionShell("cell4", "Cell4 ¬∑ T·ª∑ l·ªá theo v·ªã tr√≠ (home)", "Top/Sort t∆∞∆°ng t·ª± notebook: hi·ªÉn th·ªã t·ª∑ l·ªá t·ª´ng s·ªë theo 6 v·ªã tr√≠.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[10, "Top 10"], [20, "Top 20"], [30, "Top 30"], [45, "T·∫•t c·∫£ (45)"]].forEach(([v, l]) => {
                const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o);
            });
            topSel.value = "45";
            const sortSel = document.createElement("select");
            [["default", "M·∫∑c ƒë·ªãnh (1‚Üí45)"], ["total_desc", "Theo t·ªïng % gi·∫£m d·∫ßn"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const decimalSel = document.createElement("select");
            [[0, "0 ch·ªØ s·ªë"], [1, "1 ch·ªØ s·ªë"], [2, "2 ch·ªØ s·ªë"], [3, "3 ch·ªØ s·ªë"], [4, "4 ch·ªØ s·ªë"], [5, "5 ch·ªØ s·ªë"], [6, "6 ch·ªØ s·ªë"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hi·ªÉn th·ªã:", topSel, "S·∫Øp x·∫øp:", sortSel, "ƒê·ªô ch√≠nh x√°c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const counts = Array.from({ length: 46 }, () => Array(6).fill(0));
                let total = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return;
                    total++;
                    r.nums.forEach((v, i) => { counts[v][i]++; });
                });
                let data = [];
                for (let v = 1; v <= 45; v++) {
                    const pcts = counts[v].map(c => total ? c / total : 0);
                    const countSum = counts[v].reduce((a, b) => a + b, 0);
                    data.push({ v, pcts, sum: pcts.reduce((a, b) => a + b, 0), count: countSum });
                }
                if (sortSel.value === "total_desc") data.sort((a, b) => b.sum - a.sum); else data.sort((a, b) => a.v - b.v);
                data = data.slice(0, parseInt(topSel.value, 10));

                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr>" +
                    "<th>Rank</th><th>S·ªë</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>T·ªïng %</th></tr></thead><tbody>";
                data.forEach((row, idx) => {
                    const bg = idx % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.05)";
                    html += `<tr style="background:${bg};">` +
                        `<td>#${idx + 1}</td><td><span class='pill'>${row.v}</span></td>` +
                        row.pcts.map(p => `<td>${fmtPctCustom(p, decimals)}</td>`).join("") +
                        `<td><span class='muted' style='font-size:12px;margin-right:8px;'>${row.count}/${total}=</span><strong>${fmtPctCustom(row.sum, decimals)}</strong></td></tr>`;
                });
                html += "</tbody></table></div>";
                wrap.innerHTML = html;
            }
            topSel.onchange = sortSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5: x·∫øp h·∫°ng theo v·ªã tr√≠
        function renderCell5() {
            const body = sectionShell("cell5", "Cell5 ¬∑ X·∫øp h·∫°ng theo v·ªã tr√≠", "Ch·ªçn top v√† t√¥ ƒë·∫≠m theo notebook.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[3, "Top 3"], [5, "Top 5"], [10, "Top 10"], [45, "T·∫•t c·∫£ (45)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o); });
            topSel.value = "45";
            const decimalSel = document.createElement("select");
            [[0, "0 ch·ªØ s·ªë"], [1, "1 ch·ªØ s·ªë"], [2, "2 ch·ªØ s·ªë"], [3, "3 ch·ªØ s·ªë"], [4, "4 ch·ªØ s·ªë"], [5, "5 ch·ªØ s·ªë"], [6, "6 ch·ªØ s·ªë"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hi·ªÉn th·ªã:", topSel, "ƒê·ªô ch√≠nh x√°c:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                const count = Array.from({ length: 6 }, () => Array(46).fill(0));
                rows.forEach(r => { r.nums.forEach((v, i) => { count[i][v]++; }); });
                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                const topN = parseInt(topSel.value, 10);
                for (let rank = 0; rank < topN; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        const arr = [...Array(45).keys()].map(i => i + 1).map(v => [v, count[pos][v]]).sort((a, b) => b[1] - a[1]);
                        const [v, c] = arr[rank];
                        const pct = rows.length ? (c / rows.length) : 0;
                        const col = getCol(v);
                        cells.push(`<td><div><strong>${v}</strong> <span class='muted'>[C${col}]</span></div><div class='muted'>${c}/${rows.length}= ${fmtPctCustom(pct, decimals)}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank + 1}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                // Th√™m b·∫£ng m·ªõi: X·∫øp h·∫°ng c·ªôt theo v·ªã tr√≠ (6x6)
                html += "<h3 style='margin-top: 24px; margin-bottom: 12px;'>X·∫øp h·∫°ng c·ªôt theo v·ªã tr√≠</h3>";

                // T·ªïng % c·ªßa t·ª´ng c·ªôt (C1-C6) tr√™n to√†n b·ªô 6 v·ªã tr√≠
                const colTotals = Array(6).fill(0);
                rows.forEach(r => {
                    r.nums.forEach(v => { const col = getCol(v); colTotals[col - 1]++; });
                });
                const totalPositions = rows.length * 6;
                const colPctDisplay = colTotals.map((c, idx) => {
                    const pct = fmtPctCustom(totalPositions ? c / totalPositions : 0, decimals);
                    return `<span class="pill" style="background:linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%); color:#fff; border:none;">C${idx + 1}</span> <strong>${pct}</strong>`;
                }).join(" ¬∑ ");
                html += `<div style='margin:6px 0 10px; font-size:12px; color:var(--text-strong);'>${colPctDisplay}</div>`;

                html += "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";

                // T√≠nh to√°n: v·ªõi m·ªói v·ªã tr√≠, x·∫øp h·∫°ng c√°c c·ªôt (1-6) theo s·ªë l·∫ßn xu·∫•t hi·ªán
                for (let rank = 1; rank <= 6; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        // ƒê·∫øm m·ªói c·ªôt (1-6) xu·∫•t hi·ªán ·ªü v·ªã tr√≠ n√†y
                        const colCounts = {};
                        for (let col = 1; col <= 6; col++) colCounts[col] = 0;

                        rows.forEach(r => {
                            const v = r.nums[pos];
                            const col = getCol(v);
                            colCounts[col]++;
                        });

                        // S·∫Øp x·∫øp c√°c c·ªôt theo s·ªë l·∫ßn xu·∫•t hi·ªán (gi·∫£m d·∫ßn)
                        const sortedCols = Object.entries(colCounts)
                            .map(([col, count]) => ({ col: parseInt(col), count }))
                            .sort((a, b) => b.count - a.count);

                        // L·∫•y c·ªôt ·ªü rank n√†y (rank - 1 v√¨ rank b·∫Øt ƒë·∫ßu t·ª´ 1)
                        const { col: topCol, count: topCount } = sortedCols[rank - 1];
                        const pct = rows.length ? (topCount / rows.length) : 0;
                        cells.push(`<td><div><strong>C${topCol}</strong></div><div class='muted'>${topCount}/${rows.length}= ${fmtPctCustom(pct, parseInt(decimalSel.value, 10))}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                wrap.innerHTML = html;
            }
            topSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Helpers for labels
        const labelOf = (nums) => nums.map(getCol).join("");
        const diffPositions = (a, b) => { const pos = []; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) pos.push(i); return pos; };

        // Cell6: group by label with max diff + consecutive
        function renderCell6() {
            const body = sectionShell("cell7", "Cell7 ¬∑ Nh√≥m theo label", "max sai kh√°c & li·ªÅn k·ªÅ, ch·ªâ nh√≥m >=2 k·ª≥.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const diffSel = document.createElement("select");
            for (let i = 0; i <= 6; i++) { const o = document.createElement("option"); o.value = i; o.textContent = `Sai kh√°c ${i}`; diffSel.appendChild(o); } diffSel.value = "1";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ"));
            const sortSel = document.createElement("select");
            [["count_desc", "Gi·∫£m d·∫ßn (s·ªë k·ª≥)"], ["count_asc", "TƒÉng d·∫ßn (s·ªë k·ª≥)"], ["value_asc", "TƒÉng d·∫ßn (gi√° tr·ªã)"], ["value_desc", "Gi·∫£m d·∫ßn (gi√° tr·ªã)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            controls.append("Sai kh√°c t·ªëi ƒëa:", diffSel, consecLabel, "S·∫Øp x·∫øp:", sortSel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }

                // T·∫°o key ƒë·ªÉ ki·ªÉm tra cache
                const newCacheKey = `${diffSel.value}|${consec.checked}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroups(groupCache);
                    return;
                }

                wrap.innerHTML = "<div class='loader'>ƒêang x·ª≠ l√Ω...</div>";

                // D√πng requestIdleCallback ƒë·ªÉ t√≠nh to√°n khi browser r·∫£nh
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => computeAndRender());
                } else {
                    setTimeout(() => computeAndRender(), 0);
                }

                function computeAndRender() {
                    const labelRows = {};
                    rows.forEach(r => { const label = labelOf(r.nums); (labelRows[label] ||= []).push(r); });
                    const labels = Object.keys(labelRows).sort();
                    const used = new Set();
                    let groups = [];

                    // B∆∞·ªõc 1: Lu√¥n nh√≥m theo ƒëi·ªÅu ki·ªán l·ªèng nh·∫•t (kh√¥ng li·ªÅn k·ªÅ)
                    labels.forEach(base => {
                        if (used.has(base)) return;
                        used.add(base);
                        const gLabels = [base];
                        let gRows = [...labelRows[base]];

                        for (let j = 0; j < labels.length; j++) {
                            const other = labels[j];
                            if (used.has(other)) continue;
                            const pos = diffPositions(base, other);
                            // Ch·ªâ ki·ªÉm tra s·ªë v·ªã tr√≠ kh√°c nhau, kh√¥ng ki·ªÉm tra li·ªÅn k·ªÅ
                            if (pos.length > parseInt(diffSel.value, 10)) continue;
                            used.add(other); gLabels.push(other); gRows.push(...labelRows[other]);
                        }
                        if (gRows.length >= 2) groups.push({ base, labels: gLabels, rows: gRows });
                    });

                    // B∆∞·ªõc 2: N·∫øu tick "Li·ªÅn k·ªÅ", l·ªçc c√°c labels kh√¥ng tho·∫£ ƒëi·ªÅu ki·ªán trong m·ªói nh√≥m
                    if (consec.checked) {
                        groups = groups.map(g => {
                            // Gi·ªØ l·∫°i ch·ªâ nh·ªØng labels tho·∫£ ƒëi·ªÅu ki·ªán li·ªÅn k·ªÅ v·ªõi base
                            const filteredLabels = g.labels.filter(label => {
                                const pos = diffPositions(g.base, label);
                                // N·∫øu ch·ªâ kh√°c ‚â§1 v·ªã tr√≠ th√¨ OK (kh√¥ng c·∫ßn ki·ªÉm tra li·ªÅn k·ªÅ)
                                if (pos.length <= 1) return true;
                                // N·∫øu kh√°c ‚â•2 v·ªã tr√≠, ki·ªÉm tra li·ªÅn k·ªÅ
                                return pos.every((p, i) => i === 0 || p - pos[i - 1] === 1);
                            });
                            // T√≠nh l·∫°i rows d·ª±a tr√™n filtered labels
                            const filteredRows = [];
                            filteredLabels.forEach(label => {
                                filteredRows.push(...labelRows[label]);
                            });
                            return { base: g.base, labels: filteredLabels, rows: filteredRows };
                        }).filter(g => g.rows.length >= 2); // Ch·ªâ gi·ªØ nh√≥m ‚â•2 k·ª≥
                    }

                    groups.sort((a, b) => b.rows.length - a.rows.length);
                    groupCache = groups;
                    cacheKey = newCacheKey;
                    renderGroups(groups);
                }
            }

            function renderGroups(groups) {
                // Apply sorting based on sortSel value
                if (sortSel.value === 'count_desc') groups.sort((a, b) => b.rows.length - a.rows.length);
                else if (sortSel.value === 'count_asc') groups.sort((a, b) => a.rows.length - b.rows.length);
                else if (sortSel.value === 'value_asc') groups.sort((a, b) => compareKey(a.base, b.base));
                else if (sortSel.value === 'value_desc') groups.sort((a, b) => compareKey(b.base, a.base));

                // Summary + grid container
                wrap.innerHTML = `<div class='muted'>${groups.length} nh√≥m ¬∑ ${groups.reduce((s, g) => s + g.rows.length, 0)} k·ª≥</div>` +
                    `<div class='grid-centered' id='labelGroupGrid'></div>`;
                const grid = wrap.querySelector('#labelGroupGrid');

                // Caches for smoother back-scroll (per-page keys `${idx}|${page}`)
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = []; // maintain recency for limiting cache
                const MAX_CACHE = 160;
                const cardRefs = new Map(); // idx -> element
                const mountedSet = new Set(); // idx currently mounted
                const MAX_MOUNTED = 36; // limit live DOM to reduce churn

                const setCache = (key, html) => {
                    htmlCache.set(key, html);
                    lruQueue.push(key);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        const rmIdx = String(rm).split('|')[0];
                        if (!mountedSet.has(Number(rmIdx))) htmlCache.delete(rm);
                    }
                };

                const mount = (card, g, idx) => {
                    const body = card.querySelector('.card-body');
                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(g.rows.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;
                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const start = page * pageSizeRows;
                        const slice = g.rows.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        inner += "<table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        slice.forEach(r => {
                            const label = labelOf(r.nums);
                            const labelHtml = label.split("").map((ch, i) => ch !== g.base[i]
                                ? `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>`
                                : `<span>${ch}</span>`).join(" ");
                            const nums = r.nums.map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        inner += "</tbody></table>";
                        if (g.rows.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${g.rows.length - (page + 1) * pageSizeRows} d√≤ng n·ªØa</td></tr>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        setCache(cacheKey, inner);
                    }
                    body.style.minHeight = "";
                    body.innerHTML = inner;
                    // attach pagination handlers
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    // Measure and cache height after first mount
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = ""; // free DOM when offscreen
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    // Unmount farthest cards first
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const g = groups[idx];
                        if (!g) return;
                        if (entry.isIntersecting) {
                            mount(entry.target, g, idx);
                        } else {
                            unmount(entry.target, idx);
                        }
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Chunked creation of cards to avoid main-thread spikes
                const totalGroups = groups.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, groups.length);
                    for (let i = created; i < end; i++) {
                        const g = groups[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // show rank/total to the left of the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>Base ${g.base}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${g.rows.length} k·ª≥</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < groups.length) requestAnimationFrame(createChunk);
                };
                createChunk();
            }

            // D√πng debounce ƒë·ªÉ tr√°nh t√≠nh to√°n qu√° t·∫ßn su·∫•t
            const debouncedGroup = createDebounce(group, 300);
            diffSel.onchange = consec.onchange = debouncedGroup;
            sortSel.onchange = () => groupCache && renderGroups(groupCache);
            group();
        }

        // Cell6.5: Truy x - same grouping logic as Cell6 but filter groups to those containing a user-specified number x
        function renderCell6_5() {
            const body = sectionShell("cell6_5", "Cell6.5 ¬∑ Truy x", "Ch·ªçn s·ªë x (1-45) v√† k√≠ch th∆∞·ªõc b·ªô ƒë·ªÉ li·ªát k√™ ch·ªâ nh·ªØng b·ªô li√™n quan t·ªõi x.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `B·ªô ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Gi·∫£m d·∫ßn (s·ªë k·ª≥)"], ["count_asc", "TƒÉng d·∫ßn (s·ªë k·ª≥)"], ["value_asc", "TƒÉng d·∫ßn (gi√° tr·ªã)"], ["value_desc", "Gi·∫£m d·∫ßn (gi√° tr·ªã)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const xFilter = document.createElement("input"); xFilter.type = "number"; xFilter.min = 1; xFilter.max = 45; xFilter.placeholder = "S·ªë x (1-45)"; xFilter.style.width = '88px';
            // Create +/- buttons styled and behaving like Cell9 arrows
            const xContainer = document.createElement('div');
            xContainer.style.cssText = 'position:relative;display:inline-block;vertical-align:middle;margin-right:8px;';
            xFilter.style.paddingRight = '40px';
            xFilter.style.boxSizing = 'border-box';
            const btnGroup = document.createElement('div');
            btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
            const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
            const upBtn = document.createElement('button'); upBtn.type = 'button'; upBtn.className = 'arrow-up'; upBtn.innerHTML = '‚ñ≤'; upBtn.title = 'TƒÉng 1'; upBtn.style.cssText = arrowStyle;
            const downBtn = document.createElement('button'); downBtn.type = 'button'; downBtn.className = 'arrow-down'; downBtn.innerHTML = '‚ñº'; downBtn.title = 'Gi·∫£m 1'; downBtn.style.cssText = arrowStyle;

            upBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n + 1;
                if (n > 45) n = 1; // wrap like cell9
                if (n < 1) n = 1;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            downBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n - 1;
                if (n < 1) n = 45; // wrap like cell9
                if (n > 45) n = 45;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            btnGroup.appendChild(upBtn);
            btnGroup.appendChild(downBtn);
            xContainer.appendChild(xFilter);
            xContainer.appendChild(btnGroup);

            // Accept drags from number picker popup (single number, place index or place set)
            xContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { }
                xContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
            });
            xContainer.addEventListener('dragleave', () => {
                xContainer.style.backgroundColor = '';
            });
            xContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                xContainer.style.backgroundColor = '';
                const txt = e.dataTransfer.getData('text/plain');
                const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                const placeSetData = e.dataTransfer.getData('application/x-place-set');
                const labelData = e.dataTransfer.getData('application/x-label');
                let value = null;
                if (placeIndexData) {
                    const idx = parseInt(placeIndexData, 10);
                    const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                    if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                } else if (placeSetData) {
                    try {
                        const arr = JSON.parse(placeSetData);
                        if (Array.isArray(arr) && arr.length) {
                            // pick first numeric value in the set
                            for (const v of arr) {
                                if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; }
                            }
                        }
                    } catch (err) { }
                } else if (txt) {
                    value = txt;
                } else if (labelData) {
                    value = labelData;
                }

                if (value !== null && value !== undefined) {
                    let n = parseInt(String(value).trim(), 10);
                    if (Number.isFinite(n)) {
                        if (n < 1) n = 1;
                        if (n > 45) n = 45;
                        xFilter.value = String(n);
                        xFilter.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    }
                }
            });

            controls.append("S·ªë x:", xContainer, "B·ªô s·ªë:", xSel, consecLabel, orderLabel, "S·∫Øp x·∫øp:", sortSel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            let isComputing = false;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }

                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${xFilter.value}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return;
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>ƒêang x·ª≠ l√Ω (tr√™n background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    // filter by xFilter if provided
                    const fx = parseInt(xFilter.value, 10);
                    if (!Number.isNaN(fx)) arr = arr.filter(([key]) => key.split('-').map(Number).includes(fx));

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        let arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);
                        const fx = parseInt(xFilter.value, 10);
                        if (!Number.isNaN(fx)) arr = arr.filter(([key]) => key.split('-').map(Number).includes(fx));

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                wrap.innerHTML = `<div class='muted'>${arr.length} nh√≥m (>=2 k·ª≥) ‚Äî l·ªçc theo S·ªë x</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160;
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(list.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        const start = page * pageSizeRows;
                        const slice = list.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        inner += `<table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        slice.forEach(r => {
                            const orderedSeq = key.split('-').map(Number);
                            const requireOrder = !!(consec.checked && order && order.checked);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    else euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} d√≤ng n·ªØa</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // Add rank indicator (x/totalGroups) next to the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${list.length} k·ª≥</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();
            }

            const debouncedGroup = createDebounce(group, 300);
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; debouncedGroup(); };
            xSel.onchange = sortSel.onchange = order.onchange = debouncedGroup;
            xFilter.onchange = debouncedGroup;
            group();
        }

        // Cell7: reverse query by label pattern (6 chars, _ wildcard)
        function renderCell7() {
            const body = sectionShell("cell8", "Cell8 ¬∑ T√¨m ki·∫øm theo Label", "Nh·∫≠p 6 k√Ω t·ª± label (1-6 ho·∫∑c _) ƒë·ªÉ t√¨m c√°c k·ª≥ c√≥ label kh·ªõp. C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs and add small up/down arrows inside the input on the right
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                // container sized to the input; buttons will be absolutely positioned inside it
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                // small left-side grip so it doesn't cover the whole input and block typing
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // keep input as text to allow wildcard '_', but visually reserve space for buttons
                inp.type = 'text';
                inp.maxLength = 1;
                inp.placeholder = '_';
                inp.size = 1;
                inp.style.width = '70px';
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';
                inp.style.position = 'relative';
                inp.style.zIndex = '1';

                // small vertical arrow buttons inside the input, right-aligned
                const btnGroup = document.createElement('div');
                // absolutely position the buttons so they sit inside the input's right edge
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';

                // make arrows compact so they don't overflow the input border
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';

                const up = document.createElement('button');
                up.type = 'button';
                up.className = 'arrow-up';
                up.innerHTML = '‚ñ≤';
                up.title = 'TƒÉng 1';
                up.style.cssText = arrowStyle;

                const down = document.createElement('button');
                down.type = 'button';
                down.className = 'arrow-down';
                down.innerHTML = '‚ñº';
                down.title = 'Gi·∫£m 1';
                down.style.cssText = arrowStyle;

                // clamp helper: allow '' and '_' as wildcard, otherwise clamp to [1,6]
                const clampValue = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '' || raw === '_') return;
                    const n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: after 6 -> 1
                    n = n + 1;
                    if (n > 6) n = 1;
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: before 1 -> 6
                    n = n - 1;
                    if (n < 1) n = 6;
                    if (n > 6) n = 6;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '' && v !== '_';
                    container.draggable = hasValue;
                    // only enable pointer events on the small grip (left) so the input remains editable
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    // keep padding and border radius constant so container height doesn't jump
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    // use transparent border when empty to preserve box size, and accent border when filled
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampValue(); updateDraggable(); });
                inp.addEventListener('change', () => { clampValue(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // K√©o t·ª´ b·∫£ng label C1-C6 tr·ª±c ti·∫øp t·ª´ popup
                    if (labelData) {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run();
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                        return;
                    }

                    // Swap v·ªõi 1 place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                            const incomingRaw = placeVals[srcIdx];
                            const incoming = incomingRaw && popupMode === 'number' ? getCol(parseInt(incomingRaw, 10)) : incomingRaw;
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // N·∫øu k√©o c·∫£ b·ªô place (6 gi√° tr·ªã)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                                for (let i = 0; i < 6; i++) {
                                    const val = values[i];
                                    let col = '';
                                    if (val) {
                                        const numVal = parseInt(val, 10);
                                        col = popupMode === 'number' ? getCol(numVal) : numVal;
                                    }
                                    inputs[i].value = col || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                run();
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                draggedIndex = null;
                                return;
                            }
                        } catch (err) { }
                    }
                    // K√©o s·ªë tr·ª±c ti·∫øp t·ª´ popup ‚Üí chuy·ªÉn sang c·ªôt (ch·ªâ n·∫øu kh√¥ng ph·∫£i internal drag)
                    if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                        const numVal = parseInt(draggedData, 10);
                        if (numVal >= 1 && numVal <= 45) {
                            const col = getCol(numVal);
                            inputs[idx].value = col || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Ho√°n ƒë·ªïi n·ªôi b·ªô
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const wrapInputs = document.createElement("div"); wrapInputs.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Label:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            wrapInputs.appendChild(labelText);
            containers.forEach(c => wrapInputs.appendChild(c)); body.appendChild(wrapInputs);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "clear-btn"; wrapInputs.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            wrapInputs.appendChild(hint);

            function run() {
                const pattern = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : "_"; }).join("");
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                if (pattern.length !== 6) { wrap.innerHTML = "<div class='error'>C·∫ßn 6 k√Ω t·ª±</div>"; return; }
                const records = rows.filter(r => {
                    const label = r.label;
                    for (let i = 0; i < 6; i++) if (pattern[i] !== "_" && pattern[i] !== label[i]) return false;
                    return true;
                });
                if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o kh·ªõp pattern</div>"; return; }
                let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < records.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>K·∫øt qu·∫£</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    records.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_"
                            ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                            : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
                        ).join(" ");
                        const labelHtml = r.label.split("").map((ch, idx) => pattern[idx] === "_" ? `<span>${ch}</span>` : `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`).join(" ");
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        // Cell8: group by same number set size x
        function renderCell8() {
            const body = sectionShell("cell6", "Cell6 ¬∑ C·∫∑p ph·ªï bi·∫øn", "Ch·ªçn k√≠ch th∆∞·ªõc b·ªô s·ªë (1-6), t√πy ch·ªçn li·ªÅn k·ªÅ, s·∫Øp x·∫øp.");
            const controls = document.createElement("div"); controls.className = "controls";
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `B·ªô ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Gi·∫£m d·∫ßn (s·ªë k·ª≥)"], ["count_asc", "TƒÉng d·∫ßn (s·ªë k·ª≥)"], ["value_asc", "TƒÉng d·∫ßn (gi√° tr·ªã)"], ["value_desc", "Gi·∫£m d·∫ßn (gi√° tr·ªã)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            controls.append("B·ªô s·ªë:", xSel, consecLabel, orderLabel, "S·∫Øp x·∫øp:", sortSel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            let isComputing = false;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }

                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                if (isComputing) return; // Tr√°nh multiple requests
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>ƒêang x·ª≠ l√Ω (tr√™n background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                // N·∫øu x <= 2 ho·∫∑c consec=true, t√≠nh nhanh tr√™n main thread
                if (x <= 2 || consec.checked) {
                    computeQuick();
                } else {
                    // N·∫øu x > 2 v√† consec=false, d√πng worker
                    computeWithWorker();
                }

                function computeQuick() {
                    const groups = new Map();
                    rows.forEach((r, rowIndex) => {
                        const nums = r.nums;
                        if (consec.checked) {
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        } else {
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, x);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        }
                    });

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    const rowsForWorker = rows.map(r => ({ nums: r.nums, date: r.date, label: r.label }));

                    worker.onmessage = (e) => {
                        const arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                wrap.innerHTML = `<div class='muted'>${arr.length} nh√≥m (>=2 k·ª≥)</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160; // increase because we store per-page
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        // only drop if not currently mounted
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                // Lazy mount/unmount per-card table using viewport observation
                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(list.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        const start = page * pageSizeRows;
                        const slice = list.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        inner += `<table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>`;
                        slice.forEach(r => {
                            const orderedSeq = key.split('-').map(Number);
                            const requireOrder = !!(consec.checked && order && order.checked);
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                // ignore euclid errors, leave parts empty
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            // Let CSS handle centering and fixed width; avoid left-padding with NBSPs
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            inner += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} d√≤ng n·ªØa</td></tr>`;
                        inner += `</tbody></table>`;
                        // duplicate pagination controls under the table so users can navigate from bottom
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>‚óÄ</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>‚ñ∂</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // attach pagination handlers (attach to both top and bottom controls)
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${list.length} k·ª≥</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();
            }

            const debouncedGroup = createDebounce(group, 300);
            // enable/disable order checkbox depending on consec
            consec.onchange = () => {
                order.disabled = !consec.checked;
                if (!consec.checked) order.checked = false;
                debouncedGroup();
            };
            xSel.onchange = sortSel.onchange = order.onchange = debouncedGroup;
            group();
        }
        function compareKey(a, b) {
            const pa = a.split("-").map(Number); const pb = b.split("-").map(Number);
            for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; }
            return pa.length - pb.length;
        }
        function findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            if (requireConsecutive) {
                for (let i = 0; i <= nums.length - blockSize; i++) {
                    const block = nums.slice(i, i + blockSize);
                    if (block.length !== blockSize) continue;
                    if (requireOrder && Array.isArray(orderedSeq) && orderedSeq.length === blockSize) {
                        let matches = true;
                        for (let k = 0; k < blockSize; k++) {
                            if (block[k] !== orderedSeq[k]) { matches = false; break; }
                        }
                        if (matches) return Array.from({ length: blockSize }, (_, k) => i + k);
                    } else {
                        if (block.every(v => setValues.has(v)) && new Set(block).size === setValues.size) {
                            return Array.from({ length: blockSize }, (_, k) => i + k);
                        }
                    }
                }
            }
            const positions = [];
            nums.forEach((v, idx) => { if (setValues.has(v)) positions.push(idx); });
            return positions;
        }
        function renderHighlightedNums(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            const positions = findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder);
            const posSet = new Set(positions);
            const html = nums.map((v, idx) => posSet.has(idx)
                ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
            ).join(" ");
            return { html, positions };
        }
        function renderHighlightedLabel(labelStr, highlightPositions) {
            const posSet = new Set(highlightPositions);
            return labelStr.split("").map((ch, idx) => posSet.has(idx)
                ? `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`
                : `<span>${ch}</span>`
            ).join(" ");
        }

        // Helper for main thread combos (same algorithm available inside worker)
        function kCombinations(set, k) {
            const combs = [];
            const n = set.length;
            function pick(start, acc) {
                if (acc.length === k) { combs.push(acc.slice()); return; }
                for (let i = start; i < n; i++) { acc.push(set[i]); pick(i + 1, acc); acc.pop(); }
            }
            pick(0, []);
            return combs;
        }

        // Cell9: draws containing user set
        function renderCell9() {
            const body = sectionShell("cell9", "Cell9 ¬∑ T·ªï h·ª£p ch·ª©a b·ªô s·ªë ho·∫∑c label", "Ch·ªçn t√¨m theo b·ªô s·ªë (1-45) ho·∫∑c label (1-6). C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");

            // Mode toggle integrated with Number Picker
            const getNumberPickerMode = window.getNumberPickerMode || (() => "number");
            const setNumberPickerMode = window.setNumberPickerMode || (() => { });
            const onNumberPickerModeChange = window.onNumberPickerModeChange || (() => () => { });
            let cell9ModeState = getNumberPickerMode();
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell9ModeState === 'number' ? 'B·ªô s·ªë (1-45)' : 'Label (1-6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === "number") {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });
                }
            };

            let inputs = createInputs(cell9ModeState);

            // Create draggable containers for inputs ‚Äî add in-input up/down buttons and consistent sizing
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                    container.draggable = false;

                    // small left-side grip so it doesn't cover the whole input and block typing
                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                    // reserve space on the right for buttons
                    inp.style.position = "relative";
                    inp.style.zIndex = "1";
                    inp.style.paddingRight = '40px';
                    inp.style.boxSizing = 'border-box';

                    // button group inside input, right-aligned
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '‚ñ≤'; up.title = 'TƒÉng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '‚ñº'; down.title = 'Gi·∫£m 1'; down.style.cssText = arrowStyle;

                    // helpers per mode
                    const clampForNumberMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 45) inp.value = '45';
                        else inp.value = String(n);
                    };

                    const clampForLabelMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '' || raw === '_') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 6) inp.value = '6';
                        else inp.value = String(n);
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 45) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 6) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 45; // wrap
                            if (n > 45) n = 45;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 6; // wrap
                            if (n > 6) n = 6;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });

                    btnGroup.appendChild(up);
                    btnGroup.appendChild(down);

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const hasValue = inp.type === 'number' ? v !== '' : (v !== '' && v !== '_');
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                        dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                        container.style.borderRadius = '10px';
                        container.style.padding = '2px';
                        container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                        container.style.opacity = hasValue ? '1' : '0.85';
                    };

                    // attach input handlers depending on mode
                    inp.addEventListener('input', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    inp.addEventListener('change', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    updateDraggable();

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    return container;
                });
            };
            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;


            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    // Track drag-over state to avoid redundant style updates
                    let isDragOverThis = false;

                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        dropHandled = false;
                        container.style.opacity = "0.4";
                        container.style.cursor = "grabbing";
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        container.style.cursor = "grab";
                        // If drop didn't happen (dragged outside), delete the value
                        if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                            inputs[idx].value = "";
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                        }
                        draggedIndex = null;
                        dropHandled = false;
                        isDragOverThis = false;
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";

                        // Only update styles if not already in drag-over state
                        if (!isDragOverThis) {
                            isDragOverThis = true;
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        isDragOverThis = false;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        dropHandled = true;
                        const draggedData = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        isDragOverThis = false;

                        // Swap with a single place box
                        if (placeIndexData !== null && placeIndexData !== '') {
                            const srcIdx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                                const incoming = placeVals[srcIdx];
                                const outgoing = inputs[idx].value;
                                inputs[idx].value = incoming || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                placeVals[srcIdx] = outgoing || '';
                                if (window.setPlaceValues) window.setPlaceValues(placeVals);
                                if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                                if (run) run();
                                draggedIndex = null;
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                return;
                            }
                        }
                        // Accept place set (6 numbers)
                        if (placeSetData) {
                            try {
                                let values = JSON.parse(placeSetData);
                                if (Array.isArray(values) && values.length === 6) {
                                    // In label mode, reverse values to match reversed display
                                    if (cell9ModeState === 'label') {
                                        values = values.reverse();
                                    }
                                    for (let i = 0; i < 6; i++) {
                                        inputs[i].value = values[i] || '';
                                        inputs[i].dispatchEvent(new Event("input"));
                                    }
                                    if (run) run();
                                }
                            } catch (err) { }
                        }
                        // K√©o s·ªë/label tr·ª±c ti·∫øp t·ª´ popup (ch·ªâ n·∫øu kh√¥ng ph·∫£i internal drag)
                        else if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                            const numVal = parseInt(draggedData, 10);
                            if (cell9ModeState === 'number' && numVal >= 1 && numVal <= 45) {
                                inputs[idx].value = numVal;
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            } else if (cell9ModeState === 'label') {
                                const col = getCol(numVal);
                                inputs[idx].value = col || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            }
                        }
                        // K√©o label t·ª´ header popup khi mode = label
                        else if (draggedIndex === null && labelData && cell9ModeState === 'label') {
                            inputs[idx].value = labelData.replace('C', '');
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                            draggedIndex = null;
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            return;
                        }
                        // Otherwise swap
                        else if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            if (run) run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Li·ªÅn k·ªÅ"));
            const controls = document.createElement("div"); controls.className = "controls";

            // Add mode toggle button
            controls.appendChild(modeBtn);

            const inputLabel = document.createElement("span"); inputLabel.textContent = cell9ModeState === "number" ? "B·ªô s·ªë:" : "Label:"; inputLabel.style.fontWeight = "700"; inputLabel.style.fontSize = "14px"; inputLabel.style.marginLeft = "12px";
            controls.appendChild(inputLabel);

            // For label mode, reverse the containers for proper left-to-right display
            const containersToAdd = cell9ModeState === "label" ? [...containers].reverse() : containers;
            containersToAdd.forEach(c => controls.appendChild(c));
            controls.append(consecLabel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run() {
                const mode = cell9ModeState;

                if (mode === "number") {
                    const vals = inputs.map(i => parseInt(i.value, 10)).filter(v => !isNaN(v) && v >= 1 && v <= 45);
                    if (!vals.length) { wrap.innerHTML = "<div class='loader'>ƒêi·ªÅn √≠t nh·∫•t 1 s·ªë...</div>"; return; }
                    const inputFreq = {};
                    vals.forEach(v => { inputFreq[v] = (inputFreq[v] || 0) + 1; });
                    const setVals = new Set(vals);
                    const records = rows.filter(r => {
                        const rowFreq = {};
                        r.nums.forEach(v => { rowFreq[v] = (rowFreq[v] || 0) + 1; });
                        for (const num in inputFreq) {
                            if ((rowFreq[num] || 0) < inputFreq[num]) return false;
                        }
                        if (consec.checked) return hasConsecutiveBlock(r.nums, setVals);
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o ph√π h·ª£p</div>"; return; }
                    let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < records.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                        records.slice(i, i + chunk).forEach(r => {
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setVals, setVals.size, consec.checked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                } else {
                    const labels = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : null; }).filter(v => v !== null);
                    if (!labels.length) { wrap.innerHTML = "<div class='loader'>ƒêi·ªÅn √≠t nh·∫•t 1 k√Ω t·ª±...</div>"; return; }
                    const inputFreq = {};
                    labels.forEach(ch => { inputFreq[ch] = (inputFreq[ch] || 0) + 1; });
                    const totalCount = labels.length;
                    const inputKeys = Object.keys(inputFreq);
                    const keySet = new Set(inputKeys);

                    const records = rows.filter(r => {
                        const labelStr = r.label;
                        const rowFreq = {};
                        for (const ch of labelStr) rowFreq[ch] = (rowFreq[ch] || 0) + 1;
                        for (const ch of inputKeys) {
                            if ((rowFreq[ch] || 0) < inputFreq[ch]) return false;
                        }
                        if (consec.checked) {
                            for (let i = 0; i <= labelStr.length - totalCount; i++) {
                                const block = labelStr.slice(i, i + totalCount);
                                const blockFreq = {};
                                for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                let ok = true;
                                for (const ch of inputKeys) {
                                    if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                }
                                if (ok) return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o ph√π h·ª£p</div>"; return; }
                    let html = `<div class='muted'>${records.length} k·ª≥</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < records.length; i += chunk) {
                        html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th></tr></thead><tbody>";
                        records.slice(i, i + chunk).forEach(r => {
                            const labelStr = r.label;
                            let highlightPos = [];
                            if (consec.checked) {
                                let start = -1;
                                for (let s = 0; s <= labelStr.length - totalCount && start === -1; s++) {
                                    const block = labelStr.slice(s, s + totalCount);
                                    const blockFreq = {};
                                    for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                    let ok = true;
                                    for (const ch of inputKeys) {
                                        if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                    }
                                    if (ok) start = s;
                                }
                                if (start !== -1) {
                                    highlightPos = Array.from({ length: totalCount }, (_, k) => start + k);
                                }
                            }
                            if (!highlightPos.length) {
                                for (let pos = 0; pos < labelStr.length; pos++) {
                                    if (keySet.has(labelStr[pos])) highlightPos.push(pos);
                                }
                            }
                            // Create a set of highlighted column numbers from label chars
                            const highlightedLabelChars = new Set(highlightPos.map(pos => labelStr[pos]));
                            // Convert column chars to numbers 1-45 that belong to those columns
                            const highlightedNums = new Set();
                            for (let num = 1; num <= 45; num++) {
                                if (highlightedLabelChars.has(String(getCol(num)))) {
                                    highlightedNums.add(num);
                                }
                            }
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, highlightedNums, totalCount, consec.checked);
                            const labelHtml = renderHighlightedLabel(labelStr, highlightPos);
                            // compute euclidean distances between adjacent numbers (5 values) and total
                            let euclidPartsHtml = [];
                            let euclidTotal = 0;
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                const tbody = npTable ? npTable.querySelector('tbody') : null;
                                const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                                for (let j = 0; j < 5; j++) {
                                    const n1 = r.nums[j];
                                    const n2 = r.nums[j + 1];
                                    let part = '';
                                    if (npTable && tbodyRows.length > 0) {
                                        const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                        const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                        if (cell1 && cell2) {
                                            const rowElem1 = cell1.parentElement;
                                            const rowElem2 = cell2.parentElement;
                                            const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                            const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                            const logicalRow1 = 7 - rowIdx1;
                                            const logicalRow2 = 7 - rowIdx2;
                                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                            const dx = colIdx2 - colIdx1;
                                            const dy = logicalRow2 - logicalRow1;
                                            const d = Math.sqrt(dx * dx + dy * dy);
                                            part = isFinite(d) ? d.toFixed(2) : '';
                                            euclidTotal += isFinite(d) ? d : 0;
                                        }
                                    }
                                    if (part) {
                                        euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                    } else {
                                        euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                    }
                                }
                            } catch (e) {
                                for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                            }
                            const totalStr = euclidTotal.toFixed(2);
                            const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                            html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                }
            }

            const applyCell9Mode = (mode, { notify = true } = {}) => {
                if (mode !== 'number' && mode !== 'label') return;
                if (!notify && cell9ModeState === mode) return;

                cell9ModeState = mode;
                modeBtn.textContent = cell9ModeState === 'number' ? 'B·ªô s·ªë (1-45)' : 'Label (1-6)';

                // Clear old drag listeners by removing and recreating containers
                document.querySelectorAll(".drag-input-container").forEach(c => {
                    c.style.opacity = "1";
                    c.style.transform = "";
                });

                inputs = createInputs(mode);
                containers = createContainers(inputs);

                // Reset draggedIndex to prevent stale references
                draggedIndex = null;

                setupDragListeners(containers);
                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                inputLabel.textContent = mode === "number" ? "B·ªô s·ªë:" : "Label:";

                // Insert containers in visual order (avoid accidental reversal)
                const containersToAdd = mode === "label" ? [...containers].reverse() : containers;
                let anchor = inputLabel;
                containersToAdd.forEach(c => {
                    anchor.parentNode.insertBefore(c, anchor.nextSibling);
                    anchor = c;
                });

                // Navigation based on visual order (containersToAdd defines on-screen order)
                const navOrder = containersToAdd.map(c => parseInt(c.dataset.index, 10));
                const attachKeyHandlers = () => {
                    inputs.forEach((inp, logicalIdx) => {
                        inp.oninput = run;
                        inp.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const pos = navOrder.indexOf(logicalIdx);
                            if (pos === -1) return;
                            const nextPos = e.key === 'ArrowLeft'
                                ? (pos > 0 ? pos - 1 : navOrder.length - 1)
                                : (pos < navOrder.length - 1 ? pos + 1 : 0);
                            const targetIdx = navOrder[nextPos];
                            inputs[targetIdx]?.focus();
                        };
                    });
                };
                attachKeyHandlers();

                if (notify) setNumberPickerMode(mode);
                run();
            };

            // Toggle button click to switch modes and notify popup
            modeBtn.addEventListener('click', () => {
                const next = cell9ModeState === 'number' ? 'label' : 'number';
                applyCell9Mode(next, { notify: false });
            });

            // Initial handlers for first render: use current visual order
            const initialContainers = cell9ModeState === "label" ? [...containers].reverse() : containers;
            const initialNavOrder = initialContainers.map(c => parseInt(c.dataset.index, 10));
            inputs.forEach((inp, logicalIdx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                    e.preventDefault();
                    const pos = initialNavOrder.indexOf(logicalIdx);
                    if (pos === -1) return;
                    const nextPos = e.key === 'ArrowLeft'
                        ? (pos > 0 ? pos - 1 : initialNavOrder.length - 1)
                        : (pos < initialNavOrder.length - 1 ? pos + 1 : 0);
                    const targetIdx = initialNavOrder[nextPos];
                    inputs[targetIdx]?.focus();
                };
            });
            consec.onchange = run; clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function setValsIsSubset(setVals, arr) { for (const v of setVals) if (!arr.includes(v)) return false; return true; }
        function hasConsecutiveBlock(nums, setVals) {
            const k = setVals.size;
            for (let i = 0; i <= nums.length - k; i++) {
                const block = nums.slice(i, i + k);
                if (block.length === k && setValsIsSubset(setVals, block) && new Set(block).size === setVals.size) return true;
            }
            return false;
        }

        // Cell10: analyze other positions given value at order
        function renderCell10() {
            const body = sectionShell("cell10", "Cell10 ¬∑ Ph√¢n t√≠ch c√°c v·ªã tr√≠ kh√°c", "ƒêi·ªÅn 1 gi√° tr·ªã v√†o 1 √¥ ƒë·ªÉ xem ph√¢n b·ªë ·ªü 5 v·ªã tr√≠ c√≤n l·∫°i. C√≥ th·ªÉ k√©o th·∫£ gi·ªØa c√°c v·ªã tr√≠.");
            // Mode toggle: Number (1‚Äì45) vs Column (1‚Äì6)
            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : "number";
            let cell10ModeState = popupMode === "label" ? "column" : "number";
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell10ModeState === 'number' ? 'S·ªë (1‚Äì45)' : 'C·ªôt (1‚Äì6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // per-input scroll memory and last active index for cell10
            window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
            window._cell10LastIndex = window._cell10LastIndex ?? null;

            // Create draggable containers for inputs ‚Äî add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '‚ñ≤'; up.title = 'TƒÉng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '‚ñº'; down.title = 'Gi·∫£m 1'; down.style.cssText = arrowStyle;

                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };
                const clampForColumn = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 45) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 6) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 45;
                        if (n > 45) n = 45;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 6;
                        if (n > 6) n = 6;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                inp.addEventListener('change', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            if (run) run(idx);
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run(0);
                            }
                        } catch (err) { }
                    }
                    // K√©o s·ªë tr·ª±c ti·∫øp t·ª´ popup (ch·ªâ n·∫øu kh√¥ng ph·∫£i internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (cell10ModeState === 'number' && num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        } else if (cell10ModeState === 'column' && num >= 1 && num <= 45) {
                            const col = getCol(num);
                            inputs[idx].value = col;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // K√©o label t·ª´ header popup khi mode = column
                    else if (draggedIndex === null && labelData && cell10ModeState === 'column') {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run(idx);
                        draggedIndex = null;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        return;
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        if (run) run(idx);
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            // Add mode toggle button
            controls.append(modeBtn);
            containers.forEach(c => controls.appendChild(c)); body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run(changeIdx) {
                const prevScroll = window.scrollY;
                try {
                    if (changeIdx !== undefined && changeIdx !== null) {
                        window._cell10LastIndex = changeIdx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(changeIdx, prevScroll);
                    }
                } catch (e) { }

                const filled = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).filter(x => !isNaN(x.val));
                if (filled.length > 1 && changeIdx !== undefined) {
                    filled.filter(f => f.idx !== changeIdx).forEach(f => {
                        inputs[f.idx].value = "";
                        // Refresh drag visuals when value is cleared programmatically
                        inputs[f.idx].dispatchEvent(new Event("input"));
                    });
                }
                const single = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).find(x => !isNaN(x.val));
                if (!single) {
                    wrap.innerHTML = cell10ModeState === "number"
                        ? "<div class='loader'>ƒêi·ªÅn 1 s·ªë (1‚Äì45) v√†o 1 √¥...</div>"
                        : "<div class='loader'>ƒêi·ªÅn 1 c·ªôt (1‚Äì6) v√†o 1 √¥...</div>";
                    // restore scroll for same-input edits
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const order = single.idx + 1; const value = single.val;
                const posCols = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] }; const posMaps = { 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {} };
                let total = 0, hit = 0;
                const selectedPosNumbers = []; // Collect numbers at selected position for column mode
                rows.forEach(r => {
                    if (r.nums.length !== 6) return; total++;
                    const matched = (cell10ModeState === "number") ? (r.nums[order - 1] === value) : (getCol(r.nums[order - 1]) === value);
                    if (!matched) return; hit++;
                    if (cell10ModeState === "column") selectedPosNumbers.push(r.nums[order - 1]);
                    for (let pos = 1; pos <= 6; pos++) { if (pos === order) continue; const v = r.nums[pos - 1]; const c = getCol(v); posCols[pos].push(c); (posMaps[pos][c] ||= []).push(v); }
                });
                if (!hit) {
                    const what = cell10ModeState === "number" ? value : `c·ªôt ${value}`;
                    wrap.innerHTML = `<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o v·ªõi ${what} ·ªü v·ªã tr√≠ ${order}</div>`;
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const pattern = Array(6).fill("_"); pattern[order - 1] = (cell10ModeState === "number") ? value : `C${value}`;
                let html = `<div class='muted'>${hit}/${total} k·ª≥ (${(hit / total * 100).toFixed(2)}%) ¬∑ Pattern: ${pattern.join(',')}</div>`;

                // Show numbers at selected position for column mode
                if (cell10ModeState === "column" && selectedPosNumbers.length > 0) {
                    const numCounts = countMap(selectedPosNumbers);
                    const numsHtml = Object.entries(numCounts).sort((a, b) => b[1] - a[1]).map(([num, count]) =>
                        `<strong>${num}</strong><span style='font-weight:400'>(${count})</span>`
                    ).join(', ');
                    html += `<div style='margin-top:8px;font-weight:700;color:var(--text-strong);'>${numsHtml}</div>`;
                }

                const positionsBefore = [1, 2, 3, 4, 5, 6].filter(p => p < order);
                const positionsAfter = [1, 2, 3, 4, 5, 6].filter(p => p > order);
                const renderPosTable = (pos) => {
                    const counts = countMap(posCols[pos]);
                    let rowsHtml = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([c, n]) => {
                        const vals = countMap(posMaps[pos][c] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        return `<tr><td style='font-weight:700'>C·ªôt ${c}</td><td style='text-align:right;font-weight:700'>${n}</td><td style='text-align:right;font-weight:700'>${fmtPct(n / posCols[pos].length)}</td><td style='font-weight:700'>${valsHtml || '‚Äî'}</td></tr>`;
                    }).join("");
                    return `<div class='card'><h4>V·ªã tr√≠ ${pos}</h4><table><thead><tr><th>C·ªôt</th><th>S·ªë l·∫ßn</th><th>T·ª∑ l·ªá</th><th>S·ªë hay ƒëi c√πng</th></tr></thead><tbody>${rowsHtml}</tbody></table></div>`;
                };
                // Column-mode: compact 4-column table (Column | Count | Percentage | Numbers), 6 rows ranked
                const renderPosTableColumn = (pos) => {
                    const counts = countMap(posCols[pos]);
                    const totalPos = posCols[pos].length || 1;
                    const items = [1, 2, 3, 4, 5, 6].map(c => ({ col: c, count: counts[c] || 0, pct: (counts[c] || 0) / totalPos }));
                    items.sort((a, b) => b.count - a.count || a.col - b.col);
                    // Ensure each card is at most 1/3 of the row and centered
                    let t = `<div class='card' style='flex:0 1 calc(33.333% - 10px);'><h4 style='margin:0 0 8px;'>V·ªã tr√≠ ${pos}</h4><table><thead><tr><th>C·ªôt</th><th>S·ªë l·∫ßn</th><th>T·ª∑ l·ªá</th><th>S·ªë hay xu·∫•t hi·ªán</th></tr></thead><tbody>`;
                    items.forEach((it, idx) => {
                        const vals = countMap(posMaps[pos][it.col] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        t += `<tr><td style='font-weight:700'>${it.col}</td><td style='text-align:right;font-weight:700'>${it.count}</td><td style='text-align:right;font-weight:700'>${fmtPct(it.pct)}</td><td style='font-weight:700'>${valsHtml || '‚Äî'}</td></tr>`;
                    });
                    t += "</tbody></table></div>";
                    return t;
                };
                if (positionsBefore.length) html += `<h4>V·ªã tr√≠ tr∆∞·ªõc</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsBefore.map(renderPosTable) : positionsBefore.map(renderPosTableColumn)).join('')}</div>`;
                if (positionsAfter.length) html += `<h4>V·ªã tr√≠ sau</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsAfter.map(renderPosTable) : positionsAfter.map(renderPosTableColumn)).join('')}</div>`;
                wrap.innerHTML = html;
                // restore scroll for same-input edits (prevent jump-to-top)
                if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                    // small timeout to let layout settle
                    setTimeout(() => window.scrollTo(0, prevScroll), 0);
                }
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
                inp.addEventListener('focus', () => {
                    try {
                        window._cell10LastIndex = idx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(idx, window.scrollY);
                    } catch (e) { }
                });
            });
            clearBtn.onclick = () => {
                inputs.forEach(i => {
                    i.value = "";
                    // Refresh drag visuals after clear
                    i.dispatchEvent(new Event("input"));
                });
                run();
            };
            // Toggle button: adjust constraints, notify popup, clear values, rerun
            modeBtn.addEventListener('click', () => {
                cell10ModeState = cell10ModeState === 'number' ? 'column' : 'number';
                modeBtn.textContent = cell10ModeState === 'number' ? 'S·ªë (1‚Äì45)' : 'C·ªôt (1‚Äì6)';
                const newPopupMode = cell10ModeState === 'column' ? 'label' : 'number';
                if (window.setNumberPickerMode) window.setNumberPickerMode(newPopupMode);
                inputs.forEach(inp => {
                    if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                    else { inp.min = 1; inp.max = 6; inp.placeholder = '1‚Äì6'; }
                    inp.value = '';
                    inp.dispatchEvent(new Event('input'));
                });
                run();
            });
            // Subscribe to external mode changes
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    cell10ModeState = mode === 'label' ? 'column' : 'number';
                    modeBtn.textContent = cell10ModeState === 'number' ? 'S·ªë (1‚Äì45)' : 'C·ªôt (1‚Äì6)';
                    inputs.forEach(inp => {
                        if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                        else { inp.min = 1; inp.max = 6; inp.placeholder = '1‚Äì6'; }
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                    });
                    run();
                });
            }
            run();
        }
        function countMap(arr) { const m = {}; arr.forEach(v => m[v] = (m[v] || 0) + 1); return m; }

        // Cell11: pattern search 6 positions with commas, _ wildcard
        function renderCell11() {
            const body = sectionShell("cell11", "Cell11 ¬∑ T√¨m k·ª≥ theo Pattern s·ªë", "Nh·∫≠p s·ªë (1-45) v√†o t·ª´ng v·ªã tr√≠ ƒë·ªÉ t√¨m k·ª≥ kh·ªõp. C√≥ th·ªÉ k√©o th·∫£ s·ªë gi·ªØa c√°c v·ªã tr√≠ b·∫±ng chu·ªôt. B·ªè tr·ªëng v·ªã tr√≠ n√†o th√¨ v·ªã tr√≠ ƒë√≥ ch·∫•p nh·∫≠n s·ªë b·∫•t k·ª≥.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs ‚Äî add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                // small left-side grip so it doesn't cover the whole input and block typing
                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '‚ñ≤'; up.title = 'TƒÉng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '‚ñº'; down.title = 'Gi·∫£m 1'; down.style.cssText = arrowStyle;

                // clamp to [1,45]
                const clampNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    if (n > 45) n = 45;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampNumber(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run();
                            }
                        } catch (err) { }
                    }
                    // K√©o s·ªë tr·ª±c ti·∫øp t·ª´ popup (ch·ªâ n·∫øu kh√¥ng ph·∫£i internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Pattern:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            controls.appendChild(labelText);
            containers.forEach(c => controls.appendChild(c));
            body.appendChild(controls);

            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "X√≥a"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            // Add hint text
            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run(changeIdx) {
                const pattern = inputs.map(inp => {
                    const v = inp.value.trim();
                    if (!v) return "_";
                    const n = parseInt(v, 10);
                    return (n >= 1 && n <= 45) ? String(n) : "_";
                });
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Ch∆∞a c√≥ d·ªØ li·ªáu</div>"; return; }
                if (pattern.every(p => p === "_")) { wrap.innerHTML = "<div class='loader'>Nh·∫≠p v√†o 1 √¥ ƒë·ªÉ t√¨m ki·∫øm...</div>"; return; }
                const results = rows.filter(r => pattern.every((p, i) => p === "_" || r.nums[i] === Number(p)));
                if (!results.length) { wrap.innerHTML = "<div class='error'>Kh√¥ng c√≥ k·ª≥ n√†o kh·ªõp pattern</div>"; return; }
                const patternStr = pattern.join(',');
                let html = `<div class='muted'>${results.length} k·ª≥ ¬∑ pattern ${patternStr}</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < results.length; i += chunk) {
                    html += "<div class='card'><table><thead><tr><th>Ng√†y</th><th>KQ</th><th>Label</th><th>Euclid</th></tr></thead><tbody>";
                    results.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_" ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                        const highlightPositions = pattern.map((p, i) => p === "_" ? -1 : i).filter(i => i >= 0);
                        const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                        // compute euclidean distances between adjacent numbers (5 values) and total
                        let euclidPartsHtml = [];
                        let euclidTotal = 0;
                        try {
                            const npTable = document.getElementById('numberPickerTable');
                            const tbody = npTable ? npTable.querySelector('tbody') : null;
                            const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                            for (let j = 0; j < 5; j++) {
                                const n1 = r.nums[j];
                                const n2 = r.nums[j + 1];
                                let part = '';
                                if (npTable && tbodyRows.length > 0) {
                                    const cell1 = npTable.querySelector(`td[data-number="${n1}"]`);
                                    const cell2 = npTable.querySelector(`td[data-number="${n2}"]`);
                                    if (cell1 && cell2) {
                                        const rowElem1 = cell1.parentElement;
                                        const rowElem2 = cell2.parentElement;
                                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                                        const logicalRow1 = 7 - rowIdx1;
                                        const logicalRow2 = 7 - rowIdx2;
                                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                                        const dx = colIdx2 - colIdx1;
                                        const dy = logicalRow2 - logicalRow1;
                                        const d = Math.sqrt(dx * dx + dy * dy);
                                        part = isFinite(d) ? d.toFixed(2) : '';
                                        euclidTotal += isFinite(d) ? d : 0;
                                    }
                                }
                                if (part) {
                                    euclidPartsHtml.push(`<span class="euclid-pill">${part}</span>`);
                                } else {
                                    euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                                }
                            }
                        } catch (e) {
                            for (let j = 0; j < 5; j++) euclidPartsHtml.push(`<span class="euclid-pill empty">-</span>`);
                        }
                        const totalStr = euclidTotal.toFixed(2);
                        const euclidHtml = euclidPartsHtml.join('') + `<span class="euclid-total-pill">${totalStr}</span>`;
                        html += `<tr data-result="${r.nums.join(',')}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;font-family:monospace'>${euclidHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        async function bootstrap() {
            // Number picker popup
            const htmlBadge = document.getElementById('htmlBadge');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');
            const placesGrid = document.getElementById('placesGrid');
            let isPopupVisible = false;

            // Place state: [value1, value2, value3, value4, value5, value6]
            const placeValues = ['', '', '', '', '', ''];
            let draggedNumber = null;
            let draggedPlaceIndex = null;
            let draggedPlaceValue = null;
            let lastDropInsidePlace = false; // track if a place drag was dropped back into place
            let currentMode = 'number'; // 'number' or 'label'
            const modeListeners = new Set();

            const notifyModeChange = (mode, source) => {
                modeListeners.forEach(fn => fn(mode, source));
            };

            const setNumberPickerMode = (mode, source = 'picker') => {
                if (mode !== 'number' && mode !== 'label') return;
                if (currentMode === mode) return;
                currentMode = mode;
                modeSelector.value = mode;
                // Clear place values when switching mode
                placeValues.fill('');
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                notifyModeChange(mode, source);

                // Update connection toggle state when mode changes
                if (window.updateConnectionToggleState) {
                    window.updateConnectionToggleState();
                }

                // Update label cell styling based on new mode and place values
                updateLabelCellStyles();
            };

            window.setNumberPickerMode = (mode) => setNumberPickerMode(mode, 'external');
            window.getNumberPickerMode = () => currentMode;
            window.onNumberPickerModeChange = (cb) => {
                modeListeners.add(cb);
                return () => modeListeners.delete(cb);
            };

            // Quick-place toggle: two modes -> 'normal' (default) and 'hover' (hover a record to fill places)
            const quickPlaceToggleEl = document.getElementById('quickPlaceToggle');
            let quickPlaceMode = localStorage.getItem('quickPlaceMode') || 'normal';
            const setQuickPlaceMode = (mode) => {
                quickPlaceMode = mode === 'hover' ? 'hover' : 'normal';
                if (quickPlaceToggleEl) {
                    quickPlaceToggleEl.textContent = quickPlaceMode === 'normal' ? 'Normal' : 'Hover';
                    quickPlaceToggleEl.title = quickPlaceMode === 'normal'
                        ? "Normal: dblclick copies record to clipboard (existing behavior)"
                        : "Hover: hovering a record fills the place boxes (dblclick-copy disabled)";
                }
                localStorage.setItem('quickPlaceMode', quickPlaceMode);
            };
            window.getQuickPlaceMode = () => quickPlaceMode;
            // initialize
            setQuickPlaceMode(quickPlaceMode);
            if (quickPlaceToggleEl) {
                quickPlaceToggleEl.addEventListener('click', () => {
                    setQuickPlaceMode(quickPlaceMode === 'normal' ? 'hover' : 'normal');
                });
            }

            // Hover handler: when in 'hover' mode, moving mouse over any record row (tr[data-result])
            // will populate the placeValues and refresh place boxes. Throttled to avoid excessive updates.
            const hoverToPlaceHandler = createThrottle((e) => {
                try {
                    if (quickPlaceMode !== 'hover') return;
                    const tr = e.target.closest && e.target.closest('tr[data-result]');
                    if (!tr) return;
                    const text = tr.dataset.result;
                    if (!text) return;
                    const arr = text.split(',').map(s => (s || '').trim());
                    if (arr.length !== 6) return;

                    // Normalize and compare to avoid unnecessary work
                    let identical = true;
                    for (let i = 0; i < 6; i++) {
                        const v = arr[i] || '';
                        if ((placeValues[i] || '') !== v) { identical = false; break; }
                    }
                    if (identical) return;

                    // Clear previous visual highlights and overlays first to avoid stale backgrounds
                    try {
                        if (numberPickerTable) {
                            const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                            prev.forEach(p => p.classList.remove('selected-number'));
                            const disabledCells = numberPickerTable.querySelectorAll('td.number-cell.disabled');
                            disabledCells.forEach(c => c.classList.remove('selected-number'));
                        }
                        const existingOverlays = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                        existingOverlays.forEach(n => n.remove());
                        const placeBoxes = placesGrid.querySelectorAll('.place-box');
                        placeBoxes.forEach(pb => {
                            pb.classList.remove('filled');
                            const val = pb.querySelector('.place-box-value');
                            if (val) val.textContent = '_';
                            pb.style.removeProperty('backgroundColor');
                            pb.style.removeProperty('borderColor');
                        });
                    } catch (err) { /* ignore visual cleanup errors */ }

                    // Apply hovered values (replace all previous values)
                    for (let i = 0; i < 6; i++) placeValues[i] = arr[i] || '';

                    // Re-render and sync highlights/connections
                    generateNumberPickerTable();
                    generatePlaceBoxes();
                    try { if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights(); } catch (e) { }
                    drawConnections();
                } catch (err) { /* ignore */ }
            }, 80);
            document.addEventListener('mousemove', hoverToPlaceHandler, true);

            // Popup scale state
            const popupScaleState = { scale: 1.0 };

            const savePopupScale = () => {
                localStorage.setItem('popupScale', JSON.stringify(popupScaleState.scale));
            };

            const loadPopupScale = () => {
                const saved = localStorage.getItem('popupScale');
                if (saved) {
                    popupScaleState.scale = parseFloat(saved);
                }
            };

            const applyPopupScale = () => {
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
            };

            const applyPopupScaleInstant = () => {
                // Apply scale instantly without transition animation
                const oldTransition = numberPickerPopup.style.transition;
                numberPickerPopup.style.transition = 'none';
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
                // Force browser to process the change
                void numberPickerPopup.offsetHeight;
                numberPickerPopup.style.transition = oldTransition;
            };

            const addPopupScaleHandle = () => {
                let handle = numberPickerPopup.querySelector('.popup-scale-handle');
                if (handle) handle.remove();

                handle = document.createElement('div');
                handle.className = 'popup-scale-handle';

                let isScaling = false;
                let startX = 0;
                let startScale = popupScaleState.scale;

                handle.addEventListener('mousedown', (e) => {
                    isScaling = true;
                    startX = e.clientX;
                    startScale = popupScaleState.scale;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScaling) return;
                    const diff = e.clientX - startX;
                    const newScale = Math.max(0.5, Math.min(2, startScale + diff * 0.0025));
                    popupScaleState.scale = parseFloat(newScale.toFixed(3));
                    applyPopupScale();
                });

                document.addEventListener('mouseup', () => {
                    if (isScaling) {
                        isScaling = false;
                        savePopupScale();
                    }
                });

                numberPickerPopup.appendChild(handle);
            };

            loadPopupScale();

            // Generate number picker table (rotated 90¬∞ counter-clockwise)
            function generateNumberPickerTable() {
                const numbersInPlace = currentMode === 'number'
                    ? new Set(placeValues.filter(v => v && v.trim() && !isNaN(v)))
                    : new Set();

                const numbersByCol = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
                for (let i = 1; i <= 45; i++) {
                    const col = getCol(i);
                    numbersByCol[col].push(i);
                }

                const tbodyDisabled = currentMode === 'label' ? ' class="disabled"' : '';
                const tfootDisabled = currentMode === 'number' ? ' class="disabled"' : '';

                let html = `<tbody${tbodyDisabled}>`;
                for (let row = 7; row >= 0; row--) {
                    html += '<tr>';
                    for (let col = 1; col <= 6; col++) {
                        const nums = numbersByCol[col];
                        const num = nums[row] || '_';
                        if (num === '_') {
                            html += `<td style="color:var(--muted);opacity:0.5;">_</td>`;
                        } else {
                            const isDisabled = numbersInPlace.has(String(num));
                            const disabledClass = isDisabled ? ' disabled' : '';
                            const draggable = (isDisabled || currentMode === 'label') ? 'false' : 'true';
                            // Check rank toggle; when enabled, show [#x] inside the same cell, left-aligned,
                            // while keeping the number centered.
                            const rankToggleEl = document.getElementById('rankToggle');
                            const rankEnabled = !!rankToggleEl && rankToggleEl.textContent.trim() === 'rank';
                            if (rankEnabled) {
                                const rankMap = window.rankByTotal || {};
                                const r = rankMap[num] ?? '';
                                // Only render badge when we have a rank value
                                let badgeHtml = '';
                                if (r !== '' && r !== null && r !== undefined) {
                                    const rankNum = Number(r);
                                    let color = 'var(--muted)';
                                    if (!isNaN(rankNum)) {
                                        if (rankNum >= 1 && rankNum <= 9) color = '#08eb56';
                                        else if (rankNum >= 10 && rankNum <= 18) color = '#00E5FF';
                                        else if (rankNum >= 19 && rankNum <= 27) color = '#1a62ea';
                                        else if (rankNum >= 28 && rankNum <= 36) color = '#ea3ade';
                                        else if (rankNum >= 37 && rankNum <= 45) color = '#ea0313';
                                    }
                                    badgeHtml = `<span class="rank-in-cell" style="position:absolute;left:6px;top:50%;transform:translateY(-50%);font-size:0.92em;font-weight:900;color:${color};background:transparent;opacity:1;z-index:2;-webkit-text-stroke:0.4px rgba(0,0,0,0.6);text-shadow:0 0 1px rgba(0,0,0,0.22);letter-spacing:0.6px;">#${rankNum}</span>`;
                                }
                                html += `<td class="number-cell${disabledClass}" draggable="${draggable}" data-number="${num}" style="position:relative;min-height:44px;">` +
                                    `${badgeHtml}` +
                                    `<span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span>` +
                                    `</td>`;
                            } else {
                                html += `<td class="number-cell${disabledClass}" draggable="${draggable}" data-number="${num}"><span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span></td>`;
                            }
                        }
                    }
                    html += '</tr>';
                }
                html += '</tbody>';

                html += `<tfoot${tfootDisabled}><tr>`;
                for (let col = 1; col <= 6; col++) {
                    html += `<th class="label-cell" data-label="C${col}" draggable="true" style="cursor: grab;">C${col}</th>`;
                }
                html += '</tr></tfoot>';

                numberPickerTable.innerHTML = html;

                // Draw connections after table is rendered
                requestAnimationFrame(() => drawConnections());
            }

            // Draw connections between consecutive numbers in place boxes
            function drawConnections() {
                const connectionToggle = document.getElementById('connectionToggle');
                const connectionsEnabled = !!connectionToggle && connectionToggle.textContent.trim() === 'Hi·ªán';
                const euclidToggle = document.getElementById('euclidToggle');
                const euclidEnabled = !!euclidToggle && euclidToggle.textContent.trim() === 'Hi·ªán';
                // Only draw in number mode and when connections are enabled
                if (currentMode !== 'number' || !connectionsEnabled) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Find consecutive pairs in placeValues
                const pairs = [];
                for (let i = 0; i < placeValues.length - 1; i++) {
                    const curr = placeValues[i];
                    const next = placeValues[i + 1];
                    if (curr && curr.trim() && !isNaN(curr) && next && next.trim() && !isNaN(next)) {
                        pairs.push([parseInt(curr, 10), parseInt(next, 10)]);
                    }
                }

                if (pairs.length === 0) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Get or create canvas
                let canvas = document.getElementById('connectionCanvas');
                const wrapper = numberPickerTable.parentElement;

                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.id = 'connectionCanvas';
                    canvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:1';
                    wrapper.appendChild(canvas);
                }

                const tableRect = numberPickerTable.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();

                // Get current popup scale
                const scale = popupScaleState.scale;

                // Get device pixel ratio for sharp rendering
                const dpr = window.devicePixelRatio || 1;

                // Canvas should match unscaled table size (divide by scale)
                const canvasWidth = tableRect.width / scale;
                const canvasHeight = tableRect.height / scale;

                // Set canvas display size (CSS pixels, unscaled)
                canvas.style.width = canvasWidth + 'px';
                canvas.style.height = canvasHeight + 'px';

                // Set canvas actual size (device pixels)
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;

                // Position canvas to align with table within wrapper (unscaled coordinates)
                canvas.style.left = '0px';
                canvas.style.top = '0px';

                const ctx = canvas.getContext('2d');
                // Scale context to match device pixel ratio
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Store circle centers for line drawing
                const circleCenters = {};
                const circleRadius = 9;

                // Theme-aware colors
                const cssVars = getComputedStyle(document.documentElement);
                const lineColor = (cssVars.getPropertyValue('--connection-line-color') || '#00cc00').trim();
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const circleColor = currentTheme === 'light' ? lineColor : '#667eea';

                // Draw circles around all numbers in placeValues
                const allNumbers = placeValues
                    .filter(v => v && v.trim() && !isNaN(v))
                    .map(v => parseInt(v, 10));

                allNumbers.forEach(num => {
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (!cell) return;

                    const cellRect = cell.getBoundingClientRect();

                    // Apply scale factor to coordinates
                    const x = (cellRect.left - tableRect.left) / scale + (cellRect.width / scale) / 2;
                    const y = (cellRect.top - tableRect.top) / scale + (cellRect.height / scale) / 2;

                    // Store center for line drawing
                    circleCenters[num] = { x, y };

                    // Draw circle (stroke, not fill)
                    ctx.strokeStyle = circleColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                // Draw lines between consecutive pairs, starting from circle edge
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);

                pairs.forEach(([num1, num2]) => {
                    const center1 = circleCenters[num1];
                    const center2 = circleCenters[num2];
                    if (!center1 || !center2) return;

                    const x1 = center1.x;
                    const y1 = center1.y;
                    const x2 = center2.x;
                    const y2 = center2.y;

                    // Calculate angle from center1 to center2
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    // Start line from the edge of circle1, pointing toward circle2
                    const startX = x1 + circleRadius * Math.cos(angle);
                    const startY = y1 + circleRadius * Math.sin(angle);

                    // End line at the edge of circle2, pointing back toward circle1
                    const endX = x2 - circleRadius * Math.cos(angle);
                    const endY = y2 - circleRadius * Math.sin(angle);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // --- Draw Euclidean distance (in grid cell units) near the middle of the line ---
                    try {
                        // Find grid row/col indices by inspecting tbody rows and cell positions
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${num1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${num2}"]`);
                        if (cell1 && cell2 && tbodyRows.length > 0) {
                            const rowElem1 = cell1.parentElement;
                            const rowElem2 = cell2.parentElement;
                            const rowIdx1 = tbodyRows.indexOf(rowElem1); // 0..n-1 (top -> bottom)
                            const rowIdx2 = tbodyRows.indexOf(rowElem2);

                            // In generator rows are created from row=7 down to 0, so logicalRow = 7 - rowIndex
                            const logicalRow1 = 7 - rowIdx1;
                            const logicalRow2 = 7 - rowIdx2;

                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1); // 0..5 left->right
                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);

                            const dx = colIdx2 - colIdx1;
                            const dy = logicalRow2 - logicalRow1;
                            const gridDistance = Math.sqrt(dx * dx + dy * dy);

                            // Midpoint of drawn segment
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;

                            // Place label directly on the line midpoint (overlay the connection)
                            const labelX = midX;
                            const labelY = midY;

                            // Draw label background for readability (only when euclid toggle enabled)
                            if (euclidEnabled) {
                                const labelText = gridDistance.toFixed(2);
                                ctx.save();
                                ctx.setLineDash([]);
                                ctx.font = '12px Inter, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                // measure
                                const metrics = ctx.measureText(labelText);
                                const paddingX = 6;
                                const paddingY = 3;
                                const rectW = metrics.width + paddingX * 2;
                                const rectH = 12 + paddingY * 2;

                                // Semi-transparent background
                                ctx.fillStyle = currentTheme === 'light' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.7)';
                                ctx.beginPath();
                                ctx.roundRect
                                    ? ctx.roundRect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH, 4)
                                    : ctx.rect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH);
                                ctx.fill();

                                // Draw text
                                ctx.fillStyle = currentTheme === 'light' ? '#000' : '#fff';
                                ctx.fillText(labelText, labelX, labelY);
                                ctx.restore();
                            }
                        }
                    } catch (e) {
                        // ignore label drawing errors to avoid breaking connections
                    }
                });
            }

            // Generate place boxes - 6 individual boxes
            function generatePlaceBoxes() {
                placesGrid.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const placeBox = document.createElement('div');
                    placeBox.className = `place-box ${placeValues[i] ? 'filled' : ''}`;
                    placeBox.dataset.placeIndex = i;
                    // Always allow dragging so an empty slot can receive a swapped value
                    placeBox.draggable = true;

                    // Dblclick to paste clipboard into all 6 slots (number mode only)
                    placeBox.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        pasteClipboardToPlaces();
                    });

                    const value = document.createElement('div');
                    value.className = 'place-box-value';
                    value.textContent = placeValues[i] || '_';
                    placeBox.appendChild(value);

                    placeBox.addEventListener('dragstart', (e) => {
                        draggedPlaceIndex = i;
                        draggedPlaceValue = placeValues[i];
                        lastDropInsidePlace = false;
                        e.dataTransfer.effectAllowed = 'copyMove';
                        e.dataTransfer.setData('text/plain', placeValues[i] || '');
                        e.dataTransfer.setData('application/x-place-index', String(i));
                        e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    });

                    placeBox.addEventListener('dragend', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        if (!lastDropInsidePlace && draggedPlaceValue) {
                            placeValues[draggedPlaceIndex] = '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                        draggedPlaceIndex = null;
                        draggedPlaceValue = null;
                    });

                    placeBox.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                        placeBox.style.borderColor = 'var(--accent-2)';
                        placeBox.style.backgroundColor = 'rgba(102, 126, 234, 0.25)';
                    });

                    placeBox.addEventListener('dragleave', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';
                    });

                    placeBox.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        lastDropInsidePlace = true;
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';

                        if (draggedPlaceIndex !== null && draggedPlaceIndex !== i) {
                            const tmp = placeValues[i];
                            placeValues[i] = draggedPlaceValue || '';
                            placeValues[draggedPlaceIndex] = tmp || '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            document.querySelectorAll('.place-box').forEach(box => {
                                box.style.removeProperty('borderColor');
                                box.style.removeProperty('backgroundColor');
                                box.style.removeProperty('opacity');
                            });
                            const placeContainer = numberPickerPopup.querySelector('.place-container');
                            if (placeContainer) {
                                placeContainer.style.removeProperty('borderColor');
                                placeContainer.style.removeProperty('backgroundColor');
                                placeContainer.style.removeProperty('opacity');
                            }
                            return;
                        }

                        let data = e.dataTransfer.getData('application/x-place-set');
                        if (data) {
                            try {
                                const values = JSON.parse(data);
                                for (let j = 0; j < 6; j++) {
                                    placeValues[j] = values[j] || '';
                                }
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                                return;
                            } catch (err) { }
                        }

                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData && currentMode === 'label') {
                            const colNum = labelData.replace('C', '');
                            placeValues[i] = colNum;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                            return;
                        }

                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num) && currentMode === 'number') {
                            placeValues[i] = num;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                    });

                    placesGrid.appendChild(placeBox);
                }
                // remove old overlays if any
                const existing = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                existing.forEach(n => n.remove());

                // helper: compute grid distance like drawConnections does
                function computeGridDistance(n1, n2) {
                    try {
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${n1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${n2}"]`);
                        if (!cell1 || !cell2 || tbodyRows.length === 0) return null;
                        const rowElem1 = cell1.parentElement;
                        const rowElem2 = cell2.parentElement;
                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                        const logicalRow1 = 7 - rowIdx1;
                        const logicalRow2 = 7 - rowIdx2;
                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                        const dx = colIdx2 - colIdx1;
                        const dy = logicalRow2 - logicalRow1;
                        return Math.sqrt(dx * dx + dy * dy);
                    } catch (e) { return null; }
                }

                // For each adjacent pair, if both filled and euclid enabled, create overlay
                const boxes = placesGrid.querySelectorAll('.place-box');
                // position overlays relative to the places grid so they sit centered
                // between the .place-box elements even when the popup is scrolled
                const containerRect = placesGrid.getBoundingClientRect();
                for (let i = 0; i < boxes.length - 1; i++) {
                    const a = placeValues[i];
                    const b = placeValues[i + 1];
                    if (currentMode === 'number' && euclidState && a && b && !isNaN(a) && !isNaN(b)) {
                        const boxA = boxes[i];
                        const boxB = boxes[i + 1];
                        if (!boxA || !boxB) continue;
                        // compute centers relative to placesGrid using offset values
                        const aCenterX = boxA.offsetLeft + boxA.offsetWidth / 2;
                        const bCenterX = boxB.offsetLeft + boxB.offsetWidth / 2;
                        const aCenterY = boxA.offsetTop + boxA.offsetHeight / 2;
                        const bCenterY = boxB.offsetTop + boxB.offsetHeight / 2;
                        const midX = (aCenterX + bCenterX) / 2;
                        const midY = (aCenterY + bCenterY) / 2;
                        const overlay = document.createElement('div');
                        overlay.className = 'place-distance-overlay';
                        const dist = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                        overlay.textContent = dist === null ? '' : dist.toFixed(2);
                        // set position inside placesGrid (no viewport -> container conversion needed)
                        overlay.style.left = midX + 'px';
                        overlay.style.top = midY + 'px';
                        placesGrid.appendChild(overlay);
                    }
                }
                // Compute total Euclidean distance for adjacent pairs and update display
                try {
                    const euclidTotalEl = document.getElementById('euclidTotal');
                    let total = 0;
                    for (let j = 0; j < boxes.length - 1; j++) {
                        const a = placeValues[j];
                        const b = placeValues[j + 1];
                        if (currentMode === 'number' && a && b && !isNaN(a) && !isNaN(b)) {
                            const d = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                            if (d !== null) total += d;
                        }
                    }
                    if (euclidTotalEl) {
                        // update nested value span if present
                        const valEl = document.getElementById('euclidTotalValue');
                        if (valEl) {
                            valEl.textContent = total.toFixed(2);
                            // ensure accent green emphasis remains
                            valEl.style.color = '#38ef7d';
                        } else {
                            euclidTotalEl.textContent = `Œ£: ${total.toFixed(2)}`;
                        }
                        euclidTotalEl.style.opacity = (euclidState && currentMode === 'number') ? '1' : '0.5';
                    }
                } catch (e) { /* ignore */ }
                // Sync label and number highlights and redraw connections
                try {
                    updateLabelCellStyles();
                } catch (e) { /* ignore */ }
                try {
                    if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights();
                } catch (e) { /* ignore */ }
                try { drawConnections(); } catch (e) { /* ignore */ }
            }

            function setupPlaceContainerListeners() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                placeContainer.draggable = true;

                placeContainer.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.dataTransfer.setData('text/plain', JSON.stringify(placeValues));
                    e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    placeContainer.style.opacity = '0.6';
                });

                placeContainer.addEventListener('dragend', () => {
                    placeContainer.style.opacity = '1';
                });

                placeContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                });

                placeContainer.addEventListener('dragleave', (e) => {
                    if (e.target === placeContainer) {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }
                });

                placeContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    lastDropInsidePlace = true;
                    placeContainer.style.borderColor = 'var(--accent)';
                    placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';

                    if (currentMode === 'number') {
                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num)) {
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = num;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                            }
                        }
                    } else if (currentMode === 'label') {
                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData) {
                            const colNum = labelData.replace('C', '');
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = colNum;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                            }
                        }
                    }
                });
            }

            function setupNumberCellDragDrop() {
                // Use event delegation on the table to ensure handlers work
                // after the table is re-rendered and to avoid duplicate listeners.
                if (!numberPickerTable) return;
                if (numberPickerTable.dataset.dragDelegation === 'true') return;
                numberPickerTable.dataset.dragDelegation = 'true';

                numberPickerTable.addEventListener('dragstart', (e) => {
                    const cell = e.target.closest('.number-cell');
                    if (!cell) return;
                    // Respect explicit draggable attribute set on cells
                    const draggableAttr = cell.getAttribute('draggable');
                    if (draggableAttr === 'false') return;
                    draggedNumber = cell.dataset.number;
                    try {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', draggedNumber);
                    } catch (err) {
                        // Some environments may restrict dataTransfer; fail silently
                    }
                });

                numberPickerTable.addEventListener('dragend', () => {
                    draggedNumber = null;
                });
            }

            function setupLabelCellDragDrop() {
                if (!numberPickerTable) return;
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    // Skip if already setup (has data attribute)
                    if (cell.dataset.dragSetup === 'true') return;

                    // Clone to remove all old event listeners
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    // Explicitly set draggable to ensure it works after cloneNode
                    newCell.draggable = true;
                    newCell.dataset.dragSetup = 'true';

                    newCell.addEventListener('dragstart', (e) => {
                        const label = newCell.dataset.label;
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('application/x-label', label);
                        newCell.style.opacity = '0.5';
                    });

                    newCell.addEventListener('dragend', () => {
                        newCell.style.opacity = '1';
                    });
                });
            }

            // Update label cell styling based on place values
            function updateLabelCellStyles() {
                if (!numberPickerTable) return;
                const tfoot = numberPickerTable.tFoot;

                if (currentMode !== 'number') {
                    // In label mode, make all label cells bright and draggable (only inside popup)
                    const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                    labelCells.forEach(cell => cell.classList.add('with-values'));
                    if (tfoot) tfoot.classList.remove('disabled');
                    return;
                }

                // In number mode, determine which columns have values in placeValues
                const columnsWithValues = new Set();
                placeValues.forEach(val => {
                    if (val && val.trim() && !isNaN(val)) {
                        const num = parseInt(val, 10);
                        const col = getCol(num); // Use existing getCol helper
                        columnsWithValues.add(col);
                    }
                });

                // If any columns have values, remove disabled class from tfoot to show labels bright
                if (columnsWithValues.size > 0) {
                    if (tfoot) tfoot.classList.remove('disabled');
                } else {
                    if (tfoot) tfoot.classList.add('disabled');
                }

                // Update label cell styling
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    const label = cell.dataset.label; // e.g., "C1", "C2", ...
                    const colNum = parseInt(label.substring(1), 10); // Extract column number
                    if (columnsWithValues.has(colNum)) {
                        cell.classList.add('with-values');
                    } else {
                        cell.classList.remove('with-values');
                    }
                });
            }

            // Update number-cell highlights to match placeValues
            function updateNumberCellHighlights() {
                if (!numberPickerTable) return;
                // remove previous highlights
                const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                prev.forEach(p => p.classList.remove('selected-number'));

                if (currentMode !== 'number') return;

                // add highlight for each placed number
                placeValues.forEach(v => {
                    if (!v || v === '' || isNaN(v)) return;
                    const num = String(parseInt(v, 10));
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (cell) cell.classList.add('selected-number');
                });
            }

            const modeSelector = document.getElementById('modeSelector');
            let modeState = 'number';
            modeSelector.addEventListener('click', () => {
                modeState = modeState === 'number' ? 'label' : 'number';
                modeSelector.textContent = modeState === 'number' ? 'S·ªë (1-45)' : 'Label (C1-C6)';
                setNumberPickerMode(modeState, 'picker');
            });

            const modeRows = document.getElementById('modeRows');
            // Sync mode button when mode changes from external sources (cell9/10)
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    modeState = mode;
                    modeSelector.textContent = mode === 'number' ? 'S·ªë (1-45)' : 'Label (C1-C6)';
                });
            }

            // Connection toggle
            const connectionToggle = document.getElementById('connectionToggle');
            const connectionToggleLabel = document.getElementById('connectionToggleLabel');
            const euclidToggle = document.getElementById('euclidToggle');
            const euclidToggleLabel = document.getElementById('euclidToggleLabel');

            const updateConnectionToggleState = () => {
                const isNumberMode = currentMode === 'number';
                connectionToggle.disabled = !isNumberMode;
                if (connectionToggleLabel) {
                    connectionToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                }
                connectionToggle.style.opacity = isNumberMode ? '1' : '0.5';
                connectionToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Euclid toggle should follow same availability rules as connection toggle
                if (euclidToggle) euclidToggle.disabled = !isNumberMode;
                if (euclidToggleLabel) euclidToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Update Euclid total display availability
                const euclidTotalEl = document.getElementById('euclidTotal');
                if (euclidTotalEl) euclidTotalEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';
                // also dim the numeric value if present
                const euclidValEl = document.getElementById('euclidTotalValue');
                if (euclidValEl) euclidValEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';

                // Redraw when toggled
                drawConnections();
            };

            // Expose globally for mode change callback
            window.updateConnectionToggleState = updateConnectionToggleState;

            let connectionState = true;
            connectionToggle.addEventListener('click', () => {
                connectionState = !connectionState;
                connectionToggle.textContent = connectionState ? 'Hi·ªán' : '·∫®n';
                drawConnections();
            });

            // Euclid toggle state and handler
            let euclidState = true; // default visible
            if (euclidToggle) {
                euclidToggle.textContent = euclidState ? 'Hi·ªán' : '·∫®n';
                euclidToggle.addEventListener('click', () => {
                    euclidState = !euclidState;
                    euclidToggle.textContent = euclidState ? 'Hi·ªán' : '·∫®n';
                    drawConnections();
                    // Refresh place overlays and Euclid total display
                    try { generatePlaceBoxes(); } catch (e) { /* ignore if not ready */ }
                });
            }

            // Initialize connection toggle state
            updateConnectionToggleState();

            // Paste clipboard into place (dblclick on any place box) when in number mode
            async function pasteClipboardToPlaces() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                const flashFail = (reason) => {
                    console.log('Paste failed:', reason);
                    if (!placeContainer) return;
                    placeContainer.style.borderColor = '#ef4444';
                    placeContainer.style.backgroundColor = 'rgba(239, 68, 68, 0.14)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 450);
                };

                if (currentMode !== 'number') {
                    flashFail('wrong mode: ' + currentMode);
                    return;
                }

                const readClipboard = async () => {
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        return navigator.clipboard.readText();
                    }
                    if (window.clipboardData && window.clipboardData.getData) {
                        return window.clipboardData.getData('Text');
                    }
                    return null;
                };

                let txt = null;
                try {
                    txt = await readClipboard();
                    console.log('Raw clipboard result:', JSON.stringify(txt));
                } catch (err) {
                    console.error('Clipboard read error:', err);
                    flashFail('clipboard error: ' + err.message);
                    return;
                }

                if (txt === null || txt === undefined) {
                    console.error('Clipboard returned null - API blocked or not available');
                    flashFail('clipboard blocked (ch·∫°y qua http:// thay v√¨ file://)');
                    return;
                }

                txt = txt.trim();
                if (!txt) {
                    flashFail('clipboard empty');
                    return;
                }

                const parts = txt.split(',').map(s => s.trim());
                console.log('Parts after split:', parts, 'length:', parts.length);
                if (parts.length !== 6) {
                    flashFail(`expected 6 parts, got ${parts.length}`);
                    return;
                }
                const next = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i];
                    if (p === '' || p === '_') { next.push(''); continue; }
                    const n = parseInt(p, 10);
                    console.log(`Part ${i}: "${p}" -> ${n}, valid: ${Number.isFinite(n) && n >= 1 && n <= 45}`);
                    if (!Number.isFinite(n) || n < 1 || n > 45) {
                        flashFail(`invalid number at position ${i + 1}: "${p}"`);
                        return;
                    }
                    next.push(String(n));
                }

                console.log('Paste successful:', next);
                for (let i = 0; i < 6; i++) placeValues[i] = next[i] || '';
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
                if (placeContainer) {
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 400);
                }
            }

            const clearPlaceBtn = document.getElementById('clearPlaceBtn');
            clearPlaceBtn.addEventListener('click', () => {
                for (let i = 0; i < placeValues.length; i++) {
                    placeValues[i] = '';
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
            });

            // Optional color picker (removed from UI) ‚Äî attach listener only if element exists
            const cellColorPicker = document.getElementById('cellColorPicker');
            if (cellColorPicker) {
                cellColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    // Update CSS variable instead of inline style to preserve hover effects
                    document.documentElement.style.setProperty('--cell-bg-color', color);
                });
            }

            // Wrap table in a relative-positioned container
            const tableWrapper = document.createElement('div');
            tableWrapper.style.position = 'relative';
            numberPickerTable.parentElement.insertBefore(tableWrapper, numberPickerTable);
            tableWrapper.appendChild(numberPickerTable);

            generateNumberPickerTable();
            generatePlaceBoxes();
            setupPlaceContainerListeners();
            setupNumberCellDragDrop();
            setupLabelCellDragDrop();

            // Rank toggle handler: toggles between 'unnank' and 'rank' and re-renders the table
            const rankToggleBtn = document.getElementById('rankToggle');
            if (rankToggleBtn) {
                rankToggleBtn.addEventListener('click', () => {
                    const cur = rankToggleBtn.textContent.trim();
                    const next = cur === 'rank' ? 'unnank' : 'rank';
                    rankToggleBtn.textContent = next;
                    // Re-generate table to show/hide ranks
                    try { generateNumberPickerTable(); setupNumberCellDragDrop(); } catch (e) { console.warn(e); }
                });
            }

            // Apply saved scale and add scale handle
            applyPopupScale();
            addPopupScaleHandle();

            // Helper: desired popup alpha based on inline slider (preserve across open/close)
            const __POPUP_MIN_ALPHA = 0.15;
            function __desiredPopupAlpha() {
                try {
                    const el = document.getElementById('popupOpacityRangeInline');
                    if (!el) return 1;
                    const pct = Number(el.value || 0);
                    if (pct === 0) return 1;
                    return 1 - (pct / 100) * (1 - __POPUP_MIN_ALPHA);
                } catch (e) { return 1; }
            }

            // Close button
            const closeNumberPickerBtn = document.getElementById('closeNumberPickerBtn');
            closeNumberPickerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                isPopupVisible = false;
                numberPickerPopup.style.opacity = '0';
                setTimeout(() => {
                    numberPickerPopup.style.display = 'none';
                }, 300);
                // Hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.remove('visible');
                }
            });

            // Toggle popup on click
            htmlBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                isPopupVisible = !isPopupVisible;

                if (isPopupVisible) {
                    // Apply scale BEFORE showing to prevent flash
                    applyPopupScaleInstant();

                    const savedPos = localStorage.getItem('popupPosition');
                    if (savedPos) {
                        const { top, left } = JSON.parse(savedPos);
                        numberPickerPopup.style.top = `${top}px`;
                        numberPickerPopup.style.left = `${left}px`;
                    } else {
                        const rect = htmlBadge.getBoundingClientRect();
                        numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                        numberPickerPopup.style.left = `${rect.left}px`;
                    }

                    // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                    numberPickerPopup.style.display = 'block';
                    numberPickerPopup.style.opacity = '0';

                    requestAnimationFrame(() => {
                        numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                    });
                } else {
                    numberPickerPopup.style.opacity = '0';
                    setTimeout(() => {
                        numberPickerPopup.style.display = 'none';
                    }, 300);
                }

                // Show/hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.toggle('visible', isPopupVisible);
                }
            });

            // Toggle popup with Ctrl
            let ctrlPressed = false;
            let ctrlWithOtherKey = false;
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control' && !e.repeat) {
                    ctrlPressed = true;
                    ctrlWithOtherKey = false;
                } else if (ctrlPressed && e.key !== 'Control') {
                    ctrlWithOtherKey = true;
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control' && ctrlPressed && !ctrlWithOtherKey) {
                    isPopupVisible = !isPopupVisible;
                    if (isPopupVisible) {
                        // Apply scale BEFORE showing
                        applyPopupScaleInstant();

                        const savedPos = localStorage.getItem('popupPosition');
                        if (savedPos) {
                            const { top, left } = JSON.parse(savedPos);
                            numberPickerPopup.style.top = `${top}px`;
                            numberPickerPopup.style.left = `${left}px`;
                        } else {
                            const rect = htmlBadge.getBoundingClientRect();
                            numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                            numberPickerPopup.style.left = `${rect.left}px`;
                        }

                        // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                        numberPickerPopup.style.display = 'block';
                        numberPickerPopup.style.opacity = '0';

                        requestAnimationFrame(() => {
                            numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                        });
                    } else {
                        numberPickerPopup.style.opacity = '0';
                        setTimeout(() => {
                            numberPickerPopup.style.display = 'none';
                        }, 300);
                    }

                    // Show/hide scale handle
                    const handle = document.querySelector('.popup-scale-handle');
                    if (handle) {
                        handle.classList.toggle('visible', isPopupVisible);
                    }
                }
                if (e.key === 'Control') {
                    ctrlPressed = false;
                    ctrlWithOtherKey = false;
                }
            });

            // Make popup draggable by background
            let popupOffsetX = 0, popupOffsetY = 0, isDraggingPopup = false;
            numberPickerPopup.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on close button
                if (e.target.closest('.number-picker-close-btn')) {
                    return;
                }
                if (e.target === numberPickerPopup) {
                    isDraggingPopup = true;
                    const rect = numberPickerPopup.getBoundingClientRect();
                    popupOffsetX = e.clientX - rect.left;
                    popupOffsetY = e.clientY - rect.top;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (isDraggingPopup) {
                    const newLeft = e.clientX - popupOffsetX;
                    const newTop = e.clientY - popupOffsetY;
                    numberPickerPopup.style.left = newLeft + 'px';
                    numberPickerPopup.style.top = newTop + 'px';
                    localStorage.setItem('popupPosition', JSON.stringify({ top: newTop, left: newLeft }));
                }
            });
            document.addEventListener('mouseup', () => { isDraggingPopup = false; });

            // Expose placeValues globally
            window.getPlaceValues = () => placeValues;
            window.markPlaceDropHandled = () => { lastDropInsidePlace = true; };
            window.setPlaceValues = (values) => {
                if (Array.isArray(values)) {
                    for (let i = 0; i < 6; i++) {
                        const v = values[i];
                        placeValues[i] = (v === undefined || v === null) ? '' : v;
                    }
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
            };
            window.applyPlaceValuesToInputs = (inputArray) => {
                if (inputArray && inputArray.length >= 6) {
                    for (let i = 0; i < 6; i++) {
                        const val = placeValues[i];
                        if (val && !isNaN(val)) {
                            inputArray[i].value = val;
                            inputArray[i].dispatchEvent(new Event('input'));
                        }
                    }
                }
            };

            // Scroll to top button
            const scrollBtn = document.getElementById('scrollToTop');
            scrollBtn.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'flex';
                    scrollBtn.style.alignItems = 'center';
                    scrollBtn.style.justifyContent = 'center';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });

            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            const root = document.documentElement;
            const savedTheme = localStorage.getItem('theme') || 'light';
            root.setAttribute('data-theme', savedTheme);
            themeToggle.onclick = () => {
                const current = root.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                // Redraw connection lines to apply theme-specific colors
                try { drawConnections(); } catch { }
            };

            // T·∫£i d·ªØ li·ªáu TR∆Ø·ªöC khi render c√°c cell
            await loadData();

            // Compute global rank (by total count) so popup can show ranks
            try {
                const totalCounts = Array(46).fill(0);
                rows.forEach(r => { if (r.nums && r.nums.length === 6) r.nums.forEach(v => { totalCounts[v] = (totalCounts[v] || 0) + 1; }); });
                const ranked = [];
                for (let v = 1; v <= 45; v++) ranked.push({ v, cnt: totalCounts[v] || 0 });
                ranked.sort((a, b) => b.cnt - a.cnt || a.v - b.v);
                const rankByTotal = {};
                ranked.forEach((r, idx) => { rankByTotal[r.v] = idx + 1; });
                window.rankByTotal = rankByTotal;
                // Regenerate the number picker table now that ranks are available
                try { if (typeof generateNumberPickerTable === 'function') generateNumberPickerTable(); } catch (e) { console.warn('regen number picker after rank compute', e); }
            } catch (e) { window.rankByTotal = {}; }

            const showSection = createSectionSwitcher();
            // Renderer map for lazy section mounting
            const renderers = {
                cell4: renderCell4,
                cell5: renderCell5,
                // Note: mismatched creators ‚Äì keep ids aligned with sections created inside
                cell6: renderCell8, // Ph√¢n nh√≥m theo b·ªô s·ªë
                cell6_5: renderCell6_5, // Truy x (l·ªçc theo s·ªë x)
                cell7: renderCell6, // Nh√≥m theo label
                cell8: renderCell7, // T√¨m ki·∫øm theo Label
                cell9: renderCell9,
                cell10: renderCell10,
                cell11: renderCell11,
            };

            // Expose ensureRendered globally for nav handlers
            window.ensureRendered = function ensureRendered(id) {
                if (!document.getElementById(id)) {
                    const fn = renderers[id];
                    if (typeof fn === 'function') fn();
                }
            };

            buildNav(showSection);
            // Hi·ªÉn th·ªã section theo hash (n·∫øu h·ª£p l·ªá), m·∫∑c ƒë·ªãnh cell4
            const initial = (location.hash || "#cell4").replace("#", "");
            // Lazy mount only the initial section
            window.ensureRendered(initial || "cell4");
            showSection(initial || "cell4");
            window.addEventListener("hashchange", () => {
                const id = (location.hash || "#cell4").replace("#", "");
                window.ensureRendered(id || "cell4");
                showSection(id || "cell4");
            });
        }

        // Tag nested cards inside `.card.card-inner` with `card-inner-child`.
        (function markInnerChildCards() {
            function mark() {
                document.querySelectorAll('.card.card-inner').forEach(wrapper => {
                    wrapper.querySelectorAll('.card').forEach(child => {
                        if (!child.classList.contains('card-inner-child')) child.classList.add('card-inner-child');
                    });
                    // If the wrapper contains exactly one descendant marked as card-inner-child,
                    // mark the wrapper with `single-child` so CSS can target descendant-only cases.
                    try {
                        const innerChildren = wrapper.querySelectorAll('.card-inner-child');
                        if (innerChildren.length === 1) wrapper.classList.add('single-child');
                        else wrapper.classList.remove('single-child');
                    } catch (e) { /* ignore */ }
                });
            }
            // initial pass
            try { mark(); } catch (e) { }
            // watch for future additions
            try {
                const mo = new MutationObserver(mark);
                mo.observe(document.body, { childList: true, subtree: true });
                // expose for debugging if needed
                window.__markInnerChildObserver = mo;
            } catch (e) { }
        })();

        // Setup inline opacity slider next to Œ£ and bind it to popup background alpha
        (function setupInlineOpacityControl() {
            const euclidTotal = document.getElementById('euclidTotal');
            const popup = document.getElementById('numberPickerPopup');
            if (!euclidTotal) return;

            // create container next to Œ£ if not exists
            if (!document.getElementById('popupOpacityRangeInline')) {
                const container = document.createElement('span');
                container.className = 'inline-opacity-container';
                container.innerHTML = `
                    <input id="popupOpacityRangeInline" type="range" min="0" max="100" value="0">
                    <div class="inline-percent" id="popupOpacityInlineValue">0%</div>
                `;
                euclidTotal.parentNode.insertBefore(container, euclidTotal.nextSibling);

                const range = container.querySelector('#popupOpacityRangeInline');
                const label = container.querySelector('#popupOpacityInlineValue');

                function parseRGB(str) {
                    const m = String(str).match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                    if (m) return [m[1], m[2], m[3]];
                    return [255, 255, 255];
                }

                function updateAlpha(v) {
                    label.textContent = `${v}%`;
                    const pct = Number(v);
                    if (!popup) return;

                    // Prevent fully transparent popup: reserve a minimum visible alpha.
                    const MIN_ALPHA = 0.15; // keep at least 15% opacity so popup never fully hides

                    // 0% should preserve the original visuals exactly (no inline overrides)
                    if (pct === 0) {
                        popup.style.backgroundColor = '';
                        popup.style.borderColor = '';
                        popup.style.boxShadow = '';
                        // If popup is currently displayed, ensure it remains visible (opacity 1).
                        // Otherwise clear inline opacity so it falls back to CSS when hidden.
                        try {
                            const csDisp = getComputedStyle(popup).display;
                            if (csDisp && csDisp !== 'none') {
                                popup.style.opacity = '1';
                            } else {
                                popup.style.opacity = '';
                            }
                        } catch (e) {
                            popup.style.opacity = '';
                        }
                        return;
                    }

                    // Map slider 0..100 -> alpha 1..MIN_ALPHA (linear)
                    const alpha = 1 - (pct / 100) * (1 - MIN_ALPHA);

                    const cs = getComputedStyle(popup);
                    const bg = cs.backgroundColor || 'rgb(255,255,255)';
                    const [r, g, b] = parseRGB(bg);

                    // Apply opacity to the whole popup so all children fade together
                    popup.style.opacity = String(alpha);
                    // Also set background rgba to preserve backdrop color when semi-transparent
                    popup.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    // Soften border and shadow proportionally (keep a minimum subtle border)
                    try {
                        const bc = cs.borderColor || 'rgb(0,0,0)';
                        const [br, bg2, bb] = parseRGB(bc);
                        const borderAlpha = Math.max(0.08, alpha * 0.9);
                        popup.style.borderColor = `rgba(${br}, ${bg2}, ${bb}, ${borderAlpha})`;
                    } catch (e) { }

                    try {
                        const shadowAlpha = 0.28 * alpha + 0.02;
                        popup.style.boxShadow = `0 8px 24px rgba(0,0,0,${shadowAlpha})`;
                    } catch (e) { }
                }

                // initialize
                updateAlpha(range.value);
                range.addEventListener('input', (e) => updateAlpha(e.target.value));
            }
        })();

        bootstrap();
    </script>
</body>

</html>
