<!DOCTYPE html>
<html lang="vi">

<head>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life Notebook → Web</title>
    <style>
        /* Reduce width of the specific "giảm dần số kỳ" dropdown in Cell6.5 */
        #cell6_5>div:nth-child(4)>div.controls>select:nth-child(13) {
            width: 90px;
            max-width: 140px;
            min-width: 80px;
        }

        /* Also reduce width of the adjacent "mới-cũ" sort order dropdown in Cell6.5 */
        #cell6_5>div:nth-child(4)>div.controls>select:nth-child(11) {
            width: 110px;
            max-width: 110px;
            min-width: 63px;
        }

        /* Reduce width of the visible "Bộ" custom-select button in Cell6.5 (bộ 1,2,...) */
        #cell6_5>div>div.controls .custom-select .nav-btn {
            width: 80px;
            min-width: 60px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Stronger, id-targeted override for the specific Cell6.5 "Bộ" button */
        #cell6_5 .controls #cell6_5_xSelBtn {
            width: 70px !important;
            min-width: 50px !important;
            max-width: 110px !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }

        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #94a3b8;
            --accent: #38ef7d;
            --accent-2: #667eea;
            --border: #1e293b;
            --card: #0b1220;
            --trash-width: 520px;
            --text: #e2e8f0;
            --text-strong: #fff;
            --highlight-bg: #4CAF50;
            --highlight-text: #0b1220;
            /* Canvas connection line color for dark mode */
            --connection-line-color: #ff5722;
            /* deep orange - contrasts with dark bg and yellow cells */
            /* Scroll button sizing/offsets will be defined on body for symmetry */
        }

        [data-theme="light"] {
            --bg: #f8f9ff;
            --panel: #ffffff;
            --muted: #666;
            --accent: #38ef7d;
            --accent-2: #11998e;
            --border: #eee;
            --card: #fafafa;
            --text: #333;
            --text-strong: #000;
            --highlight-bg: #4CAF50;
            --highlight-text: #fff;
            /* Canvas connection line color for light mode */
            --connection-line-color: #00cc00;
            /* keep green in light theme */
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
            /* Scroll button vars placed on body so positions are body-relative/mirrored */
            --scroll-btn-size: 50px;
            --scroll-btn-offset: 30px;
            --scroll-btn-right: 30px;
            /* height of the sticky header to exclude from the remaining area */
            --header-height: 64px;
        }

        /* k value badges inside Cell5.5: cyan when >= k̄, yellow when < k̄ */
        .k-value {
            font-weight: 800;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
            min-width: 28px;
            text-align: center;
        }

        .k-cyan {
            background: #00FFFF;
            /* brighter cyan */
            color: black;
            box-shadow: 0 2px 6px rgba(0, 229, 255, 0.18);
        }

        .k-yellow {
            background: #FFFF00;
            /* brighter yellow */
            color: black;
            box-shadow: 0 2px 6px rgba(255, 215, 0, 0.14);
        }

        [data-theme="dark"] body {
            background: radial-gradient(circle at 20% 20%, rgba(56, 239, 125, 0.08), transparent 35%),
                radial-gradient(circle at 80% 10%, rgba(102, 126, 234, 0.12), transparent 40%),
                var(--bg);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }

        [data-theme="light"] header {
            background: rgba(248, 250, 252, 0.9);
        }

        .theme-toggle {
            margin-left: auto;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .topbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand span {
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border-radius: 8px;
            font-size: 12px;
            color: var(--highlight-text);
            font-weight: 900;
            cursor: pointer;
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }

        .brand span:hover {
            transform: scale(1.05);
        }

        /* Number Picker Popup and Place Boxes (copied from index.html) */
        .number-picker-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 500px;
            max-height: 800px;
            /* increased to reduce internal scrolling when mode wraps */
            overflow-y: auto;
            left: 0;
            top: 0;
            cursor: move;
            transform-origin: top left;
            transition: transform 0.1s ease-out, opacity 0.3s ease;
            opacity: 0;
        }

        .popup-scale-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            display: none;
            background: var(--accent);
            border: 1px solid var(--accent-2);
            opacity: 0.7;
        }

        .popup-scale-handle.visible {
            display: block;
        }

        .number-picker-popup * {
            cursor: default;
        }

        .number-picker-popup .popup-scale-handle {
            cursor: nwse-resize !important;
        }

        [data-theme="dark"] .number-picker-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .number-picker-popup.show {
            display: block;
            opacity: 1;
        }

        /* Highlight the selected option inside native dropdowns where supported */
        select option:checked,
        select option.highlighted {
            background: var(--highlight-bg) !important;
            color: var(--highlight-text) !important;
            font-weight: 800;
        }

        /* (inline-opacity-container removed — replaced by rule toggle) */

        .number-picker-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .number-picker-table th {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: center;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .number-picker-table th.label-cell {
            cursor: grab;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            color: white;
        }

        .number-picker-table th.label-cell:active {
            cursor: grabbing;
        }

        .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        .number-picker-table th:nth-child(3) {
            border-right: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset -3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table th:nth-child(4) {
            border-left: 3px solid rgba(255, 255, 255, 0.6) !important;
            box-shadow: inset 3px 0 0 0 rgba(255, 255, 255, 0.6);
        }

        .number-picker-table td:active {
            cursor: grabbing;
        }

        [data-theme="light"] .number-picker-table td {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
        }

        [data-theme="light"] .number-picker-table td:nth-child(3) {
            border-right: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table td:nth-child(4) {
            border-left: 3px solid #00cc00 !important;
        }

        [data-theme="light"] .number-picker-table th:nth-child(3) {
            border-right: 3px solid #11998e !important;
            box-shadow: inset -3px 0 0 0 #11998e;
        }

        [data-theme="light"] .number-picker-table th:nth-child(4) {
            border-left: 3px solid #11998e !important;
            box-shadow: inset 3px 0 0 0 #11998e;
        }

        .number-picker-table td:hover {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            transition: all 0.2s;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
            font-weight: 700;
            padding: 8px;
            text-align: center;
            cursor: grab;
            user-select: none;
            position: relative;
            z-index: 1;
            box-sizing: border-box;
            /* Added box-sizing */
            /* Do not set a global text color on the cell so rank badges keep their own color.
               Color for the main number is applied to the number span below. */
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        /* Target only the main number span inside the cell; exclude rank badge spans */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number>span:not(.rank-in-cell) {
            color: #00ff00 !important;
            font-weight: 900;
        }

        #numberPickerPopup #numberPickerTable td.disabled {
            opacity: 1;
            cursor: not-allowed;
            background: #1a2a3a !important;
            pointer-events: none;
            /* avoid changing all nested text color (rank badges must keep their own color) */
            font-weight: 700 !important;
        }

        /* For disabled cells, color only the displayed number span (not the rank badge) */
        #numberPickerPopup #numberPickerTable td.disabled>span:not(.rank-in-cell) {
            color: #00ff00 !important;
        }

        /* If a disabled cell is also selected/placed, show the selected highlight instead
           (override the darker disabled styling). This ensures dragging a number into a place
           will display the same accent highlight as hover/selection and will be cleared
           by the normal highlight-sync logic. */
        #numberPickerPopup #numberPickerTable td.number-cell.selected-number,
        #numberPickerPopup #numberPickerTable td.selected-number.disabled,
        #numberPickerPopup #numberPickerTable td.number-cell.disabled.selected-number {
            background: #1a2a3a !important;
            color: #00ff00 !important;
            transform: none !important;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18) !important;
            border-style: solid !important;
            border-color: rgba(0, 0, 0, 0.12) !important;
        }

        [data-theme="light"] #numberPickerPopup #numberPickerTable td.disabled {
            background: #e8f4f8 !important;
            color: #1a1a1a !important;
        }

        /* Apply bright label-cell style when column has values */
        .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        [data-theme="light"] .number-picker-table th.label-cell.with-values {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: white !important;
            font-weight: 800 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* All Cx labels are always interactive (drag/dblclick) regardless of brightness */
        .number-picker-table tfoot:not(.disabled) th.label-cell {
            cursor: grab;
            pointer-events: auto !important;
        }

        .number-picker-table tfoot:not(.disabled) th.label-cell:active {
            cursor: grabbing;
        }

        /* Dim label cells that don't have values — visual only, still interactive */
        .number-picker-table tfoot:not(.disabled) th.label-cell:not(.with-values):not(.col-all-trashed):not(.col-all-fav) {
            opacity: 0.3 !important;
        }

        .number-picker-table tbody.disabled,
        .number-picker-table tfoot.disabled {
            pointer-events: none;
            opacity: 0.3;
            position: relative;
        }

        /* Allow label cells (C1-C6) to remain interactive even when tfoot is disabled
           so users can drag-to-trash or dblclick-to-fav entire columns in number mode */
        .number-picker-table tfoot.disabled th.label-cell {
            pointer-events: auto;
            cursor: grab;
            opacity: 1;
            position: relative;
            z-index: 2;
        }

        .number-picker-table tfoot.disabled th.label-cell:active {
            cursor: grabbing;
        }

        /* Visual indicator when all numbers in a column are in trash */
        .number-picker-table th.label-cell.col-all-trashed {
            background: linear-gradient(135deg, #b71c1c 0%, #e53935 100%) !important;
            color: #fff !important;
        }

        /* Visual indicator when all numbers in a column are in fav */
        .number-picker-table th.label-cell.col-all-fav {
            background: linear-gradient(135deg, #f9a825 0%, #fdd835 100%) !important;
            color: #1a1a1a !important;
        }

        .number-picker-table tbody.disabled::after,
        .number-picker-table tfoot.disabled::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.03) 10px,
                    rgba(0, 0, 0, 0.03) 20px);
            pointer-events: none;
        }

        [data-theme="dark"] .number-picker-table tbody.disabled::after,
        [data-theme="dark"] .number-picker-table tfoot.disabled::after {
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.03) 10px,
                    rgba(255, 255, 255, 0.03) 20px);
        }

        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 1px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 44px;
            height: 44px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 15px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: #ffffff !important;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 1px;
        }

        /* Ensure child elements inside the place-box don't add extra padding */
        .place-box>* {
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        /* Compact style for trash mode dropdowns to save horizontal space */
        .trash-mode,
        select.trash-mode,
        .mode-selector select.trash-mode {
            width: auto !important;
            min-width: 90px;
            max-width: 140px;
            padding: 6px 8px;
            font-size: 13px;
        }

        /* Ensure specific trash selector in Cell6.6 matches height of other inputs */
        #cell6_6_trashSel {
            padding: 10px 12px !important;
            font-size: 13px !important;
            line-height: 1 !important;
            box-sizing: border-box !important;
            height: auto !important;
        }

        /* Stable IDs used for the two trash selectors (Cell5.5 / Cell6.5) */
        #cell6_5_trashSel,
        #cell5_5_trashSel {
            width: 100px;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        .image-popup {
            position: fixed;
            z-index: 9999;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
        }

        [data-theme="dark"] .image-popup {
            background: var(--panel);
            border-color: var(--accent);
        }

        .image-popup.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        .image-popup img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            border-radius: 8px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .image-popup img {
                max-width: 200px;
                max-height: 200px;
            }
        }

        nav {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .nav-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        .lienket-next-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 30px;
            padding: 0 8px;
            font-size: 14px;
            line-height: 1;
            border-radius: 6px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            box-sizing: border-box;
        }

        .lienket-prev-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 30px;
            padding: 0 8px;
            font-size: 14px;
            line-height: 1;
            border-radius: 6px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            box-sizing: border-box;
            margin-right: 6px;
        }

        .lienket-next-btn:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(56, 239, 125, 0.08);
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn.active {
            border-color: var(--accent);
            color: var(--highlight-text);
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            font-weight: 800;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
        }

        section h2 {
            margin: 0 0 12px;
            color: var(--text-strong);
            letter-spacing: 0.3px;
        }

        section p.lead {
            margin: 6px 0 16px;
            color: var(--muted);
        }

        .card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .card {
            background: var(--card);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 14px;
        }

        /* By default, numtrash-related wrappers are hidden; they only
           become visible when the parent controls container is in
           `.unpair-mode`. This prevents leftover inline styles from
           showing unpair UI when switching modes. */
        #cell6_5 .numtrash-wrapper {
            display: none !important;
            pointer-events: none;
            visibility: hidden !important;
        }

        /* When unpair mode is active inside Cell6.5, show only the numtrash field */
        #cell6_5 .controls.unpair-mode>* {
            display: none !important;
        }

        #cell6_5 .controls.unpair-mode>.numtrash-wrapper {
            display: flex !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }

        /* Highlight a row while it's being dragged out from Cell6.5 (unpair)
           and keep a persistent highlight when the record has been dragged out. */
        #cell6_5 table tr.dragging-out,
        #cell6_5 table tr.dragged-out {
            position: relative !important;
            z-index: 9999 !important;
            outline: 3px solid #0f9f5c !important;
            outline-offset: -2px !important;
            box-shadow: 0 10px 30px rgba(15, 158, 86, 0.22) !important;
            background-clip: padding-box !important;
        }

        /* Highlight the `num` cell when all its `dontmatch` numbers are present in the trashPopup (green) */
        #cell6_5 td.cell6-num-highlight {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%) !important;
            color: var(--highlight-text) !important;
            font-weight: 800 !important;
            border-radius: 6px !important;
            padding: 6px 8px !important;
        }

        /* Highlight the `num` cell when the num itself is present in the trashPopup (yellow->red gradient)
           This takes precedence visually over the green `cell6-num-highlight`. */
        #cell6_5 td.cell6-num-in-trash {
            background: linear-gradient(135deg, #ffef62 0%, #ff6b6b 100%) !important;
            color: #2b2b2b !important;
            font-weight: 900 !important;
            border-radius: 6px !important;
            padding: 6px 8px !important;
            box-shadow: 0 6px 18px rgba(255, 106, 106, 0.14) !important;
        }

        /* Ensure the main `num` cell in Cell6.5 has the same
           padding/height whether or not highlight classes are applied.
           This keeps record row heights consistent in unpair mode. */
        #cell6_5 table td:first-child {
            /* Fixed width for the `num` column so it doesn't shrink
               when the `dontmatch` string grows. Keep same padding/height. */
            width: 80px !important;
            min-width: 80px !important;
            max-width: 80px !important;
            padding: 6px 8px !important;
            vertical-align: middle !important;
            line-height: 1.2 !important;
            box-sizing: border-box !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            text-align: center !important;
        }

        /* Second column (KQ) should not wrap — keep results on one line.
           Longer KQ content will overflow horizontally instead. */
        #cell6_5 table td:nth-child(2) {
            text-align: center !important;
            white-space: nowrap !important;
            overflow: visible !important;
        }

        /* Prevent the "kết quả" (result) column in Cell6.5 (truy x) from
           wrapping to a new line when the content is long. Allow it to overflow
           visually instead of forcing a line-break inside the table cell. */
        #cell6_5 table th:last-child,
        #cell6_5 table td:last-child {
            white-space: nowrap !important;
            overflow: visible !important;
            text-overflow: clip !important;
            max-width: none !important;
        }

        /* Ensure the table and surrounding card allow visible overflow so
           long result strings can extend outside the table instead of wrapping. */
        #cell6_5 .card,
        #cell6_5 .card .card-inner-child {
            overflow: visible !important;
        }

        #cell6_5 table {
            table-layout: auto !important;
            width: 100% !important;
        }

        /* Remove right margin caused by inner child of the 6th control in Cell6.6 */
        #cell6_6>div>div.controls>div:nth-child(6)>* {
            margin-right: 0 !important;
        }

        /* More general: remove right margin from any child inside controls of #cell6_6
           This addresses nth-child(1) and similar cases where inner elements add extra spacing. */
        #cell6_6>div>div.controls>div>* {
            margin-right: 0 !important;
        }

        /* Specifically override inline margin set on JS-created drag input containers */
        #cell6_6 .controls .drag-input-container {
            margin-right: 0 !important;
            margin-left: 0 !important;
        }

        select,
        input,
        button {
            border-radius: 10px;
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            font-size: 13px;
        }

        select:focus,
        input:focus {
            outline: 1px solid var(--accent);
        }

        /* Custom select/popup styling to match other controls */
        .custom-select .nav-btn {
            border: 2px solid var(--accent);
            background: var(--card);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            /* match .nav-btn and other controls */
            font-size: 13px;
            cursor: pointer;
            transition: 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            min-height: 36px;
            /* ensures same visual height as other inputs/buttons */
            box-sizing: border-box;
        }

        .custom-select .nav-btn .label {
            flex: 1;
            text-align: left;
        }

        .custom-select-options {
            position: absolute;
            z-index: 2000;
            background: var(--card);
            border: 2px solid var(--accent);
            border-radius: 10px;
            /* match other dropdown corner radius */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            padding: 6px 6px;
            max-height: 324px;
            /* 9 items × ~36px each */
            overflow-y: auto;
            min-width: 140px;
            box-sizing: border-box;
        }

        .custom-select-option {
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text);
            font-weight: 600;
        }

        .custom-select-option:hover {
            background: rgba(56, 239, 125, 0.12);
            color: var(--text-strong);
        }

        .custom-select .nav-btn:focus,
        .custom-select .nav-btn.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 4px rgba(56, 239, 125, 0.06);
            outline: none;
        }

        /* Hide number input spinner arrows */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        /* Ensure optimizer checkbox tick is visible and uses the theme accent color.
           Some environments may hide native ticks or override appearance; force
           a consistent visible tick for the optimizer control. */
        #cell6_5_optimize {
            width: 18px;
            height: 18px;
            vertical-align: middle;
            appearance: auto !important;
            -webkit-appearance: auto !important;
            -moz-appearance: auto !important;
            accent-color: var(--accent) !important;
        }

        #cell6_5_optimize:checked {
            accent-color: var(--accent) !important;
            filter: none !important;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100());
            border: none;
            color: var(--highlight-text);
            font-weight: 700;
            cursor: pointer;
        }

        button.ghost {
            background: var(--card);
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: white;
        }

        [data-theme="dark"] table {
            background: var(--panel);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            z-index: 1;
        }

        /* Allow opt-out of sticky table headers for small popup tables
           — keep header visuals (background + text color) but disable sticky positioning */
        table.no-sticky thead {
            position: static !important;
            top: auto !important;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%) !important;
            color: white !important;
            z-index: auto !important;
        }

        th {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        /* Narrow column for Tổng % to keep layout compact */
        th.col-total,
        td.col-total {
            width: 110px;
            max-width: 140px;
            white-space: nowrap;
        }

        th:last-child {
            border-right: none;
        }

        td {
            padding: 5px 6px;
            text-align: center;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        /* Ensure Cell5.5 table cells center their content (date and result pills) */
        #cell5_5 table th,
        #cell5_5 table td {
            text-align: center !important;
            vertical-align: middle !important;
            display: table-cell !important;
        }

        [data-theme="dark"] td {
            border-color: var(--border);
        }

        td:last-child {
            border-right: none;
        }

        tbody tr:nth-child(even) {
            background: #f8f9ff;
        }

        tbody tr:nth-child(odd) {
            background: white;
        }

        [data-theme="dark"] tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        [data-theme="dark"] tbody tr:nth-child(odd) {
            background: transparent;
        }

        tbody tr:hover {
            background: #ffe6b3 !important;
        }

        [data-theme="dark"] tbody tr:hover {
            background: rgba(255, 230, 179, 0.2) !important;
        }

        /* Keep top ranks in Cell4 readable on dark theme */
        [data-theme="dark"] #cell4 tbody tr.rank-top td {
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr.rank-top .pill {
            background: #fffbea;
            color: #0b1220;
        }

        [data-theme="dark"] #cell4 tbody tr:nth-child(n+4) td[style*="background:linear-gradient"] {
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.15) 0%, rgba(56, 239, 125, 0.25) 100%) !important;
            color: #fff !important;
        }

        .pill {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: #e6f4ea;
            color: #0b8a60;
            white-space: nowrap;
            margin: 1px;
            font-family: monospace;
        }

        /* Tighten number pills for Cell5.5: fixed-size and perfectly centered digits
           Includes .cell5-pill (inline-styled fallback) and .pill */
        #cell5_5 td.td-has-pill .pill,
        #cell5_5 td.td-has-pill .cell5-pill {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 22px !important;
            min-width: 22px !important;
            height: 20px !important;
            padding: 0 !important;
            margin: 0 3px !important;
            font-family: monospace !important;
            font-size: 12px !important;
            line-height: 1 !important;
            box-sizing: border-box !important;
            text-align: center !important;
            white-space: nowrap !important;
        }

        /* Remove extra margin on the first/last pill so endpoint numbers don't add horizontal gaps */
        #cell5_5 td.td-has-pill .pill:first-child,
        #cell5_5 td.td-has-pill .cell5-pill:first-child {
            margin-left: 0 !important;
        }

        #cell5_5 td.td-has-pill .pill:last-child,
        #cell5_5 td.td-has-pill .cell5-pill:last-child {
            margin-right: 0 !important;
        }

        /* Reduce horizontal padding on the table cells that contain pills */
        #cell5_5 .card .card-inner-child table td.td-has-pill {
            padding-left: 2px;
            padding-right: 2px;
        }

        /* Reduce left/right padding of the Result column to free table width */
        #cell5_5 table th:nth-child(2),
        #cell5_5 table td:nth-child(2) {
            padding-left: 4px;
            padding-right: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Ensure fav-marked pills keep their yellow background even when the row/card is hovered */
        #cell5_5 table tr:hover .pill.in-fav,
        #cell5_5 table tr.popup-number-highlight .pill.in-fav,
        #cell5_5 .card .card-body tr:hover .pill.in-fav {
            background: #f8f333 !important;
            color: #000 !important;
            box-shadow: 0 6px 18px rgba(248, 243, 51, 0.12) !important;
        }

        /* Euclid small framed pills (default style copied from day.html) */
        .euclid-pill {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            /* single soft orange for lower glare */
            background: #f8f333;
            color: #000;
            white-space: nowrap;
            margin: 0 1px 0 0;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }

        /* For Cell6.5: ensure Euclid pill (last column) never wraps and
           is allowed to overflow outside the table visually. */
        #cell6_5 table th:last-child,
        #cell6_5 table td:last-child {
            overflow: visible !important;
            white-space: nowrap !important;
        }

        #cell6_5 table th:last-child .euclid-pill,
        #cell6_5 table td:last-child .euclid-pill {
            display: inline-block !important;
            white-space: nowrap !important;
            overflow: visible !important;
            max-width: none !important;
        }

        .euclid-pill.empty {
            opacity: 0.45;
        }

        /* Popup-scoped euclid pill appearance (keeps high-contrast pill look in info popup) */
        table.no-sticky .euclid-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 28px;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 900;
            background: #fffbea;
            color: var(--text-strong);
            margin: 0 6px 0 0;
            font-family: monospace;
            text-align: center;
            border: none;
            -webkit-text-stroke: 0.36px rgba(0, 0, 0, 0.6);
            text-shadow: 0 0 1px rgba(0, 0, 0, 0.22);
        }

        /* Color the pill text according to 5 rank tiers (1..5) inside popup only */
        table.no-sticky .euclid-pill.rank-tier-1 {
            color: #08eb56;
        }

        table.no-sticky .euclid-pill.rank-tier-2 {
            color: #00E5FF;
        }

        table.no-sticky .euclid-pill.rank-tier-3 {
            color: #1a62ea;
        }

        table.no-sticky .euclid-pill.rank-tier-4 {
            color: #ea3ade;
        }

        table.no-sticky .euclid-pill.rank-tier-5 {
            color: #ea0313;
        }

        /* Apply same rank-tier colors inside Cell4 rank column */
        #cell4 .rank-pill.rank-tier-1 {
            color: #08eb56;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-2 {
            color: #00E5FF;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-3 {
            color: #1a62ea;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-4 {
            color: #ea3ade;
            font-weight: 800;
        }

        #cell4 .rank-pill.rank-tier-5 {
            color: #ea0313;
            font-weight: 800;
        }

        /* Info popup number pill (Số column) */
        table.no-sticky td.num-cell {
            text-align: center;
        }

        .info-num-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 22px;
            padding: 2px 4px;
            border-radius: 6px;
            background: #2e7d32;
            color: #ffffff;
            font-weight: 800;
            font-family: monospace;
            box-sizing: border-box;
        }

        /* Zero-occurrence number style shown in Cell5.5 info popup */
        .info-zero-num {
            color: #ff1744;
            /* bright red */
            font-weight: 900;
            background: rgba(255, 23, 68, 0.06);
            padding: 0px 2px;
            border-radius: 4px;
            margin-right: 2px;
            font-size: 13px;
            line-height: 1;
            display: inline-block;
            box-shadow: 0 1px 0 rgba(255, 23, 68, 0.06);
        }

        /* teal */

        .euclid-total-pill {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 2px 5px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 800;
            background: #38ef7d;
            color: #072018;
            margin-left: 3px;
            font-family: monospace;
            min-width: 38px;
            text-align: center;
        }

        .label-chip {
            display: inline-block;
            min-width: 18px;
            padding: 2px 5px;
            margin: 1px 2px 1px 0;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-weight: 700;
            background: transparent;
            color: inherit;
        }

        .label-chip.highlight {
            background: var(--highlight-bg);
            color: var(--highlight-text);
        }

        /* Highlight class applied to number cells in the popup when hovering a group row.
           Use a dark solid background (requested) and keep on-top z-index. */
        #numberPickerPopup #numberPickerTable td.popup-number-highlight {
            background: #1a2a3a !important;
            color: #ffffff !important;
            box-shadow: none !important;
            outline: none !important;
            position: relative;
            z-index: 1100;
        }

        [data-theme="dark"] .pill {
            background: rgba(56, 239, 125, 0.15);
            color: #38ef7d;
        }

        /* Prevent pill containers from wrapping.
           The selector `:has()` isn't supported in some editors/linters —
           provide a compatible class-based fallback and a tiny JS shim
           that marks `td` elements containing `.pill` with `.td-has-pill`. */
        td.td-has-pill {
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .pill {
                font-size: 10px;
                padding: 2px 5px;
                margin: 1px;
            }

            th,
            td {
                padding: 4px 6px;
                font-size: 11px;
            }
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid>* {
            flex: 1 1 350px;
            min-width: 0;
        }

        .grid-centered {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .grid-centered>* {
            flex: 0 1 calc(33.333% - 10px);
            max-width: 600px;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            .grid>* {
                flex: 1 1 100%;
            }

            .grid-centered>* {
                flex: 1 1 100%;
                max-width: none;
            }
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            padding: 3px 8px;
            border-radius: 8px;
            background: var(--accent-2);
            color: white;
            font-weight: 700;
            font-size: 12px;
            opacity: 0.9;
        }

        main {
            padding: 16px 12px 32px;
        }

        section {
            margin: 20px 0;
            padding: 16px;
        }

        /* Performance: skip rendering offscreen content like large apps do */
        section {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 800px 600px;
        }

        .card {
            content-visibility: auto;
            contain: content;
        }

        /* Marker for cards nested inside "card-inner" wrappers.
           JS will add the class 'card-inner-child' to any .card inside .card.card-inner.
           Use this selector to style inner cards separately. */
        .card-inner-child {
            /* empty by default; add overrides as needed */
            box-sizing: border-box;
            /* harmless default to avoid empty-selector warning */
        }

        /* Layout rule: make the inner wrapper a flex container so we can
           enforce max 2 child cards per row. Each child gets up to 50%
           width and will be centered when it's the only child. */
        .card.card-inner {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-start;
        }

        .card.card-inner>.card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* Some renderers create .card elements nested deeper than direct children.
           Ensure any descendant marked with .card-inner-child gets the same sizing. */
        .card.card-inner .card-inner-child {
            flex: 0 0 calc(50% - 6px) !important;
            max-width: calc(50% - 6px) !important;
            width: calc(50% - 6px) !important;
            box-sizing: border-box;
        }

        /* When a .card.card-inner contains exactly one inner card, center that
           inner card horizontally and allow it to size to its content (up to
           the wrapper width). This centers narrow tables while still allowing
           wider tables to grow up to the container. */
        .card.card-inner.single-child {
            justify-content: center;
        }

        .card.card-inner.single-child .card-inner-child {
            flex: 0 1 auto !important;
            max-width: 100% !important;
            width: auto !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* Override for Cell5.5: when a row contains exactly one table,
           do not center it — render normally left-to-right. */
        #cell5_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell5_5 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            /* keep natural width and flow left-to-right */
            flex: 0 1 auto !important;
            width: auto !important;
            max-width: none !important;
        }

        /* Also ensure the table itself isn't centered by inherited rules */
        #cell5_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Prefer intrinsic table width inside a centered single child; allow
           the table to grow up to the wrapper width but not force 100% width. */
        .card.card-inner.single-child .card-inner-child table {
            width: auto !important;
            max-width: 100% !important;
            margin-left: auto !important;
            margin-right: auto !important;
        }

        /* If a wrapper contains a single child, center it horizontally */
        .card.card-inner>.card-inner-child:only-child {
            margin-left: auto;
            margin-right: auto;
        }

        /* Ensure the grid container used by Cell5.5 aligns children left-to-right
           instead of centering them (this container holds the paged tables). */
        #cell5_5 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        /* Same behavior for Cell6.5: don't center its grid/cards when only one child/table */
        #cell6_5 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        #cell6_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell6_5 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
            flex: 0 1 auto !important;
        }

        #cell6_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Clear any :only-child centering inside cell6_5 */
        #cell6_5 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Cell6.6 table: center KQ column, full width */
        #cell6_6 table td:nth-child(2) {
            text-align: center !important;
            white-space: nowrap !important;
            overflow: visible !important;
        }

        #cell6_6 table {
            table-layout: auto !important;
            width: 100% !important;
        }

        /* Cell8 table: center KQ column, full width */
        #cell8 table td:nth-child(2) {
            text-align: center !important;
            white-space: nowrap !important;
            overflow: visible !important;
        }

        #cell8 table {
            table-layout: auto !important;
            width: 100% !important;
        }

        /* Cell9 table: center KQ column, full width */
        #cell9 table td:nth-child(2) {
            text-align: center !important;
            white-space: nowrap !important;
            overflow: visible !important;
        }

        #cell9 table {
            table-layout: auto !important;
            width: 100% !important;
        }

        /* Cell11 table: center KQ column, full width */
        #cell11 table td:nth-child(2) {
            text-align: center !important;
            white-space: nowrap !important;
            overflow: visible !important;
        }

        #cell11 table {
            table-layout: auto !important;
            width: 100% !important;
        }

        /* Same behavior for Cell11: don't center its grid/cards when only one child/table */
        #cell11 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        /* Each table in Cell11 takes exactly half the row width */
        #cell11 .grid-centered>* {
            flex: 0 0 calc(50% - 5px) !important;
            max-width: calc(50% - 5px) !important;
            min-width: 0 !important;
        }

        #cell11 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell11 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
            flex: 0 1 auto !important;
        }

        #cell11 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Clear any :only-child centering inside cell11 */
        #cell11 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Same behavior for Cell6.6: don't center its grid/cards when only one child/table */
        #cell6_6 .grid-centered {
            justify-content: flex-start !important;
            align-items: flex-start !important;
        }

        #cell6_6 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell6_6 .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
            flex: 0 1 auto !important;
        }

        #cell6_6 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* Clear any :only-child centering inside cell6_6 */
        #cell6_6 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Small screens: stack to single column */
        @media (max-width: 768px) {
            .card.card-inner>.card-inner-child {
                flex: 0 0 100%;
                max-width: 100%;
            }
        }

        /* Reduce paint/layout when card bodies are offscreen */
        .card-body {
            content-visibility: auto;
            contain: content;
            contain-intrinsic-size: 200px 120px;
        }

        @media (min-width: 768px) {
            main {
                padding: 24px 18px 48px;
            }

            section {
                margin: 32px 0;
                padding: 22px;
            }
        }

        .error {
            color: #fca5a5;
            font-weight: 600;
        }

        .success {
            color: #34d399;
            font-weight: 700;
        }

        .loader {
            text-align: center;
            color: var(--muted);
            padding: 16px 0;
        }

        .flex {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        a.anchor {
            color: inherit;
            text-decoration: none;
        }

        .hidden {
            display: none;
        }

        /* Flash highlight after copying a row */
        tr.copied-row {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Persistent highlight when a record is Ctrl+clicked in Cell5.5 */
        tr.ctrl-selected {
            outline: 3px solid #FFD500;
            /* yellow */
            outline-offset: -3px;
        }

        /* Fallback highlight using inset box-shadow on cells so clipping doesn't hide the outline */
        tr.ctrl-selected td {
            box-shadow: inset 0 0 0 3px #FFD500;
            background-clip: padding-box;
        }

        /* Floating scroll-to-top button (uses variables so mirror can be computed on body) */
        #scrollToTop {
            position: fixed;
            bottom: var(--scroll-btn-offset);
            right: var(--scroll-btn-right);
            width: var(--scroll-btn-size);
            height: var(--scroll-btn-size);
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: calc(var(--scroll-btn-size) * 0.48);
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToTop:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToTop:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            body {
                --scroll-btn-offset: 20px;
                --scroll-btn-size: 45px;
                --scroll-btn-right: 20px;
            }

            #scrollToTop {
                font-size: calc(var(--scroll-btn-size) * 0.44);
            }
        }

        /* Scroll to bottom button: vertically mirrored relative to scrollToTop (uses same vars) */
        #scrollToBottom {
            position: fixed;
            /* place below header so it's the mirror across the midpoint of the remaining body
               remaining midpoint derivation simplifies to top = header + offset */
            top: calc(var(--header-height) + var(--scroll-btn-offset));
            right: var(--scroll-btn-right);
            width: var(--scroll-btn-size);
            height: var(--scroll-btn-size);
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%);
            border: none;
            color: white;
            font-size: calc(var(--scroll-btn-size) * 0.48);
            cursor: pointer;
            display: none;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(56, 239, 125, 0.3);
            transition: all 0.3s ease;
        }

        #scrollToBottom:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.4);
        }

        #scrollToBottom:active {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #scrollToBottom {
                font-size: calc(var(--scroll-btn-size) * 0.44);
            }
        }

        /* Close button for number picker popup */
        .number-picker-close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255, 67, 67, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .number-picker-close-btn:hover {
            background: rgba(255, 67, 67, 1);
            transform: scale(1.1);
        }

        .number-picker-close-btn:active {
            transform: scale(0.95);
        }

        /* Canvas overlay for drawing connections */
        #connectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Make controls inside Cell7/8/9/10/11 stick under the header when scrolling.
              Keep them in normal flow so they match other sections visually.
          */
        #cell5_5 .controls,
        #cell6_5 .controls,
        #cell6_6 .controls,
        #cell7 .controls,
        #cell8 .controls,
        #cell9 .controls,
        #cell10 .controls,
        #cell11 .controls {
            position: sticky;
            top: 64px;
            /* space for sticky header */
            z-index: 11;
            /* blue-gray → dark-gray gradient to match normal section look */
            background: linear-gradient(135deg, #334155 0%, #1f2937 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px 12px;
            margin: 0 0 14px 0;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        /* Some browsers prevent sticky when an ancestor uses 'contain' or
           'content-visibility'. Disable containment for this specific
           section so the controls can stick correctly. */
        #cell5_5,
        #cell6_5,
        #cell6_6,
        #cell7,
        #cell8,
        #cell9,
        #cell10,
        #cell11 {
            contain: none;
            content-visibility: visible;
        }

        /* JS fallback will add this class when it needs to pin the controls */
        .controls.stuck {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.24);
            transition: box-shadow 0.12s ease;
        }

        /* Mode selector two-row layout + swap control */
        .mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .mode-rows {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .mode-row {
            display: flex;
            gap: 6px;
            align-items: center;
            /* Keep controls on a single row; allow horizontal scroll when space is tight */
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .mode-rows.reversed {
            flex-direction: column-reverse;
        }

        #swapRowsBtn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor: pointer;
        }

        /* === Exact place styles copied from day.html to match visuals === */
        .place-container {
            margin-top: 16px;
            padding: 18px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: rgba(56, 239, 125, 0.08);
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            position: relative;
        }

        .place-container:hover {
            background: rgba(56, 239, 125, 0.12);
            border-color: var(--accent-2);
        }

        .places-grid {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
        }

        .place-box {
            width: 54px;
            height: 54px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 700;
            background: rgba(56, 239, 125, 0.1);
            color: #ffffff !important;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            flex-direction: column;
            gap: 3px;
        }

        /* Overlay distance label between adjacent place boxes */
        .place-distance-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
            line-height: 16px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translate(-50%, -50%);
            white-space: nowrap;
            min-width: 24px;
        }

        [data-theme="dark"] .place-distance-overlay {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 0 6px;
            height: 16px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }

        .place-box.filled {
            background: rgba(56, 239, 125, 0.25);
            border-style: solid;
            border-color: var(--accent);
        }

        [data-theme="light"] .place-box.filled {
            background: #0f9f5c;
            color: var(--highlight-text);
            border-color: #0f9f5c;
        }

        .place-box-label {
            position: absolute;
            top: -20px;
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        .place-box-value {
            font-size: 20px;
            font-weight: 700;
        }

        .mode-selector {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(56, 239, 125, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            /* allow items to wrap to next line */
        }

        .mode-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 13px;
            cursor: pointer;
        }

        .clear-btn {
            background: #ef4444 !important;
            color: #fff !important;
            border-color: #dc2626 !important;
            cursor: pointer !important;
            transition: all 0.2s !important;
            font-weight: 500 !important;
        }

        .clear-btn:hover {
            background: #dc2626 !important;
            border-color: #b91c1c !important;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3) !important;
        }

        /* === End copied styles === */

        /* FINAL OVERRIDE: ensure Cell5.5 single-table outputs are left-aligned.
           This rule is placed last and uses high specificity + !important so
           it wins over earlier centering rules. */
        #cell5_5.card .card.card-inner.single-child,
        #cell5_5 .card.card-inner.single-child {
            justify-content: flex-start !important;
        }

        #cell5_5 .card.card-inner.single-child .card-inner-child,
        #cell5_5.card .card.card-inner.single-child .card-inner-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: none !important;
            width: auto !important;
        }

        /* Override the generic rule that centers tables inside single-child wrappers */
        #cell5_5 .card.card-inner.single-child .card-inner-child table {
            margin-left: 0 !important;
            margin-right: 0 !important;
            width: auto !important;
            max-width: none !important;
            display: table !important;
        }

        /* If any :only-child centering rule remains, specifically clear it inside #cell5_5 */
        #cell5_5 .card.card-inner>.card-inner-child:only-child {
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        /* Trash popup styles */
        /* Ensure clear button inside trash popup is visible and accessible */
        #trashPopup .clear-btn {
            display: inline-block !important;
            color: var(--text) !important;
            background: var(--card) !important;
            border: 1px solid var(--border) !important;
            padding: 6px 10px !important;
            height: 32px !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            z-index: 10005 !important;
        }

        #trashPopup {
            z-index: 10001;
        }

        /* ensure popup sits above other overlays */
        #trashPopup {
            position: absolute;
            z-index: 10001;
            left: calc(-1 * (var(--trash-width, 420px) + 12px));
            top: 8px;
            display: none;
            background: var(--card);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            overflow-y: auto;
            overflow-x: hidden;
            /* allow transform so trash can scale with popup */
            transform-origin: top right;
            will-change: transform, width, height, left, top;
        }

        /* Cell5.5 count highlight */
        .cell5-count-x {
            font-weight: 800;
            color: var(--text-strong);
            display: inline-block;
        }

        #trashPopup table {
            width: 100%;
            max-width: var(--trash-width);
            border-collapse: collapse;
            table-layout: fixed;
            transform: none !important;
            table-layout: fixed;
        }

        #trashPopup td {
            padding: 6px;

        }

        /* Favorite popup styles: reuse and mirror trash popup visuals */
        #favPopup .clear-btn {
            display: inline-block !important;
            color: var(--text) !important;
            background: var(--card) !important;
            border: 1px solid var(--border) !important;
            padding: 6px 10px !important;
            height: 32px !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            z-index: 10005 !important;
        }

        #favPopup {
            /* match trash popup positioning and transform behaviour */
            z-index: 10001;
            position: absolute;
            left: calc(-1 * (var(--trash-width, 420px) + 12px));
            top: 8px;
            display: none;
            background: var(--card);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            overflow-y: auto;
            overflow-x: hidden;
            transform-origin: top right;
            will-change: transform, width, height, left, top;
        }

        /* keep table behaviour identical so scaling/resizing is consistent */
        #favPopup table {
            width: 100%;
            max-width: var(--trash-width);
            border-collapse: collapse;
            table-layout: fixed;
            transform: none !important;
        }

        /* Use same 3-column, aspect-ratio layout as trash popup */
        #favPopup td,
        #favPopup td.fav-number {
            width: calc(100% / 3);
            max-width: calc(100% / 3);
            aspect-ratio: 1 / 1.732;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 6px;
            box-sizing: border-box;
            text-align: center;
            vertical-align: middle;
            cursor: grab;
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            font-weight: 700;
            border: 2px solid var(--connection-line-color);
            box-shadow: 0 2px 8px rgba(255, 251, 234, 0.4);
        }

        /* inner flex wrapper inside each fav cell to position rank and number like trash */
        #favPopup td.fav-number>.trash-inner {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            min-width: 0;
            overflow: hidden;
        }

        /* position rank/pill left of main number and preserve same ordering as trash */
        #favPopup td.fav-number .rank-in-cell,
        #favPopup td.fav-number .pill {
            margin-right: 6px;
            order: 0;
        }

        #favPopup td.fav-number .number-main,
        #favPopup td.fav-number span:not(.pill):not(.rank-in-cell) {
            order: 1;
        }

        #favPopup td.fav-number:active {
            cursor: grabbing;
        }

        /* Scale handle for fav popup (mirror trash popup bottom-left handle) */
        #favPopup .trash-scale-handle {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 18px;
            height: 18px;
            background: transparent;
            border-radius: 4px;
            cursor: nesw-resize;
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.9;
            pointer-events: auto;
        }

        #favPopup .trash-scale-handle:after {
            content: '';
            width: 10px;
            height: 10px;
            border-right: 2px solid var(--border);
            border-bottom: 2px solid var(--border);
            transform: rotate(45deg);
            opacity: 0.9;
        }

        /* Favorite marker: highlight numbers inside the main number-picker popup when marked fav */
        #numberPickerPopup #numberPickerTable td.in-fav {
            background: #f8f333 !important;
            color: #000 !important;
            font-weight: 800 !important;
            box-shadow: 0 2px 8px rgba(248, 243, 51, 0.28);
        }

        /* Empty fav slot: render as visually blank (no background/border/shadow) */
        #favPopup td:empty {
            background: transparent !important;
            box-shadow: none !important;
            border: none !important;
            cursor: default !important;
            pointer-events: none;
            min-height: 40px;
            /* keep layout height consistent */
        }

        /* Each trash cell: 3 columns, responsive and keep aspect ratio */
        #trashPopup td {
            width: calc(100% / 3);
            max-width: calc(100% / 3);
            aspect-ratio: 1 / 1.732;
            /* height = width / 1.732 */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 6px;
            /* ensure consistent padding inside cells */
            box-sizing: border-box;
        }

        #trashPopup td.trash-number {
            background: var(--cell-bg-color, #fffbea);
            color: #000000;
            font-weight: 700;
            border: 2px solid var(--connection-line-color);
            /* keep td as a table-cell so the table layout enforces 3 columns
               use an inner wrapper for flex layout instead of changing td display */
        }

        /* Scale handle for trash popup (bottom-left corner) */
        #trashPopup .trash-scale-handle {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 18px;
            height: 18px;
            background: transparent;
            border-radius: 4px;
            cursor: nesw-resize;
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.9;
            pointer-events: auto;
        }

        #trashPopup .trash-scale-handle:after {
            content: '';
            width: 10px;
            height: 10px;
            border-right: 2px solid var(--border);
            border-bottom: 2px solid var(--border);
            transform: rotate(45deg);
            opacity: 0.9;
        }

        /* inner flex wrapper inside each trash cell to position rank and number */
        #trashPopup td.trash-number>.trash-inner {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            min-width: 0;
            /* allow flex children to shrink to prevent overflow */
            overflow: hidden;
        }

        #trashPopup td.trash-number:active {
            cursor: grabbing;
        }

        /* rank/pill should appear left of the main number */
        #trashPopup td.trash-number .rank-in-cell,
        #trashPopup td.trash-number .pill {
            margin-right: 6px;
            order: 0;
        }

        #trashPopup td.trash-number .number-main,
        #trashPopup td.trash-number span:not(.pill):not(.rank-in-cell) {
            order: 1;
        }

        /* Hidden state for numbers removed into trash
           keep the table cell as a placeholder so other cells don't shift */
        #numberPickerTable td.in-trash {
            visibility: hidden !important;
            pointer-events: none !important;
            background: transparent !important;
        }

        /* Show a red flagged style for trashed numbers when shown inside the
           number-picker popup. This overrides the global hidden state so the
           popup can visually indicate items that were moved to trash. */
        #numberPickerPopup #numberPickerTable td.in-trash {
            visibility: visible !important;
            pointer-events: none !important;
            /* Bright red background and high-contrast white text */
            background: #ff1744 !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
        }

        /* Hide visible content (rank badges and main number) inside
           trashed cells when rendered in the popup, but preserve layout
           so the table row height does not collapse. Use visibility +
           opacity instead of display:none to keep cell box size. */
        #numberPickerPopup #numberPickerTable td.in-trash .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash .pill,
        #numberPickerPopup #numberPickerTable td.in-trash .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash>span:not(.rank-in-cell):not(.pill) {
            visibility: hidden !important;
            opacity: 0 !important;
            color: transparent !important;
        }

        /* Keep trashed cells visibly red for direct hover/selection/inline-style.
           Exclude `.popup-number-highlight` here so the split-gradient
           pseudo-element can render the left-dark/right-red highlight. */
        #numberPickerPopup #numberPickerTable td.in-trash:hover,
        #numberPickerPopup #numberPickerTable td.in-trash.selected-number,
        #numberPickerPopup #numberPickerTable td.in-trash[style] {
            background: #ff1744 !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
            outline: none !important;
        }

        /* Additional hard override: ensure no descendant text or inline styles
           inside popup trashed cells can show green/black text. Use
           visibility/opacity instead of removing layout to avoid collapsing
           the row height. Keep pointer-events disabled. */
        #numberPickerPopup #numberPickerTable td.in-trash *,
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash *,
        .number-picker-popup #numberPickerTable td.in-trash * {
            visibility: hidden !important;
            opacity: 0 !important;
            color: transparent !important;
            pointer-events: none !important;
        }

        /* Make the injected restore handle visible and interactive despite
           the global hiding of trashed cell descendants. */
        #numberPickerPopup #numberPickerTable td.in-trash .restore-handle {
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            pointer-events: auto !important;
            position: absolute;
            right: 6px;
            top: 6px;
            z-index: 2100;
            touch-action: manipulation;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        /* Extra overlay: create an absolutely positioned red layer that fully
           covers the trashed cell. This prevents other styling (outline,
           box-shadow, or pseudo-elements) from visually overriding the red
           background during transient hover/selection updates. */
        #numberPickerPopup #numberPickerTable td.in-trash {
            position: relative !important;
            z-index: 2000 !important;
            transition: none !important;
            -webkit-transition: none !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash::before {
            content: '' !important;
            position: absolute !important;
            inset: 0 !important;
            background: #ff1744 !important;
            border-radius: inherit !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
            z-index: 2001 !important;
            pointer-events: none !important;
        }

        /* Fav overlay: show split (dark-green / yellow) only when the
           popup highlights the cell (hover) or when it's explicitly selected.
           This mirrors the 'in-trash.popup-number-highlight' behavior so the
           fav overlay appears only during hover/selection. */
        #numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight,
        #numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight[style],
        .number-picker-popup #numberPickerTable td.in-fav.popup-number-highlight[style],
        #numberPickerPopup #numberPickerTable td.in-fav.selected-number,
        .number-picker-popup #numberPickerTable td.in-fav[style].selected-number {
            position: relative !important;
            z-index: 2000 !important;
        }

        #numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight::before,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight::before,
        #numberPickerPopup #numberPickerTable td.in-fav.popup-number-highlight[style]::before,
        .number-picker-popup #numberPickerTable td.in-fav.popup-number-highlight[style]::before,
        #numberPickerPopup #numberPickerTable td.in-fav.selected-number::before,
        .number-picker-popup #numberPickerTable td.in-fav[style].selected-number::before {
            content: '' !important;
            position: absolute !important;
            inset: 0 !important;
            /* left half: dark green; right half: yellow (semi-transparent) */
            background: linear-gradient(90deg, rgba(0, 70, 255, 0.56) 0%, rgba(0, 255, 255, 0.56) 100%) !important;
            border-radius: inherit !important;
            box-shadow: inset 0 2px 8px rgba(34, 139, 34, 0.08) !important;
            z-index: 2001 !important;
            pointer-events: none !important;
        }

        /* Dimmed overlay for trashed numbers that are also present in place boxes.
           This shows a 50% red overlay but keeps the cell contents visible. It
           overrides the heavier in-trash rules above when the additional
           `in-trash-dim` class is present. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            visibility: visible !important;
            pointer-events: none !important;
            background: rgba(255, 23, 68, 0.5) !important;
            color: #ffffff !important;
            border-color: #e51b3b !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            position: relative !important;
            z-index: 2000 !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::before {
            background: rgba(255, 23, 68, 0.5) !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            z-index: 2001 !important;
            pointer-events: none !important;
        }

        /* Ensure children of dimmed trashed cells remain visible (undo the
           global hide rules for plain trashed items). Keep pointer-events off
           so interaction remains disabled while the visual remains readable. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim * {
            display: revert !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            pointer-events: none !important;
        }

        /* Ensure dim overlay persists when JS toggles highlight/selection/inline styles
           which previously forced a full-red overlay via higher-specificity selectors. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number::before,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]::before,
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before {
            background: rgba(255, 23, 68, 0.5) !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.08) !important;
            z-index: 3000 !important;
            pointer-events: none !important;
        }

        /* Ensure the orange outline remains visible for dimmed trashed cells
           that are highlighted by group hover. Lower the overlay z-index so
           the outline (drawn on the cell) appears above the pseudo-element. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight {
            outline: 4px solid #ff8c00 !important;
            outline-offset: 2px !important;
            position: relative !important;
            z-index: 4000 !important;
        }

        /* Push the dim ::before overlay beneath the cell's outline when highlighted */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight::before {
            z-index: 2000 !important;
        }

        /* Also ensure children remain visible under these transient states */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight *,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number *,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] * {
            display: revert !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            pointer-events: none !important;
        }

        /* Also ensure highlighted/selected variants keep the overlay intact.
           When a trashed number is highlighted (hovering a record that maps
           to this number), show a left-dark / right-red split so the UI
           clearly indicates both 'flagged' and 'highlighted' states. */
        /* Highlight-on-hover (record hover -> popup-number-highlight): split background */
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Keep fully-red overlay for selected/explicitly-styled trashed cells */
        #numberPickerPopup #numberPickerTable td.in-trash.selected-number::before,
        .number-picker-popup #numberPickerTable td.in-trash[style]::before {
            background: #ff1744 !important;
            box-shadow: inset 0 2px 8px rgba(229, 27, 59, 0.12) !important;
        }

        /* Stronger rule: when a trashed cell is also highlighted via
           `popup-number-highlight`, prefer the split appearance even if
           `selected-number` or inline styles are present. This wins by
           being more specific and placed after the full-red rule. */
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight.selected-number::before,
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight[style]::before,
        .number-picker-popup #numberPickerTable td.in-trash.popup-number-highlight::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Small visual for the trash and fav buttons when active */
        /* allow badge to overflow without being clipped by ancestors */
        #modeRowRank>div,
        #modeRowRank,
        #trashBtn,
        #favBtn {
            overflow: visible;
        }

        /* Ensure fav button uses the same base styling as trash so their
           badges render identically and sit in the same corner. Make
           icon sizing explicit so emoji vs glyphs render at the same size. */
        #trashBtn,
        #favBtn {
            position: relative;
            /* allow corner badge positioning */
            background: transparent;
            border: 1px solid var(--border);
            /* normalize layout so both icons match visually */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 6px;
            min-width: 40px;
            min-height: 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            font-family: "Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }

        #trashBtn.disabled,
        #favBtn.disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        /* Tiny circular badge displayed at the corner of the trash button (like Messenger) */
        .trash-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            background: #ff3b30;
            /* red similar to messenger */
            color: white;
            font-weight: 800;
            font-size: 11px;
            line-height: 1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            /* purely decorative */
            z-index: 20000;
        }

        .trash-badge.hidden {
            display: none;
        }

        /* Fav badge should use a darker green accent while trash remains red */
        #favBadge {
            background: #2e7d32;
            border-color: #1b5e20;
            color: #ffffff;
        }

        /* `#trashToggle` removed: trash is always enabled by default. */

        /* Stronger enforcement: ensure the split (50% dark / 50% red)
           gradient appears for trashed popup cells when they are highlighted.
           This rule is very specific and placed at the end of the stylesheet
           so it wins over earlier full-red overrides (including inline-style
           based selectors). */
        #numberPickerPopup.number-picker-popup.show #numberPickerTable td.in-trash.popup-number-highlight::before,
        .number-picker-popup#numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight::before,
        #numberPickerPopup #numberPickerTable td.in-trash.popup-number-highlight[style]::before,
        .number-picker-popup #numberPickerTable td.in-trash.popup-number-highlight[style]::before {
            background: linear-gradient(to right, #1a2a3a 0 50%, #fe1744 50% 100%) !important;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.28) !important;
        }

        /* Additional overrides: ensure trashed-but-present cells show the
       split overlay while keeping number and rank text visible and in
       their intended colors. Inserted to win over earlier hiding rules. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            position: relative;
            isolation: isolate;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(56, 239, 125, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 0;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Explicit rules to ensure number text and rank/pill remain visible
           for trashed items that are also present in place boxes (in-trash-dim).
           These selectors override earlier hiding rules and make text render
           above the split overlay. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            position: relative;
            isolation: isolate;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(56, 239, 125, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 0;
        }

        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 1;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Unhide the specific spans that were previously hidden for trashed cells */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>span:not(.rank-in-cell):not(.pill) {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            font-weight: 700 !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Ensure the above also applies during transient highlight/selection or when inline styles are present */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>span:not(.rank-in-cell):not(.pill),
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>span:not(.rank-in-cell):not(.pill),
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .rank-in-cell,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .pill,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style] .number-main,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>span:not(.rank-in-cell):not(.pill) {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
            font-weight: 700 !important;
            -webkit-text-stroke: 0px !important;
            text-shadow: none !important;
        }

        /* Neutralize underlying cell color and render a crisp split overlay
           using exact colors requested: left #1a2a3a, right #ff1744. Keep
           text above overlays so number and rank remain readable. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim {
            background: transparent !important;
            box-shadow: none !important;
            position: relative;
            isolation: isolate;
        }

        /* Remove earlier ::before full-red overlays (if present) */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::before {
            display: none !important;
            content: none !important;
        }

        /* Split overlay: left half #1a2a3a, right half #ff1744 at 50% opacity
           so underlying theme doesn't change perceived color too much. */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg,
                    rgba(26, 42, 58, 0.5) 0% 50%,
                    rgba(255, 23, 68, 0.5) 50% 100%);
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: normal;
        }

        /* Ensure content renders above overlays */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim>* {
            position: relative;
            z-index: 2;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Also enforce during transient highlight/selection or when inline styles
           are applied by JS so overlay remains visible and text keeps color */
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.popup-number-highlight>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim.selected-number>*,
        #numberPickerPopup #numberPickerTable td.in-trash.in-trash-dim[style]>* {
            position: relative;
            z-index: 2;
            visibility: visible !important;
            opacity: 1 !important;
            color: inherit !important;
        }

        /* Compact k input and keep trash popup header on one line */
        #trashPopup>div:first-child {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
        }

        #trashPopup input[type="number"] {
            width: 56px;
            min-width: 40px;
            max-width: 88px;
            padding: 4px 6px;
            box-sizing: border-box;
            font-size: 13px;
            display: inline-block;
            vertical-align: middle;
        }

        /* Prioritize a class if present for the k field */
        #trashPopup .k-input,
        #trashPopup input.k-input {
            width: 56px;
        }

        /* Override the inline style applied to the specific input #trashKInput */
        #trashPopup #trashKInput {
            width: 56px !important;
            min-width: 40px !important;
            max-width: 88px !important;
            padding: 4px 6px 4px 8px !important;
            padding-right: 18px !important;
            /* make room for compact spinner */
            box-sizing: border-box !important;
            font-size: 13px !important;
            display: inline-block !important;
            vertical-align: middle !important;
        }

        /* Keep average-k label on one line and prevent wrapping */
        #trashPopup .avg-k {
            white-space: nowrap;
            margin-left: 8px;
            flex: 0 0 auto;
            display: inline-block;
            align-self: center;
        }

        /* ===== Fav visual adjustments =====
           Move the prominent yellow border from the main popup cells
           to the favorite-popup cells themselves. Keep the main popup
           `in-fav` marker minimal so selection/hover visuals remain stable. */
        #numberPickerPopup #numberPickerTable td.in-fav {
            /* Keep fav numbers prominent in the main popup: yellow background */
            background: #f8f333 !important;
            color: #000 !important;
            font-weight: 800 !important;
            box-shadow: 0 6px 18px rgba(248, 243, 51, 0.12) !important;
            outline: none !important;
        }

        /* Apply thin yellow border to favorite numbers inside the fav popup */
        #favPopup td.fav-number {
            border: 2px solid #f8f333 !important;
            box-shadow: 0 6px 18px rgba(248, 243, 51, 0.12) !important;
        }

        /* Highlight fav numbers inside Cell5.5 result pills */
        #cell5_5 .pill.in-fav {
            background: #2e7d32 !important;
            /* green */
            color: #fff !important;
            box-shadow: 0 2px 6px rgba(46, 125, 50, 0.18);
        }
    </style>
</head>
<!-- Draft popup CSS inserted -->
<style>
    /* Draft popup styles: reuse trash popup visuals but keep it attached to number picker */
    #draftPopup {
        position: fixed;
        display: none;
        z-index: 10002;
        width: 320px;
        max-width: 42vw;
        background: var(--card);
        border: 2px solid var(--accent);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        color: var(--text);
        border-radius: 8px;
        overflow: hidden;
        font-size: 13px;
        /* prevent content-visibility from hiding during position calc */
        content-visibility: visible;
    }

    #draftPopup .draft-header {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
    }

    #draftPopup .draft-header .title {
        font-weight: 700
    }

    #draftPopup .draft-body {
        padding: 8px;
        /* default: let content size itself and avoid scrollbars for small lists */
        max-height: none;
        overflow: visible;
    }

    /* when draft has many records, enable a scrollable body */
    #draftPopup.has-scroll .draft-body {
        max-height: 320px;
        overflow: auto;
    }

    #draftPopup table {
        width: 100%;
        border-collapse: collapse
    }

    #draftPopup td {
        padding: 6px 8px;
        border-bottom: 1px dashed rgba(255, 255, 255, 0.03)
    }

    #draftPopup .record-row {
        display: flex;
        gap: 8px;
        align-items: center
    }

    #draftPopup .pills {
        display: flex;
        gap: 6px;
        flex-wrap: wrap
    }

    /* Draft pills: styled like Cell5.5 result column pills, black text */
    #draftPopup .pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        min-width: 22px;
        height: 20px;
        padding: 0;
        margin: 0 3px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1;
        box-sizing: border-box;
        text-align: center;
        white-space: nowrap;
        border-radius: 4px;
        font-weight: 700;
        background: #e6f4ea;
        color: #000;
        cursor: pointer;
    }

    /* Empty pill placeholder */
    #draftPopup .pill.pill-empty {
        background: rgba(128, 128, 128, 0.15);
        color: #999;
        border: 1px dashed rgba(128, 128, 128, 0.4);
        cursor: pointer;
    }

    #draftPopup .pills .pill:first-child {
        margin-left: 0;
    }

    #draftPopup .pills .pill:last-child {
        margin-right: 0;
    }

    #draftPopup .draft-controls {
        display: flex;
        gap: 8px
    }

    #draftPopup .small-btn {
        padding: 6px 8px;
        border-radius: 6px;
        background: transparent;
        border: 1px solid var(--border);
        cursor: pointer
    }

    /* Grabber styles for draft rows */
    #draftPopup td.has-grabber {
        position: relative;
    }

    #draftPopup .grabber {
        cursor: grab;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 4px;
        user-select: none;
        color: var(--text);
        opacity: 0.9;
        font-weight: 700;
        margin-left: 8px;
        flex: 0 0 auto;
    }

    #draftPopup .grabber:active {
        cursor: grabbing;
        opacity: 1;
    }

    /* Floating clone while dragging inside draft popup */
    .draft-dragging-clone {
        position: fixed;
        z-index: 100000;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
        opacity: 0.95;
        border-radius: 6px;
        background: var(--card);
        transform-origin: top left;
        pointer-events: none;
        transition: none;
        will-change: transform, left, top;
    }

    /* Clone inherits pill/row styles from draftPopup scope */
    .draft-dragging-clone .record-row {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .draft-dragging-clone .pills {
        display: flex;
        gap: 6px;
        flex-wrap: nowrap;
        flex: 1;
    }

    .draft-dragging-clone .pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        min-width: 22px;
        height: 20px;
        padding: 0;
        margin: 0 3px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1;
        box-sizing: border-box;
        text-align: center;
        white-space: nowrap;
        border-radius: 4px;
        font-weight: 700;
        background: #e6f4ea;
        color: #000;
    }

    .draft-dragging-clone .pill.pill-empty {
        background: rgba(128, 128, 128, 0.15);
        color: #999;
        border: 1px dashed rgba(128, 128, 128, 0.4);
    }

    .draft-dragging-clone .pills .pill:first-child {
        margin-left: 0;
    }

    .draft-dragging-clone .pills .pill:last-child {
        margin-right: 0;
    }

    .draft-dragging-clone .grabber {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 4px;
        user-select: none;
        opacity: 0.9;
        font-weight: 700;
        margin-left: 8px;
        flex: 0 0 auto;
        color: var(--text);
    }

    .draft-dragging-clone td.has-grabber {
        padding: 6px 8px;
        border: none;
    }

    .draft-dragging-clone table {
        border-collapse: collapse;
        width: 100%;
    }

    /* Block hover effects on number picker / place boxes during row drag */
    body.draft-row-dragging-active #numberPickerPopup td,
    body.draft-row-dragging-active .place-box,
    body.draft-row-dragging-active .place-container {
        pointer-events: none !important;
    }

    /* Source row is hidden while being dragged (replaced by placeholder) */
    #draftPopup tr.draft-row-dragging {
        opacity: 0.3;
        background: rgba(128, 128, 128, 0.15);
        transition: opacity 0.15s;
    }

    /* Placeholder row that marks drop target inside draft */
    #draftPopup tr.draft-row-placeholder td {
        background: rgba(56, 239, 125, 0.12);
        border: 2px dashed var(--accent);
        padding: 0;
        height: 36px;
        transition: height 0.15s;
    }

    /* Pill edit / drag-swap visuals */
    #draftPopup span.pill-target {
        outline: 2px solid var(--accent);
        transform: translateY(-1px);
    }

    /* Pill editor styled to match pill appearance exactly */
    #draftPopup input.pill-editor {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        min-width: 22px;
        height: 20px;
        padding: 0;
        margin: 0 3px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1;
        box-sizing: border-box;
        text-align: center;
        white-space: nowrap;
        border-radius: 4px;
        font-weight: 700;
        background: #e6f4ea;
        color: #000;
        border: 2px solid var(--accent);
        outline: none;
    }

    /* Add-row button at the bottom of draft table */
    #draftPopup .draft-add-row {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        padding: 4px 0;
        cursor: pointer;
        color: var(--text);
        opacity: 0.6;
        font-size: 18px;
        font-weight: 700;
        border: none;
        background: transparent;
        border-top: 1px dashed rgba(128, 128, 128, 0.2);
        transition: opacity 0.15s;
    }

    #draftPopup .draft-add-row:hover {
        opacity: 1;
        background: rgba(56, 239, 125, 0.08);
    }

    /* Scale handle for draft popup (bottom-right corner) */
    #draftPopup .draft-scale-handle {
        position: absolute;
        right: 0;
        bottom: 0;
        width: 18px;
        height: 18px;
        cursor: nwse-resize;
        pointer-events: auto;
        z-index: 10;
        user-select: none;
    }

    #draftPopup .draft-scale-handle::after {
        content: '';
        position: absolute;
        right: 3px;
        bottom: 3px;
        width: 8px;
        height: 8px;
        border-right: 2px solid var(--text);
        border-bottom: 2px solid var(--text);
        opacity: 0.4;
    }

    /* Flash green border when a draft row is copied */
    #draftPopup tr.draft-row-copied td {
        box-shadow: inset 0 0 0 2px #38ef7d;
        transition: box-shadow 0.15s ease;
    }
</style>

<body>
    <header>
        <div class="topbar">
            <div class="brand">Life Notebook
                <span id="htmlBadge">HTML</span>
            </div>
            <nav id="nav"></nav>
            <button class="theme-toggle" id="themeToggle" title="Chuyển giao diện">🌓</button>
        </div>
    </header>
    <div class="image-popup" id="imagePopup">
        <img src="anh.png" alt="Preview">
    </div>
    <!-- Number Picker Popup (copied from index.html) -->
    <div class="number-picker-popup" id="numberPickerPopup">
        <button class="number-picker-close-btn" id="closeNumberPickerBtn" title="Đóng">✕</button>
        <table class="number-picker-table" id="numberPickerTable">
            <!-- Generated by JS -->
        </table>
        <div class="place-container">
            <div class="places-grid" id="placesGrid">
                <!-- Generated by JS: 6 place boxes V1-V6 -->
            </div>
        </div>
        <div class="mode-selector" id="modeSelectorContainer">
            <div class="mode-rows reversed" id="modeRows">
                <div class="mode-row" id="modeRowRank"
                    style="font-size:14px;gap:8px;align-items:center;display:flex;justify-content:space-between;width:100%;order:999;">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <button id="trashBtn" title="Thùng rác" aria-label="Thùng rác">🗑️<span id="trashBadge"
                                class="trash-badge hidden" aria-hidden="true"></span></button>
                        <button id="favBtn" title="Yêu thích" aria-label="Yêu thích">⭐</button>
                    </div>
                    <div id="rankSummary"
                        style="font-size:14px;font-weight:700;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:0 auto;">
                    </div>
                </div>
                <div class="mode-row" id="modeRowTop">
                    <label style="font-size: 12px;">Mode:</label>
                    <button id="modeSelector"
                        style="width: 100px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);">Số
                        (1-45)</button>
                    <button id="clearPlaceBtn" class="clear-btn" title="Xóa toàn bộ place"
                        style="padding: 6px 10px; font-size: 12px;">Xóa</button>
                    <label style="margin-left:6px;font-size:12px;">Rank:</label>
                    <button id="rankToggle"
                        style="width:80px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);">rank</button>
                    <label style="margin-left:6px;font-size:12px;">Hover:</label>
                    <button id="quickPlaceToggle"
                        style="width:auto;min-width:48px;font-size:11px;padding:6px 4px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);box-sizing:border-box;max-width:100%;"
                        title="Toggle hover mode: 'Normal' = dblclick copies; 'Hover' = hover fills places">Normal</button>
                </div>
                <div class="mode-row" id="modeRowBottom">
                    <label style="margin-left: 6px; font-size: 12px;" id="connectionToggleLabel">Nối:</label>
                    <button id="connectionToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiện/ẩn đường nối giữa các số liên tiếp">Hiện</button>
                    <label style="font-size: 12px;" id="euclidToggleLabel">Euclid:</label>
                    <button id="euclidToggle"
                        style="width: 50px; font-size: 12px; padding: 6px 10px; cursor: pointer; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text);"
                        title="Hiện/ẩn hiển thị khoảng cách Euclid">Hiện</button>
                    <span id="euclidTotal"
                        style="margin-left:8px;font-size:13px;font-weight:700;color:var(--text-strong);opacity:1;">Σ:&nbsp;&nbsp;
                        <span id="euclidTotalValue"
                            style="color:#38ef7d;font-weight:900;margin-left:8px;font-size:16px;text-shadow:0 0 8px rgba(56,239,125,0.22);">0.00</span>
                    </span>
                    <label style="margin-left:10px;font-size:12px;">Rule:</label>
                    <button id="trashToggle"
                        style="width:68px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);"
                        title="Normal = rê record không đổi trash; Trash = rê record áp dụng trash tạm thời">normal</button>
                    <button id="favToggle"
                        style="width:68px;font-size:12px;padding:6px 10px;cursor:pointer;border:1px solid var(--border);border-radius:6px;background:var(--card);color:var(--text);"
                        title="Normal = rê record không đổi fav; Fav = rê record áp dụng fav tạm thời">normal</button>
                </div>
            </div>
        </div>
    </div>
    </div>
    <!-- Draft popup: attached to numberPickerPopup; toggled with key 'a' -->
    <div id="draftPopup" aria-hidden="true">
        <div class="draft-header">
            <div class="title">Draft (a to toggle)</div>
            <div class="draft-controls">
                <button id="draftClearBtn" class="small-btn" title="Clear">Clear</button>
            </div>
        </div>
        <div class="draft-body">
            <table id="draftTable" aria-label="Draft records">
                <tbody>
                    <!-- rows inserted by JS -->
                </tbody>
            </table>
        </div>
        <div class="draft-scale-handle" aria-hidden="true"></div>
    </div>
    <button id="scrollToTop" title="Quay về đầu trang">↑</button>
    <button id="scrollToBottom" title="Xuống cuối trang">↓</button>
    <main>
        <div id="status" class="card" style="margin-bottom:18px;">Đang tải dữ liệu...</div>
        <!-- Sections injected by JS -->
    </main>

    <script>
        // ===== Helpers from notebook =====
        const COL_MAP = { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 2, 10: 2, 11: 2, 12: 2, 13: 2, 14: 2, 15: 2, 16: 2, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 3, 23: 3, 24: 3, 25: 4, 26: 4, 27: 4, 28: 4, 29: 4, 30: 4, 31: 4, 32: 5, 33: 5, 34: 5, 35: 5, 36: 5, 37: 5, 38: 5, 39: 6, 40: 6, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6 };
        const getCol = (v) => COL_MAP[v] ?? 0;

        // Safe focus helper: prefer preventing scroll when moving focus programmatically
        function safeFocus(el) {
            if (!el) return;
            try {
                el.focus({ preventScroll: true });
            } catch (e) {
                try { el.focus(); } catch (e2) { /* ignore */ }
            }
        }
        // ===== Web Worker Setup =====
        // Tạo web worker inline để xử lý tính toán nặng
        const workerCode = `
            // Helpers for worker
            const compareKey = (a, b) => { const pa = a.split("-").map(Number); const pb = b.split("-").map(Number); for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; } return pa.length - pb.length; };

            function kCombinations(set, k) {
                const combs = [];
                const recur = (start, combo) => {
                    if (combo.length === k) { combs.push([...combo]); return; }
                    for (let i = start; i < set.length; i++) { combo.push(set[i]); recur(i + 1, combo); combo.pop(); }
                };
                recur(0, []);
                return combs;
            }

            // Helper to compute union of number arrays (unique sorted)
            function unionOfArrays(arrs) {
                const s = new Set();
                for (const a of arrs) for (const v of (a || [])) s.add(Number(v));
                return Array.from(s).filter(n => Number.isFinite(n)).sort((a,b)=>a-b);
            }

            self.onmessage = (e) => {
                const { rows, xSel, consec, order, sortSel, workerType } = e.data;
                if (workerType === 'groupBySet') {
                    const x = parseInt(xSel, 10);
                    const groups = new Map();

                    // threshold used when including rows into candidate groups
                    const THRESHOLD = 6;

                    if (consec) {
                        // consecutive slices per single row
                        rows.forEach((r, rowIndex) => {
                            const nums = r.nums || [];
                            for (let i = 0; i <= nums.length - x; i++) {
                                const slice = nums.slice(i, i + x).slice();
                                const key = order ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            }
                        });
                    } else {
                        // Non-consecutive: handle three cases
                        if (x <= 6) {
                            // enumerate combinations inside a single row (fast)
                            rows.forEach((r, rowIndex) => {
                                const nums = r.nums || [];
                                const indexed = nums.map((v, i) => [i, v]);
                                const combos = kCombinations(indexed, x);
                                combos.forEach(combo => {
                                    const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                    const key = values.join("-");
                                    if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                });
                            });
                        } else if (x > 6 && x <= 12) {
                            // Pairwise unions of two rows (heuristic similar to main-thread quick path)
                            const MAX_ROWS_FOR_PAIRING = Math.min(rows.length, 500);
                            const seen = new Set();
                            for (let i = 0; i < MAX_ROWS_FOR_PAIRING; i++) {
                                for (let j = i + 1; j < MAX_ROWS_FOR_PAIRING; j++) {
                                    try {
                                        const a = rows[i].nums || [];
                                        const b = rows[j].nums || [];
                                        const union = unionOfArrays([a, b]);
                                        if (union.length !== x) continue;
                                        const key = union.join('-');
                                        if (seen.has(key)) continue;
                                        seen.add(key);
                                        groups.set(key, new Set());
                                    } catch (err) { /* ignore */ }
                                }
                            }
                            // include rows that intersect the candidate group by at least THRESHOLD
                            for (const key of Array.from(groups.keys())) {
                                const parts = key.split('-').map(Number);
                                rows.forEach((r, rowIndex) => {
                                    try {
                                        const common = (r.nums || []).filter(n => parts.includes(n)).length;
                                        if (common >= THRESHOLD) groups.get(key).add(rowIndex);
                                    } catch (err) { }
                                });
                            }
                        } else {
                            // x >= 13: need to consider unions of multiple rows (triples)
                            // We'll try triples as a compromise between coverage and performance.
                            const MAX_ROWS_FOR_TRIPLE = Math.min(rows.length, 200);
                            const seen = new Set();
                            for (let i = 0; i < MAX_ROWS_FOR_TRIPLE; i++) {
                                for (let j = i + 1; j < MAX_ROWS_FOR_TRIPLE; j++) {
                                    for (let k = j + 1; k < MAX_ROWS_FOR_TRIPLE; k++) {
                                        try {
                                            const a = rows[i].nums || [];
                                            const b = rows[j].nums || [];
                                            const c = rows[k].nums || [];
                                            const union = unionOfArrays([a, b, c]);
                                            if (union.length !== x) continue;
                                            const key = union.join('-');
                                            if (seen.has(key)) continue;
                                            seen.add(key);
                                            groups.set(key, new Set());
                                        } catch (err) { /* ignore */ }
                                    }
                                }
                            }
                            // include rows that intersect the candidate group by at least THRESHOLD
                            for (const key of Array.from(groups.keys())) {
                                const parts = key.split('-').map(Number);
                                rows.forEach((r, rowIndex) => {
                                    try {
                                        const common = (r.nums || []).filter(n => parts.includes(n)).length;
                                        if (common >= THRESHOLD) groups.get(key).add(rowIndex);
                                    } catch (err) { }
                                });
                            }
                        }
                    }

                    let arr = [...groups.entries()].filter(([, indices]) => indices.size >= 2);
                    if (sortSel === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sortSel === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sortSel === "count_asc") arr.sort((a, b) => a[1].size - b[1].size);
                    else arr.sort((a, b) => b[1].size - a[1].size);

                    self.postMessage({ result: arr.map(([k, v]) => [k, Array.from(v)]) });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        let worker = null;

        const getWorker = () => {
            if (!worker) worker = new Worker(workerUrl);
            return worker;
        };
        // warm the worker early to avoid worker creation latency on first heavy query
        try { getWorker(); } catch (e) { /* ignore if worker creation fails */ }

        // ===== Data Loading =====
        let rows = [];
        async function loadData() {
            const status = document.getElementById("status");
            try {
                // Expect data.json in format: [{"date": "2024-01-01", "Result": "1,2,3,4,5,6"}, ...]
                const res = await fetch("data.json");
                if (!res.ok) throw new Error("Không tìm thấy data.json. Hãy xuất từ Excel trước.");
                const raw = await res.json();
                // Parse rows and normalize dates into a Date object + display string
                function parseDateString(raw) {
                    if (raw === undefined || raw === null) return { parsedDate: null, displayDate: '' };
                    let s = String(raw).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    if (s.includes('/')) {
                        const parts = s.split('/').map(p => p.trim());
                        if (parts.length >= 3) {
                            let [dd, mm, yy] = parts;
                            dd = dd.padStart(2, '0');
                            mm = mm.padStart(2, '0');
                            if (yy.length === 2) yy = '20' + yy;
                            const date = new Date(Number(yy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yy}` };
                        }
                    }
                    // only digits: try ddmmyyyy or ddmmyy (padded)
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = digits.slice(0, 2), mm = digits.slice(2, 4), yyyy = digits.slice(4, 8);
                            const date = new Date(Number(yyyy), Number(mm) - 1, Number(dd));
                            if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                        }
                        // pad to 6 digits (ddmmyy) — handles numbers like 10117 -> 010117
                        const d6 = digits.padStart(6, '0');
                        const dd = d6.slice(0, 2), mm = d6.slice(2, 4), yy = d6.slice(4, 6);
                        const yyyy = 2000 + Number(yy);
                        const date = new Date(yyyy, Number(mm) - 1, Number(dd));
                        if (!isNaN(date)) return { parsedDate: date, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    // fallback to Date.parse
                    const dt = new Date(s);
                    if (!isNaN(dt)) {
                        const dd = String(dt.getDate()).padStart(2, '0');
                        const mm = String(dt.getMonth() + 1).padStart(2, '0');
                        const yyyy = dt.getFullYear();
                        return { parsedDate: dt, displayDate: `${dd}/${mm}/${yyyy}` };
                    }
                    return { parsedDate: null, displayDate: s };
                }

                // Treat `date` as raw display string (don't attempt heavy parsing).
                rows = raw
                    .map(r => {
                        if (!r.Result || typeof r.Result !== "string") return null;
                        const nums = r.Result.split(",").map(x => parseInt(x.trim(), 10)).filter(Number.isInteger);
                        if (nums.length !== 6) return null;
                        const dateStr = String(r.date ?? r.Date ?? r.dateStr ?? r["date"] ?? '');
                        return { dateRaw: dateStr, date: dateStr, parsedDate: null, nums, label: nums.map(getCol).join("") };
                    })
                    .filter(Boolean);
                status.innerHTML = `<span class="success">Đã tải ${rows.length} dòng</span> · file: data.json`;
            } catch (err) {
                status.innerHTML = `<span class="error">${err.message}</span><br/><span class="muted">Tạo file data.json từ Excel bằng script python: <code>python - <<'PY'\nimport pandas as pd, json\ndf = pd.read_excel('data.xlsx')\nout = df[['date','Result']]\nout.to_json('data.json', orient='records', force_ascii=False, indent=2)\nPY</code></span>`;
            }
        }

        // ===== Utilities =====
        let decimalPlaces = 2; // default decimal places for percentage
        const fmtPct = (v) => `${(v * 100).toFixed(decimalPlaces)}%`;
        const fmtPctCustom = (v, decimals) => `${(v * 100).toFixed(decimals)}%`;
        const MATCH_STYLE = "background:#2e7d32;color:#fff;"; // dark green with white text for matched values

        // Helpers to highlight numbers inside the number-picker popup
        function clearPopupHighlights() {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            tbl.querySelectorAll('td.popup-number-highlight').forEach(td => td.classList.remove('popup-number-highlight'));
            try {
                // restore place values if we temporarily replaced them while highlighting
                if (window.__prevPlaceValues && typeof window.setPlaceValues === 'function') {
                    try { window.setPlaceValues(window.__prevPlaceValues); } catch (e) { }
                    window.__prevPlaceValues = null;
                }
            } catch (e) { }
        }

        function applyPopupHighlights(nums) {
            const tbl = document.getElementById('numberPickerTable');
            if (!tbl) return;
            clearPopupHighlights();
            // Only apply the orange popup highlight when quick-place mode is 'hover'
            try {
                const inHover = (window.getQuickPlaceMode && window.getQuickPlaceMode() === 'hover');
                if (!inHover) return;
            } catch (e) { return; }
            nums.forEach(n => {
                try {
                    const td = tbl.querySelector(`td[data-number="${n}"]`);
                    // Allow highlighting for trashed numbers too so the popup can
                    // render a split overlay (left dark / right red).
                    // Also allow highlighting disabled cells so group-hover
                    // highlights remain visible even when numbers are disabled.
                    if (td) {
                        td.classList.add('popup-number-highlight');
                    }
                } catch (e) { /* ignore */ }
            });

            // Temporarily replace the 6 place boxes with these numbers so user sees the set
            try {
                if (Array.isArray(nums) && nums.length === 6 && typeof window.getPlaceValues === 'function') {
                    // save previous
                    try { window.__prevPlaceValues = (window.getPlaceValues ? window.getPlaceValues().slice() : null); } catch (e) { window.__prevPlaceValues = null; }
                    // set new place values (strings)
                    try { if (typeof window.setPlaceValues === 'function') window.setPlaceValues(nums.map(n => String(n))); } catch (e) { }
                }
            } catch (e) { }

        }

        // Sync favorite markers from fav list/popup into the main number picker table
        function syncFavHighlights() {
            try {
                const numberPickerTable = document.getElementById('numberPickerTable');
                if (!numberPickerTable) return;
                // clear previous fav markers
                numberPickerTable.querySelectorAll('td.in-fav').forEach(td => td.classList.remove('in-fav'));

                let favs = [];
                if (window.getFavItems && typeof window.getFavItems === 'function') {
                    favs = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                } else if (typeof favItems !== 'undefined' && Array.isArray(favItems) && favItems.length) {
                    favs = favItems.slice().map(n => Number(n)).filter(n => Number.isFinite(n));
                } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                    favs = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                } else {
                    const f = document.getElementById('favPopup');
                    if (f) {
                        favs = Array.from(f.querySelectorAll('td.fav-number')).map(td => {
                            try {
                                const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                if (dn) return Number(dn);
                                const txt = String(td.textContent || '');
                                const m = txt.match(/(\d+)/);
                                return m ? Number(m[1]) : null;
                            } catch (e) { return null; }
                        }).filter(n => Number.isFinite(n));
                    }
                }

                favs.forEach(n => {
                    try {
                        const cell = numberPickerTable.querySelector(`td[data-number="${n}"]`);
                        if (cell) cell.classList.add('in-fav');
                    } catch (e) { /* ignore */ }
                });
            } catch (e) { /* ignore */ }
        }

        // Listen for fav changes and resync
        try { document.addEventListener('favchange', () => { try { syncFavHighlights(); } catch (e) { } }, true); } catch (e) { }

        // Debounce helper to prevent excessive function calls
        const createDebounce = (fn, delay = 100) => {
            let timeout;
            return function debounced(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        };

        // Throttle helper for smoother updates
        const createThrottle = (fn, delay = 100) => {
            let lastCall = 0;
            return function throttled(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    return fn.apply(this, args);
                }
            };
        };

        // Double-click any table row that has data-result to copy its result string (format: 1,2,3,4,5,6)
        const handleRowCopyDblClick = (e) => {
            const row = e.target.closest("tr[data-result]");
            if (!row || !row.dataset.result) return;
            // Always allow dblclick-copy regardless of quick-place mode
            const text = row.dataset.result;

            const flash = () => {
                row.classList.add("copied-row");
                setTimeout(() => row.classList.remove("copied-row"), 500);
            };

            const fallbackCopy = () => {
                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.top = "-9999px";
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    document.execCommand("copy");
                    document.body.removeChild(ta);
                    flash();
                } catch (_) { /* ignore */ }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(flash).catch(fallbackCopy);
            } else {
                fallbackCopy();
            }
        };

        // Global listener to catch all dynamic tables
        document.addEventListener('dblclick', handleRowCopyDblClick, true);

        // Global mouseover: apply popup highlights when hovering any record row
        // and clear when moving to a different card. This centralizes the
        // hover->popup behavior so all cells (cell6, cell6.5, cell6.6, etc.)
        // behave consistently.
        document.addEventListener('mouseover', (ev) => {
            try {
                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                const cardEl = tr ? tr.closest('.card') : null;

                // If hovering a result row, try to find the header <strong>{...}</strong>
                // in the same card and use it to compute popup highlights.
                if (tr && cardEl) {
                    // Skip popup highlight for Cell5.5 / Cell6.5 rows when both toggles are "normal"
                    try {
                        if (tr.closest('#cell5_5') || tr.closest('#cell6_5') || tr.closest('#cell6_6') || tr.closest('#cell7') || tr.closest('#cell8') || tr.closest('#cell9') || tr.closest('#cell11')) {
                            const trashMode = (typeof window.getTrashToggleMode === 'function') ? window.getTrashToggleMode() : 'normal';
                            const favMode = (typeof window.getFavToggleMode === 'function') ? window.getFavToggleMode() : 'normal';
                            if (trashMode === 'normal' && favMode === 'normal') return;
                        }
                    } catch (e) { }
                    const s = cardEl.querySelector('strong');
                    if (s && s.textContent) {
                        const nums = String(s.textContent || '').replace(/[{}]/g, '')
                            .split(/[^0-9]+/).map(s => parseInt(s, 10)).filter(n => Number.isFinite(n));
                        if (nums.length) {
                            try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                            applyPopupHighlights(nums);
                            return;
                        }
                    }
                }

                // Otherwise, if moving to a different card, clear existing highlights
                const src = window.__popupHighlightSource || null;
                if (src && cardEl && cardEl !== src) {
                    clearPopupHighlights();
                    try { window.__popupHighlights = null; window.__popupHighlightSource = null; } catch (e) { }
                }
            } catch (e) { /* ignore */ }
        }, true);

        const anchorNav = [
            { id: "cell4", label: "Cell4 · Tỷ lệ theo vị trí" },
            { id: "cell5", label: "Cell5 · Xếp hạng vị trí" },
            { id: "cell5_5", label: "Cell5.5 · Lịch sử" },
            { id: "cell6_5", label: "Cell6.5 · Truy x" },
            { id: "cell6_6", label: "Cell6.6 · Mổ pattern" },
            { id: "cell7", label: "Cell7 · Nhóm label" },
            { id: "cell8", label: "Cell8 · Tìm label" },
            { id: "cell9", label: "Cell9 · Tổ hợp tùy chọn" },
            { id: "cell10", label: "Cell10 · Phân tích vị trí" },
            { id: "cell11", label: "Cell11 · Pattern số" },
        ];

        function buildNav(showSection) {
            const nav = document.getElementById("nav");
            anchorNav.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "nav-btn";
                btn.textContent = item.label;
                btn.dataset.target = item.id;
                btn.onclick = () => {
                    // Lazy render the section only when needed
                    if (typeof ensureRendered === 'function') {
                        ensureRendered(item.id);
                    }
                    showSection(item.id);
                    history.replaceState(null, "", `#${item.id}`);
                };
                nav.appendChild(btn);
            });
        }

        // ===== Renderers =====
        // Fallback: capture Ctrl+clicks on rows (and Shift-click) so it runs before other handlers
        document.addEventListener('click', (ev) => {
            try {
                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                if (!tr) return;

                // Ctrl+click: navigate to Cell6.6 and apply numbers there (existing behavior)
                if (ev && ev.ctrlKey) {
                    const section = tr.closest('section');
                    if (!section || section.id !== 'cell11') return;
                    ev.preventDefault();
                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                    if (!result) return;
                    const nums = parseSixNumbersFromString(result);
                    if (!nums) return;
                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                    tr.classList.add('ctrl-selected');
                    try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                    if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                    else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                    return;
                }

                // Shift+click: navigate to Cell6.5, switch to 'unpair' mode and paste numbers into unpair inputs
                if (ev && ev.shiftKey) {
                    ev.preventDefault();
                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                    if (!result) return;
                    const nums = parseSixNumbersFromString(result);
                    if (!nums) return;

                    try { document.querySelectorAll('tr.shift-selected').forEach(r => r.classList.remove('shift-selected')); } catch (e) { }
                    tr.classList.add('shift-selected');

                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_5'); } catch (e) { }
                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_5"]');
                    const applyToUnpair = () => {
                        try {
                            // set mode selector to unpair if available
                            const sec = document.getElementById('cell6_5');
                            const modeSel = (sec && sec.__modeSel) ? sec.__modeSel : (document.body && document.body.__modeSel) ? document.body.__modeSel : null;
                            if (modeSel) {
                                try { modeSel.value = 'unpair'; } catch (e) { }
                                try { modeSel.dispatchEvent(new Event('change')); } catch (e) { }
                            }

                            // find unpair inputs and apply numbers
                            for (let k = 0; k < 6; k++) {
                                const id = `cell6_5_unpair_input_${k + 1}`;
                                const inp = document.getElementById(id);
                                if (inp) {
                                    try { inp.value = String(nums[k]); } catch (e) { }
                                    try { inp.dispatchEvent(new Event('input')); } catch (e) { }
                                }
                            }

                            // also update place boxes so popup reflects the pasted numbers
                            try { if (typeof window.setPlaceValues === 'function') window.setPlaceValues(nums.map(n => String(n))); } catch (e) { }
                            try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }

                            // After group recompute, explicitly compute best rule → trash + fav + num highlight
                            setTimeout(() => {
                                // Reset hover state to prevent contamination from previous record's hover-trash
                                try { window.__hoverActive = false; window.__hoverPrevTrash = null; } catch (e) { }
                                try { clearPopupHighlights(); } catch (e) { }
                                try { if (typeof window.computeAndApplyUnpairBest === 'function') window.computeAndApplyUnpairBest(nums); } catch (e) { }
                            }, 500);
                        } catch (e) { /* ignore */ }
                    };

                    if (navBtn) {
                        setTimeout(() => {
                            try { navBtn.click(); } catch (e) { }
                            setTimeout(() => { try { applyToUnpair(); } catch (e) { } }, 220);
                        }, 200);
                    } else {
                        setTimeout(() => { try { applyToUnpair(); } catch (e) { } }, 260);
                    }
                    return;
                }
            } catch (e) { /* ignore */ }
        }, true);
        function sectionShell(id, title, lead = "") {
            const sec = document.createElement("section");
            sec.id = id;
            sec.dataset.section = id;
            const h2 = document.createElement("h2");
            h2.textContent = title;
            sec.appendChild(h2);
            if (lead) {
                const p = document.createElement("p");
                p.className = "lead";
                p.textContent = lead;
                sec.appendChild(p);
            }
            const body = document.createElement("div");
            sec.appendChild(body);
            document.querySelector("main").appendChild(sec);
            return body;
        }

        // Quản lý hiển thị từng "trang" (section) mà không mất state
        function createSectionSwitcher() {
            const main = document.querySelector("main");
            const buttons = () => Array.from(document.querySelectorAll(".nav-btn"));
            const sections = () => Array.from(main.querySelectorAll("section"));
            const scrollPositions = new Map(); // Lưu vị trí scroll cho từng section

            function setActive(id) {
                // Lưu vị trí scroll hiện tại trước khi chuyển
                const currentSection = sections().find(sec => !sec.classList.contains("hidden"));
                if (currentSection) {
                    scrollPositions.set(currentSection.id, window.scrollY);
                }

                buttons().forEach(btn => {
                    const active = btn.dataset.target === id;
                    btn.classList.toggle("active", active);
                });
                sections().forEach(sec => {
                    sec.classList.toggle("hidden", sec.id !== id);
                });

                // notify other components which section is now active
                try { document.dispatchEvent(new CustomEvent('sectionchange', { detail: { id } })); } catch (e) { }

                // Restore vị trí scroll của section mới
                requestAnimationFrame(() => {
                    // Prefer per-input saved scroll for cell10 when available
                    let savedPosition;
                    try {
                        if (id === 'cell10' && window._cell10LastIndex !== undefined && window._cell10LastIndex !== null && window._cell10ScrollByIndex instanceof Map) {
                            const p = window._cell10ScrollByIndex.get(window._cell10LastIndex);
                            if (p !== undefined) savedPosition = p;
                        }
                    } catch (e) { }

                    if (savedPosition === undefined) savedPosition = scrollPositions.get(id);
                    if (savedPosition !== undefined) {
                        window.scrollTo(0, savedPosition);
                    } else {
                        window.scrollTo(0, 0); // Scroll về đầu nếu chưa có lịch sử
                    }
                });
            }

            function showSection(id) {
                const target = sections().find(sec => sec.id === id);
                const fallback = "cell4";
                const finalId = target ? id : fallback;
                setActive(finalId);
            }

            return showSection;
        }

        // Clear popup highlights when switching sections so stale orange outlines
        // from the previous section (e.g. Cell6.5) don't persist on the popup.
        document.addEventListener('sectionchange', () => {
            try {
                clearPopupHighlights();
                window.__popupHighlights = null;
                window.__popupHighlightSource = null;
            } catch (e) { }
        });

        // When leaving Cell6.5 unpair mode, clear trash and fav that were set
        // by computeAndApplyUnpairBest / hover so they don't persist on other pages.
        // When entering Cell6.5 unpair mode, recompute from 6 inputs.
        document.addEventListener('sectionchange', (ev) => {
            try {
                const id = ev && ev.detail && ev.detail.id;
                const c65 = document.getElementById('cell6_5');
                const isUnpair = c65 && c65.querySelector('.controls.unpair-mode');

                if (id === 'cell6_5') {
                    // Entering Cell6.5: if in unpair mode with 6 filled inputs, recompute
                    if (isUnpair && typeof window.computeAndApplyUnpairBest === 'function') {
                        try {
                            const inputs = c65.querySelectorAll('.controls.unpair-mode .drag-input-container input[type="number"]');
                            if (inputs && inputs.length >= 1) {
                                const vals = Array.from(inputs).map(el => (el.value || '').trim()).filter(s => s !== '');
                                if (vals.length >= 1) {
                                    const nums = vals.map(s => parseInt(s, 10)).filter(n => Number.isFinite(n) && n >= 1 && n <= 45);
                                    const uniq = Array.from(new Set(nums));
                                    if (uniq.length >= 1) {
                                        setTimeout(() => { try { window.computeAndApplyUnpairBest(uniq); } catch (e) { } }, 120);
                                    }
                                }
                            }
                        } catch (e) { }
                    }
                    return;
                }

                // Leaving Cell6.5: clean up if it was in unpair mode
                if (!isUnpair) return;
                // Clear trash
                try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }
                // Clear fav: remove the computed candidate and any hover candidate
                try {
                    const cand = window.__cell6_5_lastCand;
                    if (cand != null && typeof window.removeFromFav === 'function') window.removeFromFav(Number(cand));
                    window.__cell6_5_lastCand = null;
                } catch (e) { }
                try {
                    const hfc = window.__cell6_5_hoverFavCand;
                    if (hfc != null && typeof window.removeFromFav === 'function') window.removeFromFav(Number(hfc));
                    window.__cell6_5_hoverFavCand = null;
                } catch (e) { }
                // Reset hover state
                try { window.__hoverActive = false; } catch (e) { }
                try { window.__hoverPrevTrash = null; } catch (e) { }
                try { window.__lastHoveredUnpairNum = null; } catch (e) { }
            } catch (e) { }
        });

        // Keep the trashPopup average `k̄` in sync with the active section.
        // Remove the `.avg-k` element whenever we leave `cell5_5`, and recreate
        // it when `cell5_5` becomes active so the UI never shows k̄ on other pages.
        document.addEventListener('sectionchange', (ev) => {
            try {
                const id = ev && ev.detail && ev.detail.id;
                const tp = document.getElementById('trashPopup');
                if (!tp) return;
                const firstDiv = tp.querySelector('div');
                if (!firstDiv) return;
                const existing = firstDiv.querySelector('.avg-k');
                if (existing) existing.remove();
                if (id === 'cell5_5') {
                    const span = document.createElement('span');
                    span.className = 'avg-k';
                    span.style.cssText = 'margin-left:12px;color:var(--muted);font-weight:700;';
                    const displayAvg = (typeof window.__lastAvgK === 'number' && !Number.isNaN(window.__lastAvgK)) ? window.__lastAvgK.toFixed(2) : '';
                    span.textContent = displayAvg ? ('k̄ = ' + displayAvg) : 'k̄ = ';
                    firstDiv.appendChild(span);
                }
            } catch (e) { /* ignore */ }
        });


        function renderCell4() {
            const body = sectionShell("cell4", "Cell4 · Tỷ lệ theo vị trí (home)", "Top/Sort tương tự notebook: hiển thị tỷ lệ từng số theo 6 vị trí.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[10, "Top 10"], [20, "Top 20"], [30, "Top 30"], [45, "Tất cả (45)"]].forEach(([v, l]) => {
                const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o);
            });
            topSel.value = "45";
            const sortSel = document.createElement("select");
            [["default", "Mặc định (1→45)"], ["total_desc", "Theo tổng % giảm dần"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            // Mặc định chọn sắp xếp theo tổng % giảm dần
            sortSel.value = "total_desc";
            const decimalSel = document.createElement("select");
            [[0, "0 chữ số"], [1, "1 chữ số"], [2, "2 chữ số"], [3, "3 chữ số"], [4, "4 chữ số"], [5, "5 chữ số"], [6, "6 chữ số"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiển thị:", topSel, "Sắp xếp:", sortSel, "Độ chính xác:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);
            // (removed debug placeholder)

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const counts = Array.from({ length: 46 }, () => Array(6).fill(0));
                let total = 0;
                rows.forEach(r => {
                    if (r.nums.length !== 6) return;
                    total++;
                    r.nums.forEach((v, i) => { counts[v][i]++; });
                });
                let data = [];
                for (let v = 1; v <= 45; v++) {
                    const pcts = counts[v].map(c => total ? c / total : 0);
                    const countSum = counts[v].reduce((a, b) => a + b, 0);
                    data.push({ v, pcts, sum: pcts.reduce((a, b) => a + b, 0), count: countSum });
                }
                if (sortSel.value === "total_desc") data.sort((a, b) => b.sum - a.sum); else data.sort((a, b) => a.v - b.v);
                data = data.slice(0, parseInt(topSel.value, 10));

                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr>" +
                    "<th>Rank</th><th>Số</th><th class=\"col-total\">Tổng %</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                data.forEach((row, idx) => {
                    const bg = idx % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.05)";
                    // Assign tier by 9-rank blocks: ranks 1-9 -> tier1, 10-18 -> tier2, ...
                    let tier = Math.floor(idx / 9) + 1;
                    if (tier < 1) tier = 1;
                    if (tier > 5) tier = 5;
                    html += `<tr style="background:${bg};">` +
                        `<td><span class="rank-pill rank-tier-${tier}">#${idx + 1}</span></td><td><span class='pill'>${row.v}</span></td>` +
                        `<td class=\"col-total\"><span class='muted rank-pill rank-tier-${tier}' style='font-size:12px;margin-right:8px;'>${row.count}</span><span class='muted' style='font-size:12px;margin:0 6px'>/${total}=</span><strong class='rank-pill rank-tier-${tier}'>${fmtPctCustom(row.sum, decimals)}</strong></td>` +
                        row.pcts.map(p => `<td>${fmtPctCustom(p, decimals)}</td>`).join("") +
                        `</tr>`;
                });
                html += "</tbody></table></div>";
                wrap.innerHTML = html;
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell11
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell11_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach delegated hover + Ctrl+click handlers on wrap so all generated inner cards/tables receive behavior
                (function attachRowHoverAndCtrlClick_cell11_delegated() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const cardEl = tr.closest('.card');
                            if (!cardEl) return;
                            const s = cardEl.querySelector('strong');
                            if (!s) return;
                            const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;
                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                            } catch (e) { }
                        });
                    } catch (err) { }
                })();
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell11
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell11_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach Ctrl+click handler for cell11 (use delegation on wrap so all inner cards/tables are covered)
                (function attachRowHoverAndCtrlClick_cell11() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const cardEl = tr.closest('.card');
                            if (!cardEl) return;
                            const s = cardEl.querySelector('strong');
                            if (!s) return;
                            const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;
                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell11_ctrl_selected', result); } catch (e) { }
                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                            } catch (e) { }
                        });
                    } catch (err) { }
                })();
                // ensure viewport shows controls + results consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            topSel.onchange = sortSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5: xếp hạng theo vị trí
        function renderCell5() {
            const body = sectionShell("cell5", "Cell5 · Xếp hạng theo vị trí", "Chọn top và tô đậm theo notebook.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const topSel = document.createElement("select");
            [[3, "Top 3"], [5, "Top 5"], [10, "Top 10"], [45, "Tất cả (45)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; topSel.appendChild(o); });
            topSel.value = "45";
            const decimalSel = document.createElement("select");
            [[0, "0 chữ số"], [1, "1 chữ số"], [2, "2 chữ số"], [3, "3 chữ số"], [4, "4 chữ số"], [5, "5 chữ số"], [6, "6 chữ số"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; decimalSel.appendChild(o); });
            decimalSel.value = "2";
            controls.append("Hiển thị:", topSel, "Độ chính xác:", decimalSel);
            body.appendChild(controls);
            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const count = Array.from({ length: 6 }, () => Array(46).fill(0));
                rows.forEach(r => { r.nums.forEach((v, i) => { count[i][v]++; }); });
                const decimals = parseInt(decimalSel.value, 10);
                let html = "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";
                const topN = parseInt(topSel.value, 10);
                for (let rank = 0; rank < topN; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        const arr = [...Array(45).keys()].map(i => i + 1).map(v => [v, count[pos][v]]).sort((a, b) => b[1] - a[1]);
                        const [v, c] = arr[rank];
                        const pct = rows.length ? (c / rows.length) : 0;
                        const col = getCol(v);
                        cells.push(`<td><div><strong>${v}</strong> <span class='muted'>[C${col}]</span></div><div class='muted'>${c}/${rows.length}= ${fmtPctCustom(pct, decimals)}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank + 1}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                // Thêm bảng mới: Xếp hạng cột theo vị trí (6x6)
                html += "<h3 style='margin-top: 24px; margin-bottom: 12px;'>Xếp hạng cột theo vị trí</h3>";

                // Tổng % của từng cột (C1-C6) trên toàn bộ 6 vị trí
                const colTotals = Array(6).fill(0);
                rows.forEach(r => {
                    r.nums.forEach(v => { const col = getCol(v); colTotals[col - 1]++; });
                });
                const totalPositions = rows.length * 6;
                const colPctDisplay = colTotals.map((c, idx) => {
                    const pct = fmtPctCustom(totalPositions ? c / totalPositions : 0, decimals);
                    return `<span class="pill" style="background:linear-gradient(135deg, var(--accent-2) 0%, var(--accent) 100%); color:#fff; border:none;">C${idx + 1}</span> <strong>${pct}</strong>`;
                }).join(" · ");
                html += `<div style='margin:6px 0 10px; font-size:12px; color:var(--text-strong);'>${colPctDisplay}</div>`;

                html += "<div><table><thead><tr><th>Rank</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody>";

                // Tính toán: với mỗi vị trí, xếp hạng các cột (1-6) theo số lần xuất hiện
                for (let rank = 1; rank <= 6; rank++) {
                    const cells = [];
                    for (let pos = 0; pos < 6; pos++) {
                        // Đếm mỗi cột (1-6) xuất hiện ở vị trí này
                        const colCounts = {};
                        for (let col = 1; col <= 6; col++) colCounts[col] = 0;

                        rows.forEach(r => {
                            const v = r.nums[pos];
                            const col = getCol(v);
                            colCounts[col]++;
                        });

                        // Sắp xếp các cột theo số lần xuất hiện (giảm dần)
                        const sortedCols = Object.entries(colCounts)
                            .map(([col, count]) => ({ col: parseInt(col), count }))
                            .sort((a, b) => b.count - a.count);

                        // Lấy cột ở rank này (rank - 1 vì rank bắt đầu từ 1)
                        const { col: topCol, count: topCount } = sortedCols[rank - 1];
                        const pct = rows.length ? (topCount / rows.length) : 0;
                        cells.push(`<td><div><strong>C${topCol}</strong></div><div class='muted'>${topCount}/${rows.length}= ${fmtPctCustom(pct, parseInt(decimalSel.value, 10))}</div></td>`);
                    }
                    const bg = rank % 2 ? "rgba(255,255,255,0.02)" : "rgba(255,255,255,0.04)";
                    html += `<tr style="background:${bg};"><td>#${rank}</td>${cells.join("")}</tr>`;
                }
                html += "</tbody></table></div>";

                wrap.innerHTML = html;
            }
            topSel.onchange = decimalSel.onchange = draw;
            draw();
        }

        // Cell5.5: Lịch sử — in ra toàn bộ bộ các kỳ, 3 bảng trên một hàng, loại bỏ cột euclid
        function renderCell5_5() {
            const body = sectionShell("cell5_5", "Cell5.5 · Lịch sử", "Hiển thị lịch sử toàn bộ bộ các kỳ. Lọc theo năm và sắp xếp theo thời gian.");
            const controls = document.createElement("div");
            controls.className = "controls";

            const sortSel = document.createElement("select");
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            sortSel.value = 'desc';

            const yearSel = document.createElement("select");
            // will populate years after data is ready

            const monthSel = document.createElement("select");
            // will populate months after years are populated

            // info button that shows counts popup on hover
            const infoBtn = document.createElement('div');
            infoBtn.textContent = 'info';
            infoBtn.title = 'Di chuột để xem thống kê số lần xuất hiện (1..45) cho Năm/Tháng đã chọn';
            infoBtn.style.padding = '8px 10px';
            infoBtn.style.borderRadius = '8px';
            infoBtn.style.border = '1px solid var(--border)';
            infoBtn.style.background = 'var(--card)';
            infoBtn.style.color = 'var(--text)';
            infoBtn.style.cursor = 'pointer';
            infoBtn.style.fontSize = '12px';
            infoBtn.style.marginLeft = '6px';

            // Trash filter toggle (click to toggle include|exclude)
            const trashSel = document.createElement('button');
            try { trashSel.id = 'cell5_5_trashSel'; trashSel.className = 'trash-mode trash-toggle'; } catch (e) { }
            trashSel.type = 'button';
            trashSel.value = 'include';
            trashSel.textContent = 'include';
            trashSel.title = 'Click to toggle trash mode (include/exclude)';
            trashSel.style.padding = '6px 10px';
            trashSel.addEventListener('click', () => {
                try {
                    trashSel.value = (trashSel.value === 'include') ? 'exclude' : 'include';
                    trashSel.textContent = trashSel.value;
                    // emit change so code that assigns .onchange will run
                    try { trashSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { if (typeof draw === 'function') draw(); } catch (e) { }
                } catch (e) { }
            });

            // Fav filter toggle (click to toggle include|exclude) - default exclude
            const favSel = document.createElement('button');
            try { favSel.id = 'cell5_5_favSel'; favSel.className = 'fav-mode fav-toggle'; } catch (e) { }
            favSel.type = 'button';
            favSel.value = 'exclude';
            favSel.textContent = 'exclude';
            favSel.title = 'Click to toggle fav mode (include/exclude)';
            favSel.style.padding = '6px 10px';
            favSel.style.marginLeft = '6px';
            favSel.addEventListener('click', () => {
                try {
                    favSel.value = (favSel.value === 'include') ? 'exclude' : 'include';
                    favSel.textContent = favSel.value;
                    try { favSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { if (typeof draw === 'function') draw(); } catch (e) { }
                } catch (e) { }
            });

            controls.append(sortSel, "Năm:", yearSel, "Tháng:", monthSel, "Trash:", trashSel, "Fav:", favSel, infoBtn);
            body.appendChild(controls);

            // Ensure Cell5.5 redraws when the popup trash changes (only add listener once)
            try {
                if (!window.__cell5_5_trash_listener_added) {
                    document.addEventListener('trashchange', function () {
                        try {
                            // Query the current selector(s) by id to avoid stale closure references
                            const cur = document.getElementById('cell5_5_trashSel');
                            const other = document.getElementById('cell6_6_trashSel');
                            const isExclude = (cur && String(cur.value) === 'exclude') || (other && String(other.value) === 'exclude');
                            if (isExclude) {
                                try {
                                    // Invalidate cached grouping so new trash contents are applied
                                    try { groupCache = null; } catch (e) { }
                                    try { cacheKey = null; } catch (e) { }
                                    try { baselineArrAll = null; baselineArrGlobal = null; baselineCountsMap = null; baselineAllKeys = null; baselineGlobalKeys = null; } catch (e) { }
                                    // Redraw (draw -> group) so exclude filtering is recomputed
                                    try { if (typeof draw === 'function') draw(); else if (typeof group === 'function') group(); } catch (err) { /* ignore */ }
                                } catch (err) { }
                            }
                        } catch (e) { }
                    });
                    window.__cell5_5_trash_listener_added = true;
                }
            } catch (e) { /* ignore */ }

            // Ensure Cell5.5 redraws when the fav popup changes (only add listener once)
            try {
                if (!window.__cell5_5_fav_listener_added) {
                    document.addEventListener('favchange', function () {
                        try {
                            const cur = document.getElementById('cell5_5_favSel');
                            const other = document.getElementById('cell6_6_favSel');
                            const isInclude = (cur && String(cur.value) === 'include') || (other && String(other.value) === 'include');
                            if (isInclude) {
                                try { groupCache = null; } catch (e) { }
                                try { cacheKey = null; } catch (e) { }
                                try { baselineArrAll = null; baselineArrGlobal = null; baselineCountsMap = null; baselineAllKeys = null; baselineGlobalKeys = null; } catch (e) { }
                                try { if (typeof draw === 'function') draw(); else if (typeof group === 'function') group(); } catch (err) { /* ignore */ }
                            }
                        } catch (e) { }
                    });
                    window.__cell5_5_fav_listener_added = true;
                }
            } catch (e) { /* ignore */ }

            const wrap = document.createElement("div");
            wrap.className = "card";
            body.appendChild(wrap);

            // parse date string into sortable timestamp (reused by months/year builders)
            function parseDateSortable(s) {
                if (!s) return 0;
                s = String(s).trim();
                // dd/mm/yyyy or dd/mm/yy
                let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                if (m) {
                    let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                    if (yy < 100) yy += 2000;
                    const dt = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt)) return dt.getTime();
                }
                // digits only: ddmmyyyy or ddmmyy
                const digits = s.replace(/\D/g, '');
                if (/^\d+$/.test(digits)) {
                    if (digits.length === 8) {
                        const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                        const dt = new Date(yyyy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    const d6 = digits.padStart(6, '0');
                    const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                    const dt2 = new Date(yy, mm - 1, dd);
                    if (!isNaN(dt2)) return dt2.getTime();
                }
                // fallback to Date parsing
                const dtf = new Date(s);
                if (!isNaN(dtf)) return dtf.getTime();
                return 0;
            }

            function populateYears() {
                const prev = yearSel.value;
                yearSel.innerHTML = '';
                const yearsSet = new Set();
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (s.length >= 4) yearsSet.add(s.slice(-4));
                });
                const years = Array.from(yearsSet).filter(Boolean).sort((a, b) => b - a);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Tất cả'; yearSel.appendChild(oAll);
                years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; yearSel.appendChild(o); });
                // restore previous selection if still available, otherwise default to 'all'
                if (prev && Array.from(yearSel.options).some(o => o.value === prev)) {
                    yearSel.value = prev;
                } else {
                    yearSel.value = 'all';
                }
                // populate months for the (possibly restored) year selection
                // mark selected option visually
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                populateMonths();
            }

            function populateMonths() {
                const prev = monthSel.value;
                monthSel.innerHTML = '';
                const monthsSet = new Set();
                const selectedYear = yearSel.value;
                rows.forEach(r => {
                    const s = String(r.date || '');
                    if (!s) return;
                    // if filtering by year, only consider rows matching that year (by last-4)
                    if (selectedYear && selectedYear !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== selectedYear) return;
                    }
                    const ts = parseDateSortable(s);
                    if (ts) {
                        const dt = new Date(ts);
                        const m = dt.getMonth() + 1;
                        monthsSet.add(m);
                    }
                });
                const months = Array.from(monthsSet).sort((a, b) => a - b);
                const oAll = document.createElement('option'); oAll.value = 'all'; oAll.textContent = 'Tất cả'; monthSel.appendChild(oAll);
                // if no months detected (e.g., non-parseable dates), include generic 1..12
                if (!months.length) {
                    for (let i = 1; i <= 12; i++) {
                        const o = document.createElement('option'); o.value = String(i).padStart(2, '0'); o.textContent = `Tháng ${i}`; monthSel.appendChild(o);
                    }
                } else {
                    months.forEach(m => { const o = document.createElement('option'); o.value = String(m).padStart(2, '0'); o.textContent = `Tháng ${m}`; monthSel.appendChild(o); });
                }
                if (prev && Array.from(monthSel.options).some(o => o.value === prev)) {
                    monthSel.value = prev;
                } else {
                    monthSel.value = 'all';
                }
                // mark selected option visually
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
            }

            // Create a floating popup for the info box (shared for all hovers)
            const infoPopup = document.createElement('div');
            // use fixed positioning so the popup stays aligned with sticky controls
            infoPopup.style.position = 'fixed';
            infoPopup.style.zIndex = 9999;
            infoPopup.style.minWidth = '220px';
            infoPopup.style.maxWidth = '480px';
            infoPopup.style.maxHeight = '320px';
            infoPopup.style.overflow = 'auto';
            infoPopup.style.padding = '10px';
            infoPopup.style.borderRadius = '8px';
            infoPopup.style.border = '1px solid var(--border)';
            infoPopup.style.background = 'var(--panel)';
            infoPopup.style.color = 'var(--text)';
            infoPopup.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
            infoPopup.style.display = 'none';
            document.body.appendChild(infoPopup);

            // Pre-compute global totals/rank (across all rows, full history)
            const globalCounts = new Array(46).fill(0);
            rows.forEach(r => {
                const nums = r.nums || [];
                nums.forEach(n => {
                    const v = Number(n);
                    if (v >= 1 && v <= 45) globalCounts[v]++;
                });
            });
            const globalItems = [];
            for (let i = 1; i <= 45; i++) globalItems.push({ n: i, c: globalCounts[i] });
            globalItems.sort((a, b) => b.c - a.c || a.n - b.n);
            const globalRankMap = {};
            globalItems.forEach((it, idx) => { globalRankMap[it.n] = idx + 1; });

            // Build counts for numbers 1..45 for currently selected year/month
            let infoSort = 'desc'; // 'default' | 'desc' | 'asc' — default to Giảm dần
            function buildCountsHtml() {
                // filter rows by year/month similar to draw()
                const filtered = rows.filter(r => {
                    const s = String(r.date || '');
                    if (!s) return false;
                    if (yearSel.value && yearSel.value !== 'all') {
                        if (s.length < 4 || s.slice(-4) !== yearSel.value) return false;
                    }
                    if (monthSel.value && monthSel.value !== 'all') {
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        if (m !== monthSel.value) return false;
                    }
                    return true;
                });

                const counts = new Array(46).fill(0);
                filtered.forEach(r => {
                    const nums = r.nums || [];
                    nums.forEach(n => {
                        const v = Number(n);
                        if (v >= 1 && v <= 45) counts[v]++;
                    });
                });

                // prepare items and apply sorting
                const items = [];
                for (let i = 1; i <= 45; i++) items.push({ n: i, c: counts[i] });
                if (infoSort === 'desc') items.sort((a, b) => b.c - a.c || a.n - b.n);
                else if (infoSort === 'asc') items.sort((a, b) => a.c - b.c || a.n - b.n);

                let html = `<div style="font-weight:700;margin-bottom:6px;">Thống kê xuất hiện (Năm: ${yearSel.value || 'Tất cả'} · Tháng: ${monthSel.value || 'Tất cả'})</div>`;
                html += `<div style="margin-bottom:8px;"><select id="infoSortSel" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);"><option value="default">Mặc định</option><option value="desc">Giảm dần (số lần)</option><option value="asc">Tăng dần (số lần)</option></select></div>`;
                // compute numbers that did NOT appear in the filtered set
                const zeros = items.filter(it => it.c === 0).map(it => it.n).sort((a, b) => a - b);
                if (zeros.length) {
                    const zerosHtml = zeros.map(n => `<span class="info-zero-num">${n}</span>`).join(' ');
                    html += `<div style="margin-top:6px;font-size:12px;font-weight:700;color:var(--muted);">Không có ${zeros.length} số: ${zerosHtml}</div>`;
                }

                html += `<div style="margin-top:8px;color:var(--muted);font-size:11px;">Tổng kỳ: ${filtered.length}</div>`;
                html += '<table class="no-sticky" style="width:100%;font-size:12px;border-collapse:collapse;">';
                html += '<thead><tr><th style="width:28px;text-align:left;padding:6px;border-bottom:1px solid var(--border);">Hạng</th><th class="num-header" style="width:36px;text-align:center;padding:6px;border-bottom:1px solid var(--border);">Số</th><th style="text-align:right;padding:6px;border-bottom:1px solid var(--border);">Số lần</th></tr></thead>';
                html += '<tbody>';
                items.forEach(it => {
                    const rankNum = globalRankMap[it.n];
                    const displayRank = rankNum || '-';
                    let pillClass = 'euclid-pill';
                    if (typeof rankNum === 'number') {
                        let tier = Math.ceil(rankNum / 9); // 45 numbers → 5 tiers of ~9 each
                        tier = Math.max(1, Math.min(5, tier));
                        pillClass += ' rank-tier-' + tier;
                    }
                    html += `<tr><td style="padding:4px 6px;"><span class="${pillClass}">${displayRank}</span></td><td class="num-cell" style="padding:4px 6px;text-align:center;"><span class="info-num-pill">${it.n}</span></td><td style="padding:4px 6px;text-align:right;">${it.c}</td></tr>`;
                });
                html += '</tbody></table>';
                html += `<div style="margin-top:8px;color:var(--muted);font-size:11px;">Tổng kỳ: ${filtered.length}</div>`;
                return html;
            }

            // Show/hide logic with pointer interaction (keep open if moving between btn and popup)
            let hoverTimeout = null;
            function renderInfoPopup() {
                infoPopup.innerHTML = buildCountsHtml();
                // wire the sort select inside popup
                const sel = infoPopup.querySelector('#infoSortSel');
                if (sel) {
                    sel.value = infoSort;
                    sel.onchange = () => {
                        infoSort = sel.value; infoPopup.innerHTML = buildCountsHtml(); // re-wire recursively
                        const sel2 = infoPopup.querySelector('#infoSortSel'); if (sel2) sel2.onchange = () => { infoSort = sel2.value; renderInfoPopup(); }
                    };
                }
            }

            // Positioning and show/hide helpers so the popup stays anchored
            // under the sticky controls even while the page is scrolled.
            let __infoPopupPositionBound = false;
            function positionInfoPopup() {
                try {
                    const rect = infoBtn.getBoundingClientRect();
                    const top = rect.bottom + 8;
                    let left = rect.left;
                    // Use actual popup width when available; fallback to declared maxWidth
                    const popupRect = infoPopup.getBoundingClientRect();
                    const popupWidth = (popupRect && popupRect.width) ? popupRect.width : parseInt(infoPopup.style.maxWidth || 480, 10);
                    // keep popup within viewport with small padding
                    const maxLeft = Math.max(8, window.innerWidth - popupWidth - 12);
                    if (left > maxLeft) left = maxLeft;
                    if (left < 8) left = 8;
                    infoPopup.style.top = top + 'px';
                    infoPopup.style.left = left + 'px';
                } catch (e) { /* ignore positioning errors */ }
            }

            function bindPopupPositionListeners() {
                if (__infoPopupPositionBound) return;
                // capture scroll so reposition happens even when ancestor elements scroll
                window.addEventListener('scroll', positionInfoPopup, true);
                window.addEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = true;
            }

            function unbindPopupPositionListeners() {
                if (!__infoPopupPositionBound) return;
                window.removeEventListener('scroll', positionInfoPopup, true);
                window.removeEventListener('resize', positionInfoPopup);
                __infoPopupPositionBound = false;
            }

            function showInfoPopup() {
                // only show when the Cell5.5 section is active
                const cell5 = document.getElementById('cell5_5');
                if (cell5 && cell5.classList.contains('hidden')) return;
                clearTimeout(hoverTimeout);
                renderInfoPopup();
                // ensure popup is visible so we can measure and position it
                infoPopup.style.display = 'block';
                // position now and while scrolling/resizing
                positionInfoPopup();
                bindPopupPositionListeners();
            }

            function hideInfoPopupSoon() {
                clearTimeout(hoverTimeout);
                hoverTimeout = setTimeout(() => { hideInfoPopup(); }, 180);
            }

            // Click-to-toggle only: popup opens/closes when clicking the `infoBtn` itself.
            infoBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (infoPopup.style.display === 'block') hideInfoPopup();
                else showInfoPopup();
            });
            // make infoBtn focusable and allow keyboard toggle (Enter/Space)
            infoBtn.tabIndex = 0;
            infoBtn.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' || ev.key === ' ') {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (infoPopup.style.display === 'block') hideInfoPopup();
                    else showInfoPopup();
                }
            });

            // immediate hide helper (used by click)
            function hideInfoPopup() {
                clearTimeout(hoverTimeout);
                infoPopup.style.display = 'none';
                try { unbindPopupPositionListeners(); } catch (e) { }
            }

            // Prevent outer page scrolling when the pointer is over the popup.
            // Wheel: stop propagation and prevent default when appropriate.
            infoPopup.addEventListener('wheel', function (ev) {
                // allow scrolling inside the popup but prevent page scroll
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!canScroll) {
                    ev.preventDefault(); ev.stopPropagation();
                    return;
                }
                const delta = ev.deltaY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if ((delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    // consume the wheel so page doesn't move while interacting with popup
                    ev.stopPropagation();
                }
            }, { passive: false });

            // Touch support: prevent overscroll from reaching page on mobile
            let __infoTouchStartY = 0;
            infoPopup.addEventListener('touchstart', function (ev) {
                if (ev.touches && ev.touches.length) __infoTouchStartY = ev.touches[0].clientY;
            }, { passive: true });
            infoPopup.addEventListener('touchmove', function (ev) {
                const canScroll = infoPopup.scrollHeight > infoPopup.clientHeight;
                if (!ev.touches || !ev.touches.length) return;
                const curY = ev.touches[0].clientY;
                const delta = __infoTouchStartY - curY;
                const atTop = infoPopup.scrollTop === 0;
                const atBottom = Math.abs(infoPopup.scrollHeight - infoPopup.clientHeight - infoPopup.scrollTop) < 1;
                if (!canScroll || (delta > 0 && atBottom) || (delta < 0 && atTop)) {
                    ev.preventDefault(); ev.stopPropagation();
                } else {
                    ev.stopPropagation();
                }
            }, { passive: false });

            // hide the info popup whenever we switch to another section
            document.addEventListener('sectionchange', (ev) => {
                try {
                    if (!ev || !ev.detail) return;
                    if (ev.detail.id !== 'cell5_5') {
                        hideInfoPopup();
                    }
                } catch (e) { }
            });

            // Update popup if filters change while it's visible
            yearSel.addEventListener('change', () => {
                Array.from(yearSel.options).forEach(o => o.classList.toggle('highlighted', o.value === yearSel.value));
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });
            monthSel.addEventListener('change', () => {
                Array.from(monthSel.options).forEach(o => o.classList.toggle('highlighted', o.value === monthSel.value));
                if (infoPopup.style.display === 'block') renderInfoPopup();
            });

            function draw() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                populateYears();
                // Build data with parsedDate (if available) and display date
                let data = rows.map(r => ({ date: r.date || '', parsedDate: r.parsedDate || null, nums: r.nums || [], label: r.label || '' }));
                if (yearSel.value && yearSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        return s.length >= 4 ? s.slice(-4) === yearSel.value : false;
                    });
                }
                // filter by month if selected
                if (monthSel.value && monthSel.value !== 'all') {
                    data = data.filter(d => {
                        const s = String(d.date || '');
                        const ts = parseDateSortable(s);
                        if (!ts) return false;
                        const dt = new Date(ts);
                        const m = String(dt.getMonth() + 1).padStart(2, '0');
                        return m === monthSel.value;
                    });
                }

                // Apply trash-exclude filter when requested: if trashSel is set to 'exclude',
                // remove any record that contains at least one number currently in the popup trash.
                try {
                    if (typeof trashSel !== 'undefined' && trashSel.value === 'exclude') {
                        let trashed = [];
                        try {
                            if (window.getTrashItems && typeof window.getTrashItems === 'function') trashed = window.getTrashItems();
                            else if (Array.isArray(window.__trashItems)) trashed = window.__trashItems.slice();
                        } catch (e) { trashed = []; }
                        if (trashed && trashed.length) {
                            const tset = new Set(trashed.map(n => Number(n)));
                            data = data.filter(d => {
                                const nums = d.nums || [];
                                for (const n of nums) if (tset.has(Number(n))) return false;
                                return true;
                            });
                        }
                    }
                } catch (e) { /* ignore trash filter errors */ }

                // Apply fav-include filter when requested: if favSel is set to 'include',
                // keep only records that contain at least one number currently in the fav popup.
                try {
                    if (typeof favSel !== 'undefined' && favSel.value === 'include') {
                        let favs = [];
                        try {
                            if (window.getFavItems && typeof window.getFavItems === 'function') {
                                favs = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                            } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                                favs = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                            } else {
                                // try to read favPopup cells (prefer dataset.number)
                                const f = document.getElementById('favPopup');
                                if (f) {
                                    favs = Array.from(f.querySelectorAll('td.fav-number')).map(td => {
                                        try {
                                            const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                            if (dn) return Number(dn);
                                            const txt = String(td.textContent || '');
                                            const m = txt.match(/(\d+)/);
                                            return m ? Number(m[1]) : null;
                                        } catch (e) { return null; }
                                    }).filter(n => Number.isFinite(n));
                                }
                            }
                        } catch (e) { favs = []; }
                        if (favs) {
                            const fset = new Set((favs || []).map(n => Number(n)));
                            // read filter operator/count from favPopup controls (fallbacks provided)
                            let op = '>=';
                            let req = 1;
                            try {
                                const fpop = document.getElementById('favPopup');
                                if (fpop) {
                                    const opEl = fpop.querySelector('#favFilterOp');
                                    const cntEl = fpop.querySelector('#favFilterCount');
                                    if (opEl && ['>=', '<=', '='].includes(opEl.value)) op = opEl.value;
                                    if (cntEl) {
                                        const v = Number(cntEl.value);
                                        if (Number.isFinite(v)) req = Math.max(0, Math.min(6, Math.floor(v)));
                                    }
                                }
                            } catch (e) { }

                            data = data.filter(d => {
                                const nums = d.nums || [];
                                let matchCount = 0;
                                for (const n of nums) if (fset.has(Number(n))) matchCount++;
                                if (op === '>=') return matchCount >= req;
                                if (op === '=') return matchCount === req;
                                if (op === '<=') return matchCount <= req;
                                return matchCount >= req;
                            });
                        }
                    }
                } catch (e) { /* ignore fav filter errors */ }
                // Build favSet for highlighting numbers in the rendered result pills
                let __cell5_5_favSet = new Set();
                try {
                    let favsForMark = [];
                    if (window.getFavItems && typeof window.getFavItems === 'function') favsForMark = (window.getFavItems() || []).slice();
                    else if (Array.isArray(window.__favItems) && window.__favItems.length) favsForMark = (window.__favItems || []).slice();
                    else {
                        const fpop = document.getElementById('favPopup');
                        if (fpop) {
                            favsForMark = Array.from(fpop.querySelectorAll('td.fav-number')).map(td => {
                                try {
                                    const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                    if (dn) return Number(dn);
                                    const txt = String(td.textContent || '');
                                    const m = txt.match(/(\d+)/);
                                    return m ? Number(m[1]) : null;
                                } catch (e) { return null; }
                            }).filter(n => Number.isFinite(n));
                        }
                    }
                    __cell5_5_favSet = new Set((favsForMark || []).map(n => Number(n)).filter(n => Number.isFinite(n)));
                } catch (e) { __cell5_5_favSet = new Set(); }
                // Helper: parse common dd/mm/yyyy or dd/mm/yy or digit-only forms into timestamp
                function parseDateSortable(s) {
                    if (!s) return 0;
                    s = String(s).trim();
                    // dd/mm/yyyy or dd/mm/yy
                    let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                    if (m) {
                        let dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
                        if (yy < 100) yy += 2000;
                        const dt = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt)) return dt.getTime();
                    }
                    // digits only: ddmmyyyy or ddmmyy
                    const digits = s.replace(/\D/g, '');
                    if (/^\d+$/.test(digits)) {
                        if (digits.length === 8) {
                            const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                            const dt = new Date(yyyy, mm - 1, dd);
                            if (!isNaN(dt)) return dt.getTime();
                        }
                        const d6 = digits.padStart(6, '0');
                        const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy = 2000 + Number(d6.slice(4, 6));
                        const dt2 = new Date(yy, mm - 1, dd);
                        if (!isNaN(dt2)) return dt2.getTime();
                    }
                    // fallback to Date parsing
                    const dtf = new Date(s);
                    if (!isNaN(dtf)) return dtf.getTime();
                    return 0;
                }

                data = data.slice().sort((a, b) => {
                    const ta = a.parsedDate ? a.parsedDate.getTime() : parseDateSortable(a.date);
                    const tb = b.parsedDate ? b.parsedDate.getTime() : parseDateSortable(b.date);
                    return sortSel.value === 'desc' ? tb - ta : ta - tb;
                });

                if (!data.length) { wrap.innerHTML = "<div class='loader'>Không có dữ liệu cho lựa chọn này</div>"; return; }

                const pageSize = 20;
                const pages = [];
                for (let i = 0; i < data.length; i += pageSize) pages.push(data.slice(i, i + pageSize));

                // DEBUG: log counts to help diagnose mismatched page count reported by user
                //try { console.log('renderCell5_5 debug:', { filteredCount: data.length, pages: pages.length, totalRows: rows.length }); } catch (e) { }

                // Compute a single global average k (use cached helper) so the
                // trash popup and all pages render consistently regardless of
                // page ordering. Store as rounded number in window.__lastAvgK.
                try {
                    const allTvals = data.map(r => {
                        try {
                            if (typeof window.getRowTrashK === 'function') {
                                const v = window.getRowTrashK(r);
                                return Number.isFinite(v) ? v : 0;
                            }
                        } catch (e) { }
                        return 0;
                    });
                    const sumAll = allTvals.reduce((s, v) => s + v, 0);
                    const globalAvg = allTvals.length ? (sumAll / allTvals.length) : 0;
                    window.__lastAvgK = Number.isFinite(globalAvg) ? Number(globalAvg.toFixed(2)) : null;
                    //console.log('[TRASH-DEBUG] renderCell5_5 set global __lastAvgK=', window.__lastAvgK);
                } catch (e) { window.__lastAvgK = null; }

                if (!pages.length) {
                    wrap.innerHTML = "<div class='loader'>Không có dữ liệu cho lựa chọn này</div>";
                    return;
                }

                // Build lightweight card placeholders and mount content lazily to avoid scroll jank
                wrap.innerHTML = '';
                const infoBar = document.createElement('div');
                infoBar.style.cssText = 'text-align:center;margin-bottom:10px;color:var(--muted);font-weight:700;';
                const totalItems = rows.length || 0;
                infoBar.innerHTML = `Hiển thị <span class="cell5-count-x">${data.length}</span>/${totalItems} mục · ${pages.length} bảng (tối đa ${pageSize}/bảng)`;
                wrap.appendChild(infoBar);

                const container = document.createElement('div');
                container.className = 'grid-centered';
                container.style.alignItems = 'flex-start';
                wrap.appendChild(container);

                const htmlCache = new Map();
                const heightCache = new Map();
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 36; // allow more mounted cards like Cell6.5 for snappier scroll
                // background pre-cache queue: build page HTML off-main when browser is idle
                const preCacheQueue = [];
                let preCacheScheduled = false;
                function runPreCache() {
                    if (preCacheScheduled) return;
                    preCacheScheduled = true;
                    const process = (deadline) => {
                        let count = 0;
                        while (preCacheQueue.length && (deadline ? deadline.timeRemaining() > 0 : count < 6)) {
                            const idx = preCacheQueue.shift();
                            if (!htmlCache.has(idx)) {
                                try {
                                    const p = pages[idx];
                                    if (p) htmlCache.set(idx, buildPageHtml(p, idx));
                                } catch (e) { /* ignore build errors */ }
                            }
                            count++;
                        }
                        if (preCacheQueue.length) {
                            if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                            else setTimeout(() => process(null), 50);
                        } else {
                            preCacheScheduled = false;
                        }
                    };
                    if (window.requestIdleCallback) requestIdleCallback(process, { timeout: 200 });
                    else setTimeout(() => process(null), 50);
                }

                const buildPageHtml = (page, pIdx) => {
                    const start = pIdx * pageSize;
                    const firstDate = page[0] ? page[0].date : '';
                    const lastDate = page[page.length - 1] ? page[page.length - 1].date : '';
                    let table = `<table style="width:100%;"><thead><tr><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>Ngày</th><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>Kết quả</th><th style='text-align:left;padding:6px;border-bottom:1px solid var(--border);'>rule</th></tr></thead><tbody>`;
                    // Use the global row-trash cache when available so k̄ is consistent
                    // across different display orders/views. Fall back to 0 when not ready.
                    try {
                        // build pair counts for rule computation (pairs across dataset)
                        const pairCounts = new Map();
                        try {
                            rows.forEach(r => {
                                try {
                                    const nums = Array.isArray(r.nums) ? r.nums.slice().sort((a, b) => a - b) : [];
                                    for (let i = 0; i < nums.length; i++) {
                                        for (let j = i + 1; j < nums.length; j++) {
                                            const a = nums[i], b = nums[j];
                                            const key = `${a}-${b}`;
                                            pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
                                        }
                                    }
                                } catch (e) { }
                            });
                        } catch (e) { }

                        const computeRuleLocal = (sixNums) => {
                            try {
                                if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                                const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                                if (userNums.length !== 6) return '';
                                const MAX_N = 44;
                                let found = null;
                                for (let n = MAX_N; n >= 1; n--) {
                                    for (const cand of userNums) {
                                        const others = [];
                                        for (let y = 1; y <= 45; y++) {
                                            if (y === cand) continue;
                                            const a = Math.min(cand, y), b = Math.max(cand, y);
                                            const key = `${a}-${b}`;
                                            const c = pairCounts.get(key) || 0;
                                            others.push({ y, c });
                                        }
                                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                        const pick = others.slice(0, n).map(o => o.y);
                                        const otherFive = userNums.filter(x => x !== cand);
                                        const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                        if (!conflict) { found = { n, cand, pick }; break; }
                                    }
                                    if (found) break;
                                }
                                if (!found) {
                                    const cand = userNums[0];
                                    const others = [];
                                    for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = pairCounts.get(key) || 0; others.push({ y, c }); }
                                    others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                    found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                                }
                                const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                                remaining.sort((a, b) => a - b);
                                return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                            } catch (e) { return ''; }
                        };

                        const rowsData = page.map((row) => {
                            const result = (row.nums || []).join(',');
                            const numsHtml = (row.nums || []).map(v => {
                                const inFav = __cell5_5_favSet.has(Number(v));
                                const cls = inFav ? 'pill in-fav' : 'pill';
                                return `<span class='${cls} cell5-pill' style='background:#fffbea;color:#000;font-weight:700;padding:2px 6px;border-radius:6px;display:inline-block;text-align:center;margin-right:4px;font-size:13px;'>${v}</span>`;
                            }).join("");
                            let t = 0;
                            try {
                                if (typeof window.getRowTrashK === 'function') {
                                    const val = window.getRowTrashK(row);
                                    t = Number.isFinite(val) ? val : 0;
                                }
                            } catch (er) { t = 0; }
                            const rule = (Array.isArray(row.nums) && row.nums.length === 6) ? computeRuleLocal(row.nums) : '';
                            return { date: row.date, result, numsHtml, t, rule };
                        });

                        const sumT_forPage = rowsData.reduce((s, it) => s + (Number.isFinite(it.t) ? it.t : 0), 0);
                        const countT_forPage = rowsData.length;
                        const avg = countT_forPage ? (sumT_forPage / countT_forPage) : 0;
                        const avgStr = Number.isFinite(avg) ? avg.toFixed(2) : '0';

                        // update trash popup header (if present). Use the global
                        // window.__lastAvgK if available; otherwise fall back to
                        // the page-local avg for display only. Do NOT overwrite
                        // the global cached value here (we set it once above).
                        try {
                            const tp = document.getElementById('trashPopup');
                            if (tp) {
                                try {
                                    const firstDiv = tp.querySelector('div');
                                    if (firstDiv) {
                                        const existing = firstDiv.querySelector('.avg-k');
                                        if (existing) existing.remove();
                                        // Only show the global average k (k̄) when Cell5.5 is visible.
                                        const cell5 = document.getElementById('cell5_5');
                                        const isCell5Visible = cell5 && window.getComputedStyle(cell5).display !== 'none' && window.getComputedStyle(cell5).visibility !== 'hidden';
                                        if (isCell5Visible) {
                                            const span = document.createElement('span');
                                            span.className = 'avg-k';
                                            span.style.cssText = 'margin-left:12px;color:var(--muted);font-weight:700;';
                                            const displayAvg = (typeof window.__lastAvgK === 'number' && !Number.isNaN(window.__lastAvgK)) ? window.__lastAvgK.toFixed(2) : avgStr;
                                            span.textContent = 'k̄ = ' + displayAvg;
                                            firstDiv.appendChild(span);
                                        }
                                    }
                                } catch (e) { /* ignore DOM errors */ }
                            }
                        } catch (e) { /* ignore avg errors */ }

                        // Render rows using class based on comparison to avg
                        rowsData.forEach((rdat) => {
                            const tooltip = `${rdat.t}`;
                            const compareAvg = (typeof window.__lastAvgK === 'number' && !Number.isNaN(window.__lastAvgK)) ? window.__lastAvgK : avg;
                            const cls = (rdat.t >= compareAvg) ? 'k-cyan' : 'k-yellow';
                            // keep data-k attribute for compatibility but show `rule` column
                            table += `<tr data-result="${rdat.result}" title="${tooltip}" data-k="${rdat.t}"><td style='padding:6px;text-align:left'>${rdat.date}</td><td style='padding:6px;text-align:center'>${rdat.numsHtml}</td><td style='padding:6px;text-align:left;white-space:nowrap;'>${rdat.rule || ''}</td></tr>`;
                        });
                    } catch (e) {
                        // fallback: render without tooltip
                        page.forEach((row, j) => {
                            const result = (row.nums || []).join(',');
                            const numsHtml = (row.nums || []).map(v => {
                                const inFav = __cell5_5_favSet.has(Number(v));
                                const cls = inFav ? 'pill in-fav' : 'pill';
                                return `<span class='${cls} cell5-pill' style='background:#fffbea;color:#000;font-weight:700;padding:2px 6px;border-radius:6px;display:inline-block;text-align:center;margin-right:4px;font-size:13px;'>${v}</span>`;
                            }).join("");
                            // fallback: try to compute k via global helper if available
                            let tFallback = '';
                            try { if (typeof getRowTrashK === 'function') tFallback = getRowTrashK(row); else if (typeof window.getRowTrashK === 'function') tFallback = window.getRowTrashK(row); } catch (e) { tFallback = ''; }
                            const tooltip = tFallback !== '' ? `${tFallback}` : '';
                            // fallback rule (simple): use first number as candidate, rest as remaining, n=1
                            let fallbackRule = '';
                            try {
                                const arr = Array.isArray(row.nums) ? row.nums.map(n => Number(n)).filter(Number.isFinite) : [];
                                if (arr.length === 6) {
                                    const cand = arr[0];
                                    const remaining = arr.slice(1).slice().map(n => Number(n)).filter(Number.isFinite).sort((a, b) => a - b);
                                    fallbackRule = `${cand}>{${remaining.join(',')}}[1]`;
                                }
                            } catch (e) { fallbackRule = ''; }
                            table += `<tr data-result="${result}"${tooltip ? ` title="${tooltip}" data-k="${tFallback}"` : ''}><td style='padding:6px;text-align:left'>${row.date}</td><td style='padding:6px;text-align:center'>${numsHtml}</td><td style='padding:6px;text-align:left;white-space:nowrap;'>${fallbackRule}</td></tr>`;
                        });
                    }
                    table += '</tbody></table>';
                    const header = `<div style="font-weight:700; padding:8px 12px; border-bottom:1px solid var(--border);">Bảng ${pIdx + 1} · ${page.length} mục · ${firstDate} → ${lastDate}</div>`;
                    return `<div>${header}<div style='padding:8px;'>${table}</div></div>`;
                };

                const mount = (card, page, idx) => {
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(idx)) return;
                    const body = card.querySelector('.card-body');
                    let inner = htmlCache.get(idx);
                    if (!inner) {
                        inner = buildPageHtml(page, idx);
                        htmlCache.set(idx, inner);
                    }
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell5_5_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }
                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table (same as Cell6.5)
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights until another record hover updates them.
                                return;
                            });

                            // Ctrl+click a row: switch to cell6_6, paste its 6 numbers, and mark row with yellow border
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    // parse numbers (use existing helper)
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    // clear any previous ctrl-selected rows globally and mark this one
                                    try {
                                        document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected'));
                                    } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    // persist selection so it survives remounts/navigation
                                    try { localStorage.setItem('cell5_5_ctrl_selected', result); } catch (e) { }

                                    // Ensure target section is rendered then navigate to it after a short delay
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            // apply numbers after nav; give a small delay to allow render
                                            setTimeout(() => {
                                                try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { }
                                            }, 220);
                                        }, 200);
                                    } else {
                                        // fallback: apply even if nav button missing
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { /* ignore */ }
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(idx);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const page = pages[idx];
                        if (!page) return;
                        if (entry.isIntersecting) mount(entry.target, page, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // chunked creation
                const total = pages.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, total);
                    for (let i = created; i < end; i++) {
                        const page = pages[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.currentPage = '-1';
                        card.dataset.page = String(i);
                        card.innerHTML = `<div class='card-body' style='min-height:100px;padding:8px;'></div>`;
                        container.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                        // enqueue light-weight pre-build of this page's HTML
                        preCacheQueue.push(i);
                        runPreCache();
                    }
                    created = end;
                    if (created < total) requestAnimationFrame(createChunk);
                };
                createChunk();

                // after structure is ready, scroll viewport to 240px so controls sit under header
                // Use a small timeout + rAF to wait for layout/paint to settle (match Cell6.5 behavior)
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (er) { } }
                    });
                }, 160);
            }

            sortSel.onchange = yearSel.onchange = monthSel.onchange = trashSel.onchange = draw;
            // If rows are already loaded, populate and draw; otherwise draw will handle once data present
            draw();
        }
        // Helpers for labels
        const labelOf = (nums) => nums.map(getCol).join("");
        const diffPositions = (a, b) => { const pos = []; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) pos.push(i); return pos; };

        // Helper: compute per-row trash k (cached). Returns t (largest k for which row remains visible)
        (function setupRowKCache() {
            let cache = null;
            function computeCache() {
                try {
                    const npTable = document.getElementById('numberPickerTable');
                    const poolNodes = npTable ? Array.from(npTable.querySelectorAll('td[data-number]')) : [];
                    let pool = poolNodes.map(n => Number(n.dataset.number)).filter(n => Number.isFinite(n));
                    if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);
                    const poolSet = new Set(pool);
                    const numToRows = new Map();
                    const rowKeyToIndices = new Map();
                    rows.forEach((rr, ridx) => {
                        try {
                            const rk = (rr.nums || []).join(',') + '|' + (rr.date || '');
                            if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                            rowKeyToIndices.get(rk).push(ridx);
                            for (const v of (rr.nums || [])) {
                                const n = Number(v);
                                if (!poolSet.has(n)) continue;
                                if (!numToRows.has(n)) numToRows.set(n, new Set());
                                numToRows.get(n).add(ridx);
                            }
                        } catch (e) { }
                    });

                    const MAX_K_TRASH = 39;
                    const maxK = Math.min(MAX_K_TRASH, Math.max(1, pool.length));
                    const available = new Set(pool);
                    const excludedSet = new Set();
                    const rowFirstExcludedAt = new Array(rows.length).fill(null);

                    for (let k = 1; k <= maxK; k++) {
                        let bestChoice = null;
                        let bestMarginal = Infinity;
                        for (const candidate of Array.from(available)) {
                            const s = numToRows.get(candidate);
                            if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                            let marginal = 0;
                            for (const idx of s) if (!excludedSet.has(idx)) marginal++;
                            if (marginal < bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                        }
                        if (bestChoice === null) break;
                        available.delete(bestChoice);
                        const s2 = numToRows.get(bestChoice);
                        if (s2) for (const idx of s2) excludedSet.add(idx);

                        // mark rows first excluded at this k
                        for (const [rk, idxs] of rowKeyToIndices) {
                            for (const globalIdx of idxs) {
                                if (rowFirstExcludedAt[globalIdx] === null && excludedSet.has(globalIdx)) rowFirstExcludedAt[globalIdx] = k;
                            }
                        }
                    }

                    cache = { rowKeyToIndices, rowFirstExcludedAt, maxK, pool };
                    return cache;
                } catch (e) { cache = null; return null; }
            }

            window.getRowTrashK = function (row) {
                try {
                    if (!cache) computeCache();
                    if (!cache) return 0;
                    const rk = ((row.nums || []).join(',')) + '|' + (row.date || '');
                    const idxs = cache.rowKeyToIndices.get(rk) || [];
                    let firstK = null;
                    for (const gi of idxs) {
                        const v = cache.rowFirstExcludedAt[gi];
                        if (v !== null && v !== undefined) { if (firstK === null || v < firstK) firstK = v; }
                    }
                    let t = cache.maxK;
                    if (firstK !== null) t = Math.max(0, firstK - 1);
                    return t;
                } catch (e) { return 0; }
            };
        })();

        // Cell7: group by label with max diff + consecutive
        function renderCell7() {
            const body = sectionShell("cell7", "Cell7 · Nhóm theo label", "max sai khác & liền kề, chỉ nhóm >=2 kỳ.");
            const controls = document.createElement("div");
            controls.className = "controls";
            const diffSel = document.createElement("select");
            for (let i = 0; i <= 6; i++) { const o = document.createElement("option"); o.value = i; o.textContent = `Sai khác ${i}`; diffSel.appendChild(o); } diffSel.value = "0";
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề"));
            const sortSel = document.createElement("select");
            [["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            controls.append("Sai khác tối đa:", diffSel, consecLabel, "Sắp xếp:", sortSel, recencySel);
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }

                // Tạo key để kiểm tra cache
                const newCacheKey = `${diffSel.value}|${consec.checked}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroups(groupCache);
                    return;
                }

                wrap.innerHTML = "<div class='loader'>Đang xử lý...</div>";

                // Dùng requestIdleCallback để tính toán khi browser rảnh
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => computeAndRender());
                } else {
                    setTimeout(() => computeAndRender(), 0);
                }

                function computeAndRender() {
                    const labelRows = {};
                    rows.forEach(r => { const label = labelOf(r.nums); (labelRows[label] ||= []).push(r); });
                    const labels = Object.keys(labelRows).sort();
                    let groups = [];
                    const canonicalLabel = (lbl) => (lbl || '').split('').sort().join('');

                    // Bước 1: Khi 'Liền kề' được chọn, giữ lại logic hiện tại (lọc theo số vị trí khác nhau
                    // và nhóm lỏng nhất), còn nếu không được chọn thì nhóm theo tổ hợp (combination) của
                    // các ký tự label (sắp xếp không giảm: a<=b<=...<=f) — tức là ghép các label có cùng
                    // multiset ký tự vào một nhóm.
                    if (!consec.checked) {
                        // Non-consec (base-centric) mode: for each label (base) collect
                        // other labels whose multiset distance to the base is <= maxDiff.
                        // This avoids transitive merging (connected-component closure)
                        // which can create overly large groups when labels chain.
                        const maxDiff = parseInt(diffSel.value, 10);
                        const countsMap = new Map();
                        labels.forEach(lbl => {
                            const cnt = [0, 0, 0, 0, 0, 0];
                            for (let i = 0; i < lbl.length; i++) {
                                const d = parseInt(lbl[i], 10);
                                if (Number.isFinite(d) && d >= 1 && d <= 6) cnt[d - 1]++;
                            }
                            countsMap.set(lbl, cnt);
                        });

                        const used = new Set();
                        groups = [];
                        for (let i = 0; i < labels.length; i++) {
                            const base = labels[i];
                            if (used.has(base)) continue;
                            used.add(base);
                            const gLabels = [base];
                            const gRows = [...(labelRows[base] || [])];
                            const ca = countsMap.get(base);
                            for (let j = i + 1; j < labels.length; j++) {
                                const other = labels[j];
                                if (used.has(other)) continue;
                                const cb = countsMap.get(other);
                                let sumAbs = 0;
                                for (let k = 0; k < 6; k++) sumAbs += Math.abs((ca[k] || 0) - (cb[k] || 0));
                                const multisetDist = Math.floor(sumAbs / 2);
                                if (multisetDist <= maxDiff) {
                                    used.add(other);
                                    gLabels.push(other);
                                    gRows.push(...(labelRows[other] || []));
                                }
                            }
                            if (gRows.length >= 2) {
                                gLabels.sort();
                                groups.push({ base: canonicalLabel(gLabels[0]), labels: gLabels.slice(), rows: gRows });
                            }
                        }
                    } else {
                        const used = new Set();
                        groups = [];
                        labels.forEach(base => {
                            if (used.has(base)) return;
                            used.add(base);
                            const gLabels = [base];
                            let gRows = [...labelRows[base]];

                            for (let j = 0; j < labels.length; j++) {
                                const other = labels[j];
                                if (used.has(other)) continue;
                                const pos = diffPositions(base, other);
                                // Chỉ kiểm tra số vị trí khác nhau, không kiểm tra liền kề
                                if (pos.length > parseInt(diffSel.value, 10)) continue;
                                used.add(other); gLabels.push(other); gRows.push(...labelRows[other]);
                            }
                            if (gRows.length >= 2) groups.push({ base: base, labels: gLabels, rows: gRows });
                        });
                    }

                    // Bước 2: Nếu tick "Liền kề", lọc các labels không thoả điều kiện trong mỗi nhóm
                    if (consec.checked) {
                        groups = groups.map(g => {
                            // Giữ lại chỉ những labels thoả điều kiện liền kề với base
                            const filteredLabels = g.labels.filter(label => {
                                const pos = diffPositions(g.base, label);
                                // Nếu chỉ khác ≤1 vị trí thì OK (không cần kiểm tra liền kề)
                                if (pos.length <= 1) return true;
                                // Nếu khác ≥2 vị trí, kiểm tra liền kề
                                return pos.every((p, i) => i === 0 || p - pos[i - 1] === 1);
                            });
                            // Tính lại rows dựa trên filtered labels
                            const filteredRows = [];
                            filteredLabels.forEach(label => {
                                filteredRows.push(...labelRows[label]);
                            });
                            return { base: g.base, labels: filteredLabels, rows: filteredRows };
                        }).filter(g => g.rows.length >= 2); // Chỉ giữ nhóm ≥2 kỳ
                    }

                    // Ensure rows inside each group are sorted by date (old -> new)
                    const parseDateDMY = (s) => {
                        if (!s || typeof s !== 'string') return 0;
                        const m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                        if (!m) return 0;
                        const d = Number(m[1]), mo = Number(m[2]) - 1, y = Number(m[3]);
                        return new Date(y, mo, d).getTime();
                    };
                    groups.forEach(g => {
                        g.rows.sort((a, b) => (parseDateDMY(a.date) || 0) - (parseDateDMY(b.date) || 0));
                    });

                    groups.sort((a, b) => b.rows.length - a.rows.length);
                    groupCache = groups;
                    cacheKey = newCacheKey;
                    renderGroups(groups);
                    // Ensure controls sit under header after render by scrolling
                    try { setTimeout(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }, 160); } catch (e) { }
                }
            }

            function renderGroups(groups) {
                // Apply sorting based on sortSel value
                if (sortSel.value === 'count_desc') groups.sort((a, b) => {
                    const d = b.rows.length - a.rows.length;
                    return d !== 0 ? d : compareKey(a.base, b.base);
                });
                else if (sortSel.value === 'count_asc') groups.sort((a, b) => {
                    const d = a.rows.length - b.rows.length;
                    return d !== 0 ? d : compareKey(a.base, b.base);
                });
                else if (sortSel.value === 'value_asc') groups.sort((a, b) => compareKey(a.base, b.base));
                else if (sortSel.value === 'value_desc') groups.sort((a, b) => compareKey(b.base, a.base));

                // Summary + grid container
                wrap.innerHTML = `<div class='muted'>${groups.length} nhóm · ${groups.reduce((s, g) => s + g.rows.length, 0)} kỳ</div>` +
                    `<div class='grid-centered' id='labelGroupGrid'></div>`;
                const grid = wrap.querySelector('#labelGroupGrid');

                // Caches for smoother back-scroll (per-page keys `${idx}|${page}`)
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = []; // maintain recency for limiting cache
                const MAX_CACHE = 160;
                const cardRefs = new Map(); // idx -> element
                const mountedSet = new Set(); // idx currently mounted
                const MAX_MOUNTED = 36; // limit live DOM to reduce churn

                const setCache = (key, html) => {
                    htmlCache.set(key, html);
                    lruQueue.push(key);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        const rmIdx = String(rm).split('|')[0];
                        if (!mountedSet.has(Number(rmIdx))) htmlCache.delete(rm);
                    }
                };

                const mount = (card, g, idx) => {
                    const body = card.querySelector('.card-body');
                    const pageSizeRows = 15;
                    const totalPages = Math.max(1, Math.ceil(g.rows.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    // if already mounted and the mounted page matches desired page, skip
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}`;
                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const start = page * pageSizeRows;
                        const rowsToUse = (typeof recencySel !== 'undefined' && recencySel.value === 'desc') ? g.rows.slice().reverse() : g.rows.slice();
                        const slice = rowsToUse.slice(start, start + pageSizeRows);
                        inner = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        // Build pairCounts & computeRule for rule column (same as Cell5.5 / Cell6.5)
                        const __c66_pairCounts = new Map();
                        try {
                            rows.forEach(rr => {
                                try {
                                    const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                                    for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                        const key = `${ns[i]}-${ns[j]}`;
                                        __c66_pairCounts.set(key, (__c66_pairCounts.get(key) || 0) + 1);
                                    }
                                } catch (e) { }
                            });
                        } catch (e) { }
                        const __c66_computeRule = (sixNums) => {
                            try {
                                if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                                const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                                if (userNums.length !== 6) return '';
                                const MAX_N = 44;
                                let found = null;
                                for (let n = MAX_N; n >= 1; n--) {
                                    for (const cand of userNums) {
                                        const others = [];
                                        for (let y = 1; y <= 45; y++) {
                                            if (y === cand) continue;
                                            const a = Math.min(cand, y), b = Math.max(cand, y);
                                            const key = `${a}-${b}`;
                                            const c = __c66_pairCounts.get(key) || 0;
                                            others.push({ y, c });
                                        }
                                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                        const pick = others.slice(0, n).map(o => o.y);
                                        const otherFive = userNums.filter(x => x !== cand);
                                        const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                        if (!conflict) { found = { n, cand, pick }; break; }
                                    }
                                    if (found) break;
                                }
                                if (!found) {
                                    const cand = userNums[0];
                                    const others = [];
                                    for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = __c66_pairCounts.get(key) || 0; others.push({ y, c }); }
                                    others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                    found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                                }
                                const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                                remaining.sort((a, b) => a - b);
                                return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                            } catch (e) { return ''; }
                        };
                        inner += "<table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                        slice.forEach(r => {
                            const label = labelOf(r.nums);
                            let labelHtml = "";
                            if (!consec.checked) {
                                const base = String(g.base || "");
                                const baseCounts = {};
                                for (const c of base) baseCounts[c] = (baseCounts[c] || 0) + 1;
                                const counts = Object.assign({}, baseCounts);
                                labelHtml = label.split("").map(ch => {
                                    if (counts[ch] && counts[ch] > 0) { counts[ch]--; return `<span>${ch}</span>`; }
                                    return `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>`;
                                }).join(" ");
                            } else {
                                labelHtml = label.split("").map((ch, i) => ch !== g.base[i]
                                    ? `<span style='background:#ff4444;color:white;padding:2px 6px;border-radius:4px;font-weight:700'>${ch}</span>`
                                    : `<span>${ch}</span>`).join(" ");
                            }
                            const nums = r.nums.map(v => `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            const ruleHtml = (Array.isArray(r.nums) && r.nums.length === 6) ? __c66_computeRule(r.nums) : '';
                            inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                        });
                        inner += "</tbody></table>";
                        if (g.rows.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${g.rows.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner);
                    }
                    body.style.minHeight = "";
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell7
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell7_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // attach hover + Ctrl+click handler to tbody so Ctrl+click will mark + apply to Cell6.6
                    (function attachRowHoverAndCtrlClick() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;
                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });
                            _tbody.addEventListener('mouseout', () => { return; });

                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell7_ctrl_selected', result); } catch (e) { }

                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220);
                                        }, 200);
                                    } else {
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // attach pagination handlers
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, g, idx);
                    }));

                    // attach page input handlers
                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    // record which page is currently rendered inside this card
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    // Measure and cache height after first mount
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = ""; // free DOM when offscreen
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    // Unmount farthest cards first
                    const vh = window.innerHeight;
                    const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        const g = groups[idx];
                        if (!g) return;
                        if (entry.isIntersecting) {
                            mount(entry.target, g, idx);
                        } else {
                            unmount(entry.target, idx);
                        }
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Chunked creation of cards to avoid main-thread spikes
                const totalGroups = groups.length;
                let created = 0;
                const chunkSize = 6;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, groups.length);
                    for (let i = created; i < end; i++) {
                        const g = groups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // show rank/total to the left of the count badge
                        card.innerHTML = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>Base ${g.base}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${i + 1}/${totalGroups}</span>` +
                            `<span class='badge'>${g.rows.length} kỳ</span>` +
                            `</div>` +
                            `</div><div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < groups.length) requestAnimationFrame(createChunk);
                };
                createChunk();
                // After rendering group cards, ensure page scrolls to 240px
                // Use a small delay to allow layout to settle before scrolling
                try { setTimeout(() => { window.scrollTo({ top: 240, behavior: 'smooth' }); }, 50); } catch (e) { try { setTimeout(() => { window.scrollTo(0, 240); }, 50); } catch (er) { /* ignore */ } }
            }

            // Dùng debounce để tránh tính toán quá tần suất
            const debouncedGroup = createDebounce(group, 300);
            diffSel.onchange = consec.onchange = debouncedGroup;
            recencySel.onchange = debouncedGroup;
            sortSel.onchange = () => groupCache && renderGroups(groupCache);
            group();
        }

        // Helper: parse a comma/space separated string into six valid numbers (1-45), or return null
        function parseSixNumbersFromString(s) {
            if (!s || typeof s !== 'string') return null;
            // split on any non-digit characters
            const parts = s.split(/[^0-9]+/).map(p => p.trim()).filter(Boolean);
            if (parts.length !== 6) return null;
            const nums = parts.map(p => parseInt(p, 10));
            if (nums.some(n => !Number.isFinite(n) || n < 1 || n > 45)) return null;
            const uniq = new Set(nums);
            if (uniq.size !== 6) return null;
            return nums;
        }

        // Helper: apply an array of 6 numbers into the cell6_6 inputs (if present)
        function applySixToCell6_6(nums) {
            try {
                if (!Array.isArray(nums) || nums.length !== 6) return false;
                const sec = document.getElementById('cell6_6');
                if (!sec) return false;
                const inputs = Array.from(sec.querySelectorAll('.drag-input-container input'));
                if (!inputs || inputs.length < 6) return false;
                for (let i = 0; i < 6; i++) {
                    inputs[i].value = String(nums[i]);
                    inputs[i].dispatchEvent(new Event('input'));
                }
                // small visual feedback: pulse the first input container
                try {
                    const cont = inputs[0].parentElement;
                    if (cont) {
                        cont.animate([{ boxShadow: '0 0 0 6px rgba(56,239,125,0.18)' }, { boxShadow: '0 0 0 0 rgba(56,239,125,0)' }], { duration: 450 });
                    }
                } catch (e) { }
                return true;
            } catch (e) { return false; }
        }

        // Delegated dblclick behavior: read clipboard and, when a place-box or a cell6_6 input is double-clicked,
        // parse a 6-number string and apply it to the Cell6.6 inputs. Use document-level delegation so listeners
        // work regardless of render order.
        (function setupClipboardDoubleClickHandlersDelegated() {
            try {
                document.addEventListener('dblclick', async (ev) => {
                    // If the dblclick happened inside the number picker popup, let the
                    // popup-local handlers handle it (they run on the target). The
                    // global handler runs in capture mode and may cause unwanted
                    // focus/scroll behavior; ignore events originating inside the popup.
                    try {
                        const popup = document.getElementById('numberPickerPopup');
                        if (popup && popup.contains(ev.target)) return;
                    } catch (e) { }

                    // Skip dblclick inside Cell11 — Cell11 has its own handler
                    try { if (ev.target.closest('#cell11')) return; } catch (e) { }

                    // Only handle dblclick when user targets a place-box or one of the six input containers
                    const box = ev.target.closest('.place-box');
                    const inputContainer = ev.target.closest('.drag-input-container');
                    if (!box && !inputContainer) return;

                    let text = null;
                    // Try clipboard API first
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            text = await navigator.clipboard.readText();
                        }
                    } catch (err) {
                        // ignore and fall back to prompt
                        text = null;
                    }

                    // If clipboard API not available or returned empty, fall back to prompt
                    if (!text || String(text).trim() === '') {
                        try {
                            const promptStr = 'Paste 6 numbers (comma or space separated), e.g. 29,3,35,24,18,30';
                            const res = window.prompt(promptStr, '');
                            if (res && String(res).trim() !== '') text = res.trim();
                        } catch (e) { text = null; }
                    }

                    if (!text) return;

                    try {
                        const nums = parseSixNumbersFromString(text);
                        const targetElem = box || inputContainer || ev.target;
                        if (nums) {
                            applySixToCell6_6(nums);
                            try { if (targetElem) targetElem.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (e) { }
                        } else {
                            try { if (targetElem) targetElem.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (e) { }
                        }
                    } catch (err) { console.warn('clipboard parse/apply failed', err); }
                }, true);
            } catch (e) { }
        })();

        // Cell6.6: Mổ pattern — accept exactly 6 distinct numbers and list all combinations
        function renderCell6_6() {
            const body = sectionShell("cell6_6", "Cell6.6 · Mổ pattern", "Nhập đủ 6 số (1-45) và chọn kích thước tổ hợp để liệt kê.");
            const controls = document.createElement("div"); controls.className = "controls";

            // six fixed number inputs with per-input +/- buttons and global left/right navigation
            const rawInputs = Array.from({ length: 6 }, (_, i) => {
                const inp = document.createElement('input');
                inp.type = 'number'; inp.min = 1; inp.max = 45; inp.placeholder = `#${i + 1}`;
                inp.style.width = '70px'; inp.style.boxSizing = 'border-box';
                return inp;
            });

            // create select controls
            const combSel = document.createElement('select');[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = `Bộ ${v}`; combSel.appendChild(o); }); combSel.value = '2';
            const sortSel = document.createElement('select');[["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            // recency selector (Mới → Cũ / Cũ → Mới) — mirror Cell6.5 behavior
            const recencySel = document.createElement('select');
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';

            // consecutive & order toggles (same behavior as Cell6/Cell6.5)
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;

            // (no global nav buttons — per-input arrow buttons and keyboard arrows remain)

            const inputs = [];
            // create per-input container with up/down buttons (same behavior as Cell9)
            rawInputs.forEach((inp, idx) => {
                const container = document.createElement('div');
                container.className = 'drag-input-container';
                container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;vertical-align:middle;';
                container.draggable = false;

                // small left-side grip (visual) — kept but pointer-events managed by updateDraggable
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // reserve space on the right for buttons to match Cell9
                inp.style.position = 'relative'; inp.style.zIndex = '1'; inp.style.paddingRight = '40px'; inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                // clamp helper for numeric input
                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    draw();
                });

                btnGroup.appendChild(up); btnGroup.appendChild(down);
                container.appendChild(inp); container.appendChild(btnGroup); container.appendChild(dragHandle);
                container.dataset.index = idx;

                // visual/state update for draggable container
                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                // keyboard left/right move (wrap)
                inp.addEventListener('keydown', (ev) => {
                    if (ev.key === 'ArrowLeft') {
                        ev.preventDefault();
                        const prev = (idx - 1 + 6) % 6; rawInputs[prev].focus();
                    } else if (ev.key === 'ArrowRight') {
                        ev.preventDefault();
                        const next = (idx + 1) % 6; rawInputs[next].focus();
                    }
                });

                inp.addEventListener('input', () => { clampForNumber(); updateDraggable(); });
                inp.addEventListener('change', () => { clampForNumber(); updateDraggable(); });
                updateDraggable();

                // drag/drop: allow dragging this input out to clear it, and swapping values with another input
                container.__dropHandled = false;
                container.__dragging = false;

                container.addEventListener('dragstart', (e) => {
                    container.__dragging = true;
                    container.__dropHandled = false;
                    container.style.opacity = '0.5';
                    try { window.__draggingDynamic = { type: 'cell6_6', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                    try { e.dataTransfer.setData('text/plain', String(inp.value ?? '')); } catch (er) { }
                    try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                });

                container.addEventListener('dragend', (e) => {
                    container.style.opacity = '';
                    try { window.__draggingDynamic = null; } catch (err) { }
                    if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                        draw();
                    }
                    container.__dragging = false;
                    container.__dropHandled = false;
                });

                container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(56, 239, 125, 0.04)'; });
                container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                container.addEventListener('drop', (e) => {
                    e.preventDefault(); container.style.backgroundColor = ''; container.__dropHandled = true;
                    const txt = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');
                    let value = null;
                    // If dragging from another dynamic input, swap values instead of replacing
                    try {
                        if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                            const srcInput = window.__draggingDynamic.input;
                            const srcVal = String(srcInput.value ?? '');
                            const tgtVal = String(inp.value ?? '');
                            // perform swap
                            srcInput.value = tgtVal;
                            srcInput.dispatchEvent(new Event('input'));
                            inp.value = srcVal;
                            inp.dispatchEvent(new Event('input'));
                            // mark both containers as handled to avoid clearing on dragend
                            try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                            container.__dropHandled = true;
                            try { window.__draggingDynamic = null; } catch (err) { }
                            draw();
                            return;
                        }
                    } catch (err) { }

                    if (placeIndexData) {
                        const idx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                    } else if (placeSetData) {
                        // If full place-set (6 values) is dropped, apply the entire 6-number state to the cell
                        try {
                            const arr = JSON.parse(placeSetData);
                            if (Array.isArray(arr) && arr.length === 6) {
                                try {
                                    // write all six inputs
                                    for (let k = 0; k < 6; k++) {
                                        const v = arr[k];
                                        if (v === null || v === undefined || String(v).trim() === '') {
                                            inputs[k].value = '';
                                        } else {
                                            let nn = parseInt(String(v).trim(), 10);
                                            if (!Number.isFinite(nn)) nn = '';
                                            else {
                                                if (nn < 1) nn = 1;
                                                if (nn > 45) nn = 45;
                                            }
                                            inputs[k].value = nn === '' ? '' : String(nn);
                                        }
                                        inputs[k].dispatchEvent(new Event('input'));
                                    }
                                    // mark all containers handled so they won't clear on dragend
                                    try { inputs.forEach(i => i.parentElement.__dropHandled = true); } catch (e) { }
                                    try { window.__draggingDynamic = null; } catch (e) { }
                                    draw();
                                    return;
                                } catch (err) { }
                            }
                            // fallback: pick first non-empty value in the set for this single input
                            if (Array.isArray(arr) && arr.length) {
                                for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } }
                            }
                        } catch (err) { }
                    } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                        value = txt;
                    } else if (labelData) { value = labelData; }

                    if (value !== null && value !== undefined) {
                        let n = parseInt(String(value).trim(), 10);
                        if (Number.isFinite(n)) {
                            if (n < 1) n = 1;
                            if (n > 45) n = 45;
                            inp.value = String(n);
                            inp.dispatchEvent(new Event('input'));
                            draw();
                        }
                    }
                });

                inputs.push(inp);
                controls.append(container);
            });

            // trash toggle for Cell6.6 — kept in sync with Cell6.5
            const trashSel = document.createElement('button');
            try { trashSel.id = 'cell6_6_trashSel'; trashSel.className = 'trash-mode trash-toggle'; trashSel.style.cssText = 'width:100px;margin-left:4px;height:28px;vertical-align:middle;'; } catch (e) { }
            trashSel.type = 'button';
            trashSel.value = 'include';
            trashSel.textContent = 'include';
            trashSel.title = 'Click to toggle trash mode (include/exclude)';
            trashSel.addEventListener('click', () => {
                try {
                    trashSel.value = (trashSel.value === 'include') ? 'exclude' : 'include';
                    trashSel.textContent = trashSel.value;
                    // sync other selector if present
                    try { const other = document.getElementById('cell6_5_trashSel'); if (other) { other.value = trashSel.value; if (other.textContent !== undefined) other.textContent = trashSel.value; } } catch (e) { }
                    try { trashSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { draw(); } catch (e) { }
                } catch (e) { }
            });

            // keep this selector in sync when popup or Cell6.5 updates trash
            try {
                document.addEventListener('trashchange', () => {
                    try {
                        const other = document.getElementById('cell6_5_trashSel');
                        if (other && trashSel && trashSel.value !== other.value) trashSel.value = other.value;
                    } catch (e) { }
                    try { draw(); } catch (e) { }
                });
            } catch (e) { }

            // Fav toggle (mirror Cell6.5): include|exclude
            const favSel = document.createElement('button');
            try { favSel.id = 'cell6_6_favSel'; favSel.className = 'fav-mode fav-toggle'; } catch (e) { }
            favSel.type = 'button';
            favSel.value = 'exclude';
            favSel.textContent = 'exclude';
            favSel.title = 'Click to toggle fav mode (include/exclude)';
            favSel.style.padding = '6px 10px';
            favSel.style.marginLeft = '6px';
            favSel.addEventListener('click', () => {
                try {
                    favSel.value = (favSel.value === 'include') ? 'exclude' : 'include';
                    favSel.textContent = favSel.value;
                    try { favSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { draw(); } catch (e) { }
                } catch (e) { }
            });

            // Ensure Cell6.6 redraws when the fav popup changes (only add listener once)
            try {
                const secEl = document.getElementById('cell6_6');
                if (secEl && !secEl.__favListenerAdded) {
                    secEl.__favListenerAdded = true;
                    document.addEventListener('favchange', function () {
                        try {
                            const cur = document.getElementById('cell6_6_favSel');
                            const other = document.getElementById('cell6_5_favSel');
                            const isInclude = (cur && String(cur.value) === 'include') || (other && String(other.value) === 'include');
                            if (isInclude) {
                                try { draw(); } catch (err) { /* ignore */ }
                            }
                        } catch (e) { }
                    });
                }
            } catch (e) { /* ignore */ }

            controls.append(combSel, consecLabel, orderLabel, 'Trash:', trashSel, 'Fav:', favSel, sortSel, recencySel);
            body.appendChild(controls);

            const wrap = document.createElement('div'); wrap.className = 'card card-inner'; body.appendChild(wrap);

            function draw() {
                if (!rows || !rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                const vals = inputs.map(i => { const v = String(i.value ?? '').trim(); return v === '' ? NaN : parseInt(v, 10); });
                if (vals.some(v => !Number.isFinite(v))) { wrap.innerHTML = "<div class='muted'>Vui lòng nhập đủ 6 số hợp lệ</div>"; return; }
                const uniq = new Set(vals);
                if (uniq.size !== 6) { wrap.innerHTML = "<div class='error'>Các số phải khác nhau</div>"; return; }

                const m = parseInt(combSel.value, 10) || 1;

                // generate all combinations from the user-provided 6 numbers
                const combos = kCombinations(vals, m).map(c => c.slice().sort((a, b) => a - b));

                // compute global counts for all combos of size m across rows
                // respect consecutive/order toggles when counting
                const globalCounts = Object.create(null);
                const consecChecked = !!consec.checked;
                const orderChecked = !!order.checked;
                // read trash mode from Cell6.5 (if present) so Cell6.6 mirrors its behavior
                // If Cell6.5 selector is missing (e.g., not rendered), fall back to this cell's own selector
                let trashModeEl = null;
                try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                if (!trashModeEl) trashModeEl = trashSel;
                const trashMode = (trashModeEl && (trashModeEl.value || trashSel && trashSel.value)) ? (trashModeEl.value || trashSel.value) : 'include';
                const trashedArr = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                const trashedSet = new Set((trashedArr || []).map(n => Number(n)));
                rows.forEach(r => {
                    if (!r.nums || !Array.isArray(r.nums)) return;
                    if (trashMode === 'exclude') {
                        // skip any row containing a trashed number
                        let skip = false;
                        for (const nn of r.nums) { if (trashedSet.has(Number(nn))) { skip = true; break; } }
                        if (skip) return;
                    }
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            globalCounts[key] = (globalCounts[key] || 0) + 1;
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m).map(c => c.slice().sort((a, b) => a - b));
                        combosRow.forEach(c => { const k = c.join('-'); globalCounts[k] = (globalCounts[k] || 0) + 1; });
                    }
                });

                // build results for user's combos
                const results = combos.map(c => {
                    const key = c.join('-');
                    return { key, combo: c, cnt: globalCounts[key] || 0 };
                });

                // build ranking map over all global combos (use same baseline sort logic as other cells)
                const globalArr = Object.keys(globalCounts).map(k => ({ k, cnt: globalCounts[k] }));
                const baselineSort = sortSel.value;
                if (baselineSort === "value_asc") globalArr.sort((a, b) => compareKey(a.k, b.k));
                else if (baselineSort === "value_desc") globalArr.sort((a, b) => compareKey(b.k, a.k));
                else if (baselineSort === "count_asc") globalArr.sort((a, b) => a.cnt - b.cnt);
                else globalArr.sort((a, b) => b.cnt - a.cnt);
                const rankMap = Object.create(null);
                globalArr.forEach((it, idx) => { rankMap[it.k] = idx + 1; });

                // apply requested sort
                if (sortSel.value === 'value_asc') results.sort((a, b) => compareKey(a.key, b.key));
                else if (sortSel.value === 'value_desc') results.sort((a, b) => compareKey(b.key, a.key));
                else if (sortSel.value === 'count_asc') results.sort((a, b) => a.cnt - b.cnt);
                else results.sort((a, b) => b.cnt - a.cnt);

                // build groups for only the user's combos (map key -> rows array)
                const userKeys = new Set(results.map(r => r.key));
                const groups = new Map();
                rows.forEach(r => {
                    if (consecChecked) {
                        for (let i = 0; i <= r.nums.length - m; i++) {
                            const slice = r.nums.slice(i, i + m).slice();
                            const key = orderChecked ? slice.join('-') : slice.slice().sort((a, b) => a - b).join('-');
                            if (!userKeys.has(key)) continue;
                            if (!groups.has(key)) groups.set(key, []);
                            groups.get(key).push(r);
                        }
                    } else {
                        const combosRow = kCombinations(r.nums, m);
                        combosRow.forEach(c => {
                            const values = c.slice().sort((a, b) => a - b);
                            const k = values.join('-');
                            if (!userKeys.has(k)) return;
                            if (!groups.has(k)) groups.set(k, []);
                            groups.get(k).push(r);
                        });
                    }
                });
                // If trashMode is 'exclude', filter the groups' rows to remove trashed-number rows
                if (trashMode === 'exclude' && trashedSet && trashedSet.size) {
                    for (const [k, list] of groups.entries()) {
                        const filtered = (list || []).filter(r => {
                            if (!r.nums || !Array.isArray(r.nums)) return false;
                            for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                            return true;
                        });
                        groups.set(k, filtered);
                    }
                }

                // build array of [key, list] for user's combos
                // include combos with no records (empty list) so every user combo is shown
                let arrGroups = results.map(r => [r.key, groups.get(r.key) || []]);

                // Apply fav-include filter when requested: mirror Cell6.5 behavior
                try {
                    const favEl = document.getElementById('cell6_6_favSel');
                    if (typeof favEl !== 'undefined' && favEl && String(favEl.value) === 'include') {
                        let favs = [];
                        try {
                            if (window.getFavItems && typeof window.getFavItems === 'function') {
                                favs = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                            } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                                favs = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                            } else {
                                const f = document.getElementById('favPopup');
                                if (f) {
                                    favs = Array.from(f.querySelectorAll('td.fav-number')).map(td => {
                                        try {
                                            const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                            if (dn) return Number(dn);
                                            const txt = String(td.textContent || '');
                                            const m = txt.match(/(\d+)/);
                                            return m ? Number(m[1]) : null;
                                        } catch (e) { return null; }
                                    }).filter(n => Number.isFinite(n));
                                }
                            }
                        } catch (e) { favs = []; }
                        if (favs && favs.length) {
                            const fset = new Set((favs || []).map(n => Number(n)));
                            // read filter operator/count from favPopup controls (fallbacks provided)
                            let op = '>=';
                            let req = 1;
                            try {
                                const fpop = document.getElementById('favPopup');
                                if (fpop) {
                                    const opEl = fpop.querySelector('#favFilterOp');
                                    const cntEl = fpop.querySelector('#favFilterCount');
                                    if (opEl && ['>=', '<=', '='].includes(opEl.value)) op = opEl.value;
                                    if (cntEl) {
                                        const v = Number(cntEl.value);
                                        if (Number.isFinite(v)) req = Math.max(0, Math.min(6, Math.floor(v)));
                                    }
                                }
                            } catch (e) { }

                            arrGroups = arrGroups.filter(([key, list]) => {
                                try {
                                    const nums = key.split('-').map(Number);
                                    let matchCount = 0;
                                    for (const n of nums) if (fset.has(Number(n))) matchCount++;
                                    if (op === '>=') return matchCount >= req;
                                    if (op === '=') return matchCount === req;
                                    if (op === '<=') return matchCount <= req;
                                    return matchCount >= req;
                                } catch (e) { return false; }
                            });
                        }
                    }
                } catch (e) { /* ignore fav filter errors */ }

                // build baseline over all global combos for ranking (same baseline sort logic)
                const globalArrFull = Object.keys(globalCounts).map(k => [k, []]);
                // populate counts into a map for baseline ordering
                const baselineArrAll = Object.keys(globalCounts).map(k => [k, new Array(globalCounts[k])]);
                // sort baseline keys according to baselineSort (reuse earlier `baselineSort`)
                if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => globalCounts[a[0]] - globalCounts[b[0]]);
                else baselineArrAll.sort((a, b) => globalCounts[b[0]] - globalCounts[a[0]]);

                // sort displayed groups according to user's sortSel
                if (sortSel.value === 'value_asc') arrGroups.sort((a, b) => compareKey(a[0], b[0]));
                else if (sortSel.value === 'value_desc') arrGroups.sort((a, b) => compareKey(b[0], a[0]));
                else if (sortSel.value === 'count_asc') arrGroups.sort((a, b) => a[1].length - b[1].length);
                else arrGroups.sort((a, b) => b[1].length - a[1].length);

                // render cards similar to Cell6: one card per combo showing rows
                // Create container and defer building full table HTML until a card is visible
                wrap.innerHTML = `<div class='muted'>${arrGroups.length} tổ hợp · hiển thị tối đa ${arrGroups.length} bảng</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');

                // caches and mount management
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}|${recency}`)
                const heightCache = new Map();
                const lruQueue = [];
                const MAX_CACHE = 160;
                const mountedSet = new Set();
                const cardRefs = new Map();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idxForCache) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idxForCache)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arrGroups[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    let displayList = (list && list.slice) ? list.slice() : [];
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }
                    const totalPages = Math.max(1, Math.ceil(displayList.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        const baselineTotal = baselineArrAll && baselineArrAll.length ? baselineArrAll.length : arrGroups.length;
                        const idxInBaseline = baselineArrAll ? baselineArrAll.findIndex(([k]) => k === key) : -1;
                        // By default show baseline ranking (position within all combos)
                        // baseline arrays were computed from `globalCounts` which already
                        // respect trashMode (include/exclude). Use those values so that
                        // when trash mode is 'exclude' the sample space and ranks shrink
                        // accordingly.
                        let rankDisplay = `${idx + 1}/${arrGroups.length}`;
                        let occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                        try {
                            if (idxInBaseline >= 0) {
                                rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                            }
                            // Prefer showing the globalCounts-based occurrence which
                            // already accounts for any excluded trashed rows.
                            occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                        } catch (e) {
                            if (idxInBaseline >= 0) {
                                rankDisplay = `${idxInBaseline + 1}/${baselineTotal}`;
                                occDisplay = `${globalCounts && globalCounts[key] ? globalCounts[key] : list.length} kỳ`;
                            }
                        }

                        inner = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                            `<span class='badge'>${occDisplay}</span>` +
                            `</div>` +
                            `</div>`;

                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;

                        inner += `<table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>`;
                        if (slice.length === 0) {
                            inner += `<tr><td colspan='4' class='muted'>Không có kết quả</td></tr>`;
                        } else {
                            // Build pairCounts & computeRule for rule column (same as Cell5.5 / Cell6.5)
                            const __c66b_pairCounts = new Map();
                            try {
                                rows.forEach(rr => {
                                    try {
                                        const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                                        for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                            const key2 = `${ns[i]}-${ns[j]}`;
                                            __c66b_pairCounts.set(key2, (__c66b_pairCounts.get(key2) || 0) + 1);
                                        }
                                    } catch (e) { }
                                });
                            } catch (e) { }
                            const __c66b_computeRule = (sixNums) => {
                                try {
                                    if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                                    const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                                    if (userNums.length !== 6) return '';
                                    const MAX_N = 44;
                                    let found = null;
                                    for (let n = MAX_N; n >= 1; n--) {
                                        for (const cand of userNums) {
                                            const others = [];
                                            for (let y = 1; y <= 45; y++) {
                                                if (y === cand) continue;
                                                const a = Math.min(cand, y), b = Math.max(cand, y);
                                                const key2 = `${a}-${b}`;
                                                const c = __c66b_pairCounts.get(key2) || 0;
                                                others.push({ y, c });
                                            }
                                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                            const pick = others.slice(0, n).map(o => o.y);
                                            const otherFive = userNums.filter(x => x !== cand);
                                            const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                            if (!conflict) { found = { n, cand, pick }; break; }
                                        }
                                        if (found) break;
                                    }
                                    if (!found) {
                                        const cand = userNums[0];
                                        const others = [];
                                        for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key2 = `${a}-${b}`; const c = __c66b_pairCounts.get(key2) || 0; others.push({ y, c }); }
                                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                        found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                                    }
                                    const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                                    remaining.sort((a, b) => a - b);
                                    return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                                } catch (e) { return ''; }
                            };

                            // Build a stable mapping from row key -> global indices so we can
                            // map page copies back to canonical `rows` indices for k computation
                            const rowKeyToIndices = new Map();
                            try {
                                rows.forEach((rr, gi) => {
                                    try {
                                        const rk = (rr.nums && Array.isArray(rr.nums) ? rr.nums.join(',') : '') + '|' + (rr.date || '');
                                        if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                                        rowKeyToIndices.get(rk).push(gi);
                                    } catch (err) { }
                                });
                            } catch (err) { }

                            // Build pool of numbers (respect numberPickerTable if present)
                            let pool = [];
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                if (npTable) {
                                    const tds = Array.from(npTable.querySelectorAll('td[data-number]'));
                                    pool = tds.map(td => Number(td.dataset.number)).filter(n => Number.isFinite(n));
                                }
                            } catch (e) { }
                            if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);

                            // Greedy simulation: record first-k when each global row becomes excluded
                            const rowFirstExcludedAt = new Array(rows.length).fill(null);
                            const chosen = new Set();
                            const maxK = pool.length;
                            for (let kIdx = 1; kIdx <= maxK; kIdx++) {
                                let best = null; let bestNew = Infinity;
                                for (const cand of pool) {
                                    if (chosen.has(cand)) continue;
                                    let newExcl = 0;
                                    for (let gi = 0; gi < rows.length; gi++) {
                                        if (rowFirstExcludedAt[gi] !== null) continue;
                                        const rr = rows[gi];
                                        if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                        for (const nn of rr.nums) { if (Number(nn) === cand) { newExcl++; break; } }
                                    }
                                    if (newExcl < bestNew) { bestNew = newExcl; best = cand; }
                                }
                                if (best === null) break;
                                for (let gi = 0; gi < rows.length; gi++) {
                                    if (rowFirstExcludedAt[gi] !== null) continue;
                                    const rr = rows[gi];
                                    if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                    for (const nn of rr.nums) { if (Number(nn) === best) { rowFirstExcludedAt[gi] = kIdx; break; } }
                                }
                                chosen.add(best);
                            }

                            // Now emit table rows, mapping each page-copy `r` to a global index
                            slice.forEach(r => {
                                const orderedSeqForHighlight = (consecChecked && orderChecked) ? key.split('-').map(Number) : Array.from(setValues);
                                const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, m, consecChecked, orderedSeqForHighlight, orderChecked);
                                const labelHtml = renderHighlightedLabel(r.label, positions);
                                const ruleHtml = (Array.isArray(r.nums) && r.nums.length === 6) ? __c66b_computeRule(r.nums) : '';

                                // determine t (largest k for which the record remains visible)
                                let t = pool.length;
                                try {
                                    const rk = (r.nums && Array.isArray(r.nums) ? r.nums.join(',') : '') + '|' + (r.date || '');
                                    const gids = rowKeyToIndices.get(rk) || [];
                                    const gi = (gids && gids.length) ? gids[0] : null;
                                    if (gi !== null && rowFirstExcludedAt[gi] !== null) t = Math.max(0, rowFirstExcludedAt[gi] - 1);
                                } catch (err) { }

                                inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${t}" data-k="${t}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                            });
                        }
                        if (list.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${list.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }

                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;
                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });
                            _tbody.addEventListener('mouseout', () => { return; });
                        } catch (err) { }
                    })();

                    try { if (typeof updateHeaderCount === 'function') updateHeaderCount(); } catch (e) { }
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // create card shells in chunks to avoid blocking layout
                const totalGroups = arrGroups.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arrGroups.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arrGroups[i];
                        const card = document.createElement('div');
                        card.className = 'card card-inner-child';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        // Only create an empty card body here. The card header (div.flex)
                        // will be rendered inside the mounted body to avoid duplicate headers.
                        card.innerHTML = `<div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    if (created < arrGroups.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                if (arrGroups.length === 1) wrap.classList.add('single-child');

                // After chunked creation completes, scroll viewport to keep controls visible
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try { window.scrollTo({ top: 240, behavior: 'auto' }); }
                        catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } }
                    });
                }, 160);
            }

            // wire events: input changes trigger redraw
            inputs.forEach((i) => i.addEventListener('input', draw));
            combSel.addEventListener('change', draw);
            sortSel.addEventListener('change', draw);
            if (recencySel) recencySel.addEventListener('change', draw);
            // consec toggles enable/disable order and trigger redraw
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; draw(); };
            order.addEventListener('change', draw);
            draw();

            // Listen to trash changes (dispatched by popup) so Cell6.6 mirrors Cell6.5 behavior
            try {
                const secEl = document.getElementById('cell6_6');
                if (secEl && !secEl.__trashListenerAdded) {
                    secEl.__trashListenerAdded = true;
                    document.addEventListener('trashchange', () => { try { draw(); } catch (e) { } });
                }
            } catch (e) { /* ignore */ }
        }
        // Cell6.5: Truy x - same grouping logic as Cell6 but filter groups to those containing a user-specified number x
        function renderCell6_5() {
            const body = sectionShell("cell6_5", "Cell6.5 · Truy x", "Chọn số x (1-45) và kích thước bộ để liệt kê chỉ những bộ liên quan tới x.");
            // Mode selector placed next to the H2 header
            try {
                const sec = document.getElementById('cell6_5');
                const h2 = sec ? sec.querySelector('h2') : null;
                if (h2) {
                    const modeSel = document.createElement('select');
                    modeSel.title = 'Chế độ hiển thị';
                    modeSel.style.marginLeft = '12px';
                    ['truy', 'lienket', 'unpair'].forEach(k => {
                        const o = document.createElement('option');
                        if (k === 'truy') { o.value = 'truy'; o.textContent = 'Truy x (mặc định)'; }
                        else if (k === 'lienket') { o.value = 'lienket'; o.textContent = 'Liên kết x'; }
                        else { o.value = 'unpair'; o.textContent = 'Unpair'; }
                        modeSel.appendChild(o);
                    });
                    // insert inside the H2 so the dropdown stays compact on the same line
                    h2.appendChild(modeSel);
                    // ensure default mode is 'truy'
                    try { modeSel.value = 'truy'; } catch (e) { }
                    modeSel.style.cssText = 'margin-left:12px;font-size:12px;padding:4px 6px;height:28px;vertical-align:middle;';
                    // build a separate controls container for Liên kết x
                    const lkControls = document.createElement('div'); lkControls.className = 'controls';
                    lkControls.style.display = 'none';
                    // top input
                    const topLabel = document.createElement('input'); topLabel.type = 'number'; topLabel.min = 1; topLabel.placeholder = 'Top (dương)'; topLabel.style.width = '120px';
                    // bộ dropdown (1..6)
                    const lkSetSel = document.createElement('select');[1, 2, 3, 4, 5, 6].forEach(v => { const o = document.createElement('option'); o.value = String(v); o.textContent = `Bộ ${v}`; lkSetSel.appendChild(o); }); lkSetSel.value = '2';
                    // append inputs (no explicit button — auto-update on change)
                    lkControls.appendChild(document.createTextNode('Top:'));
                    lkControls.appendChild(topLabel);
                    lkControls.appendChild(lkSetSel);
                    // place the lkControls below the header by inserting into the DOM
                    // (insert before the original next sibling of h2)
                    h2.parentElement.insertBefore(lkControls, h2.nextSibling);

                    // switching logic will be attached later after main controls created
                    // expose references on body so switch handler can access them
                    body.__modeSel = modeSel;
                    body.__lkControls = lkControls;
                    body.__lkTopInput = topLabel;
                    body.__lkSetSel = lkSetSel;
                }
            } catch (e) { /* ignore if DOM ops fail */ }

            const controls = document.createElement("div"); controls.className = "controls";
            // Bộ số selector: now supports 1..18 (expanded per request)
            const xSel = document.createElement("select");[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18].forEach(v => { const o = document.createElement("option"); o.value = v; o.textContent = `Bộ ${v}`; xSel.appendChild(o); }); xSel.value = "2";
            // Keep native select for logic but hide it; provide a custom popup limited to 9 visible items
            try {
                xSel.style.display = 'none';
                xSel.setAttribute('aria-hidden', 'true');

                const xSelWrapper = document.createElement('div');
                xSelWrapper.className = 'custom-select';
                xSelWrapper.style.position = 'relative';
                xSelWrapper.style.display = 'inline-block';
                xSelWrapper.style.verticalAlign = 'middle';

                const xSelBtn = document.createElement('button');
                xSelBtn.type = 'button';
                xSelBtn.className = 'nav-btn';
                xSelBtn.id = 'cell6_5_xSelBtn';
                xSelBtn.textContent = `Bộ ${xSel.value}`;
                xSelBtn.style.minWidth = '64px';

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'custom-select-options';
                optionsDiv.style.position = 'absolute';
                optionsDiv.style.top = '100%';
                optionsDiv.style.left = '0';
                optionsDiv.style.zIndex = '3000';
                optionsDiv.style.background = 'var(--card)';
                optionsDiv.style.border = '1px solid var(--border)';
                optionsDiv.style.borderRadius = '8px';
                optionsDiv.style.boxShadow = '0 8px 24px rgba(0,0,0,0.25)';
                optionsDiv.style.minWidth = '96px';
                optionsDiv.style.maxHeight = '324px'; /* 9 * 36px */
                optionsDiv.style.overflowY = 'auto';
                optionsDiv.style.display = 'none';

                // populate options
                for (let v = 1; v <= 18; v++) {
                    const opt = document.createElement('div');
                    opt.className = 'custom-select-option';
                    opt.textContent = `Bộ ${v}`;
                    opt.dataset.value = String(v);
                    opt.style.padding = '8px 10px';
                    opt.style.cursor = 'pointer';
                    opt.style.whiteSpace = 'nowrap';
                    opt.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const val = String(v);
                        xSel.value = val;
                        try { xSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { xSel.dispatchEvent(new Event('change')); }
                        xSelBtn.textContent = `Bộ ${val}`;
                        optionsDiv.style.display = 'none';
                    });
                    optionsDiv.appendChild(opt);
                }

                xSelBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    optionsDiv.style.display = optionsDiv.style.display === 'none' ? 'block' : 'none';
                });

                // close on outside click
                document.addEventListener('click', () => { try { optionsDiv.style.display = 'none'; } catch (e) { } });

                // keyboard: close on Escape
                document.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') optionsDiv.style.display = 'none'; });

                xSelWrapper.appendChild(xSelBtn);
                xSelWrapper.appendChild(optionsDiv);
                // keep native select for code logic accessible under wrapper
                xSelWrapper.appendChild(xSel);

                // expose wrapper so we can insert it into controls later
                body.__xSelWrapper = xSelWrapper;
            } catch (e) { /* ignore custom UI if DOM fails */ }
            // remember previous comb so we only clear extras when shrinking the set
            let prevComb = parseInt(xSel.value, 10) || 1;
            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề")); consec.checked = false;
            const order = document.createElement("input"); order.type = "checkbox"; const orderLabel = document.createElement("label"); orderLabel.className = "flex"; orderLabel.style.alignItems = 'center'; orderLabel.style.gap = '6px'; orderLabel.append(order, document.createTextNode("Order")); order.checked = false; order.disabled = true;
            const sortSel = document.createElement("select");[["count_desc", "Giảm dần (số kỳ)"], ["count_asc", "Tăng dần (số kỳ)"], ["value_asc", "Tăng dần (giá trị)"], ["value_desc", "Giảm dần (giá trị)"]].forEach(([v, l]) => { const o = document.createElement("option"); o.value = v; o.textContent = l; sortSel.appendChild(o); });
            const recencySel = document.createElement("select");
            [["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); });
            recencySel.value = 'desc';
            const xFilter = document.createElement("input"); xFilter.type = "number"; xFilter.min = 1; xFilter.max = 45; xFilter.placeholder = "Số x (1-45)"; xFilter.style.width = '88px';
            // Create +/- buttons styled and behaving like Cell9 arrows
            const xContainer = document.createElement('div');
            xContainer.style.cssText = 'position:relative;display:inline-block;vertical-align:middle;margin-right:8px;';
            xFilter.style.paddingRight = '40px';
            xFilter.style.boxSizing = 'border-box';
            const btnGroup = document.createElement('div');
            btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
            const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
            const upBtn = document.createElement('button'); upBtn.type = 'button'; upBtn.className = 'arrow-up'; upBtn.innerHTML = '▲'; upBtn.title = 'Tăng 1'; upBtn.style.cssText = arrowStyle;
            const downBtn = document.createElement('button'); downBtn.type = 'button'; downBtn.className = 'arrow-down'; downBtn.innerHTML = '▼'; downBtn.title = 'Giảm 1'; downBtn.style.cssText = arrowStyle;

            upBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n + 1;
                if (n > 45) n = 1; // wrap like cell9
                if (n < 1) n = 1;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            downBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(xFilter.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n - 1;
                if (n < 1) n = 45; // wrap like cell9
                if (n > 45) n = 45;
                xFilter.value = String(n);
                xFilter.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            btnGroup.appendChild(upBtn);
            btnGroup.appendChild(downBtn);
            xContainer.appendChild(xFilter);
            xContainer.appendChild(btnGroup);

            // Make the input container draggable like Cell9 inputs: allow dragging-out to clear value
            xContainer.__dropHandled = false;
            let draggedX = false;

            const updateXDraggable = () => {
                const v = String(xFilter.value ?? '').trim();
                const has = v !== '';
                xContainer.draggable = has;
                xContainer.style.cursor = has ? 'grab' : 'default';
                xContainer.style.opacity = has ? '' : '';
            };
            updateXDraggable();
            xFilter.addEventListener('input', () => {
                updateXDraggable();
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            xContainer.addEventListener('dragstart', (e) => {
                draggedX = true;
                xContainer.__dropHandled = false;
                // expose global dragging source so other dynamic drops can swap values
                try { window.__draggingDynamic = { type: 'xFilter', input: xFilter, container: xContainer, value: String(xFilter.value ?? '') }; } catch (err) { }
                xContainer.style.opacity = '0.5';
                try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                e.dataTransfer.setData('text/plain', String(xFilter.value ?? ''));
                // include full place set for richer drops
                try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
            });

            xContainer.addEventListener('dragend', (e) => {
                xContainer.style.opacity = '';
                // If drag ended without a handled drop, clear the input (like Cell9 behavior)
                try { window.__draggingDynamic = null; } catch (err) { }
                if (!xContainer.__dropHandled && draggedX && String(xFilter.value ?? '').trim() !== '') {
                    xFilter.value = '';
                    xFilter.dispatchEvent(new Event('input'));
                    if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                }
                draggedX = false;
                xContainer.__dropHandled = false;
            });

            // Accept drags from number picker popup (single number, place index or place set)
            xContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { }
                xContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
            });
            xContainer.addEventListener('dragleave', () => {
                xContainer.style.backgroundColor = '';
            });
            xContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                xContainer.style.backgroundColor = '';
                xContainer.__dropHandled = true;
                const txt = e.dataTransfer.getData('text/plain');
                const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                const placeSetData = e.dataTransfer.getData('application/x-place-set');
                const labelData = e.dataTransfer.getData('application/x-label');
                let value = null;
                // If dragging from another dynamic input, swap values instead of replacing
                try {
                    if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== xFilter) {
                        const srcInput = window.__draggingDynamic.input;
                        const srcVal = String(srcInput.value ?? '');
                        const tgtVal = String(xFilter.value ?? '');
                        // perform swap
                        srcInput.value = tgtVal;
                        srcInput.dispatchEvent(new Event('input'));
                        xFilter.value = srcVal;
                        xFilter.dispatchEvent(new Event('input'));
                        // mark both containers as handled to avoid clearing on dragend
                        try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                        xContainer.__dropHandled = true;
                        // conclude drop handling
                        try { window.__draggingDynamic = null; } catch (err) { }
                        return;
                    }
                } catch (err) { }
                if (placeIndexData) {
                    const idx = parseInt(placeIndexData, 10);
                    const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                    if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                    // Prefer simple text/plain payloads (single number) over place-set JSON
                    value = txt;
                } else if (placeSetData) {
                    try {
                        const arr = JSON.parse(placeSetData);
                        if (Array.isArray(arr) && arr.length) {
                            // pick first numeric value in the set
                            for (const v of arr) {
                                if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; }
                            }
                        }
                    } catch (err) { }
                } else if (labelData) {
                    value = labelData;
                }

                if (value !== null && value !== undefined) {
                    let n = parseInt(String(value).trim(), 10);
                    if (Number.isFinite(n)) {
                        if (n < 1) n = 1;
                        if (n > 45) n = 45;
                        xFilter.value = String(n);
                        xFilter.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    }
                }
            });

            // Container for extra combo inputs (comb - 1) shown when user selects comb > 1
            const comboExtras = document.createElement('div');
            comboExtras.style.cssText = 'display:flex;gap:6px;align-items:center;margin-left:6px;flex-wrap:wrap;';

            // Build or rebuild the (comb - 1) extra inputs based on xSel
            function rebuildComboExtras(prefill = []) {
                comboExtras.innerHTML = '';
                const comb = parseInt(xSel.value, 10) || 1;
                // Limit dynamic extra inputs to at most 5 (user requested: số x + 5 ô dynamic là đủ)
                const count = Math.max(0, Math.min(comb - 1, 5));
                for (let i = 0; i < count; i++) {
                    // container mimics Cell9 input container with drag handle and up/down buttons
                    const container = document.createElement('div');
                    container.className = 'combo-extra-container';
                    container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;padding:2px;border-radius:8px;border:2px solid #f8f333;background:rgba(248,243,180,0.04);';

                    const inp = document.createElement('input');
                    inp.type = 'number';
                    inp.min = 1; inp.max = 45;
                    inp.placeholder = `v${i + 1}`;
                    inp.className = 'combo-extra';
                    inp.style.cssText = 'width:64px;padding:8px;border-radius:6px;border:0;background:transparent;color:var(--text);box-sizing:border-box;';
                    // prefill if value for this index was provided (preserve when increasing comb)
                    if (prefill && prefill[i] !== undefined && String(prefill[i]).trim() !== '') {
                        const parsed = parseInt(String(prefill[i]).trim(), 10);
                        if (Number.isFinite(parsed)) {
                            const clamped = Math.max(1, Math.min(45, parsed));
                            inp.value = String(clamped);
                        }
                    }

                    // right-side up/down buttons
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;
                    btnGroup.appendChild(up); btnGroup.appendChild(down);

                    // drag handle (visual)
                    const dragHandle = document.createElement('div');
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);pointer-events:none;`;

                    // attach behaviors
                    container.__dropHandled = false;
                    container.__dragging = false;

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const has = v !== '';
                        container.draggable = has;
                        dragHandle.style.pointerEvents = has ? 'auto' : 'none';
                        dragHandle.style.cursor = has ? 'grab' : 'default';
                        // Always show yellow border even when empty
                        container.style.borderColor = '#f8f333';
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1; if (n > 45) n = 1; if (n < 1) n = 1;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1; if (n < 1) n = 45; if (n > 45) n = 45;
                        inp.value = String(n); inp.dispatchEvent(new Event('input'));
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.addEventListener('dragstart', (e) => {
                        container.__dragging = true; container.__dropHandled = false;
                        container.style.opacity = '0.5';
                        try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                        e.dataTransfer.setData('text/plain', String(inp.value ?? ''));
                        try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                        // expose global dragging source so other dynamic drops can swap values
                        try { window.__draggingDynamic = { type: 'combo-extra', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    });
                    container.addEventListener('dragend', () => {
                        container.style.opacity = '';
                        try { window.__draggingDynamic = null; } catch (err) { }
                        if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                            inp.value = '';
                            inp.dispatchEvent(new Event('input'));
                            if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                        }
                        container.__dragging = false; container.__dropHandled = false; updateDraggable();
                    });

                    container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(248,243,180,0.06)'; });
                    container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                    container.addEventListener('drop', (e) => {
                        e.preventDefault(); container.style.backgroundColor = '';
                        container.__dropHandled = true;
                        const txt = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        let value = null;
                        // If dragging from another dynamic input, swap values instead of replacing
                        try {
                            if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                                const srcInput = window.__draggingDynamic.input;
                                const srcVal = String(srcInput.value ?? '');
                                const tgtVal = String(inp.value ?? '');
                                // perform swap
                                srcInput.value = tgtVal;
                                srcInput.dispatchEvent(new Event('input'));
                                inp.value = srcVal;
                                inp.dispatchEvent(new Event('input'));
                                // mark both containers as handled to avoid clearing on dragend
                                try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                                container.__dropHandled = true;
                                try { window.__draggingDynamic = null; } catch (err) { }
                                return;
                            }
                        } catch (err) { }

                        if (placeIndexData) {
                            const idx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                        } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                            value = txt;
                        } else if (placeSetData) {
                            try { const arr = JSON.parse(placeSetData); if (Array.isArray(arr) && arr.length) { for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } } } } catch (err) { }
                        } else if (labelData) { value = labelData; }

                        if (value !== null && value !== undefined) {
                            let n = parseInt(String(value).trim(), 10);
                            if (Number.isFinite(n)) {
                                if (n < 1) n = 1; if (n > 45) n = 45;
                                inp.value = String(n); inp.dispatchEvent(new Event('input'));
                                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                            }
                        }
                    });

                    inp.addEventListener('input', () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') { updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; updateDraggable(); if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); return; }
                        if (n < 1) n = 1; if (n > 45) n = 45; inp.value = String(n);
                        updateDraggable();
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    });

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = String(i);
                    comboExtras.appendChild(container);
                    updateDraggable();
                }

                // Unified left/right navigation across the main x input and dynamic extras
                function setupFocusNavigation() {
                    const extrasInputs = Array.from(comboExtras.querySelectorAll('input.combo-extra'));
                    const navElems = [xFilter, ...extrasInputs];
                    navElems.forEach((el, idx) => {
                        el.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const nextIdx = e.key === 'ArrowLeft'
                                ? (idx - 1 + navElems.length) % navElems.length
                                : (idx + 1) % navElems.length;
                            try { navElems[nextIdx].focus(); } catch (err) { }
                        };
                    });
                }

                // Create focus navigation buttons (will be added to controls later)
                try {
                    if (typeof focusPrevBtn === 'undefined') {
                        var focusPrevBtn = document.createElement('button'); focusPrevBtn.type = 'button'; focusPrevBtn.className = 'nav-btn'; focusPrevBtn.title = 'Chuyển ô trái'; focusPrevBtn.textContent = '◀';
                        var focusNextBtn = document.createElement('button'); focusNextBtn.type = 'button'; focusNextBtn.className = 'nav-btn'; focusNextBtn.title = 'Chuyển ô phải'; focusNextBtn.textContent = '▶';
                        focusPrevBtn.style.marginRight = '6px'; focusNextBtn.style.marginLeft = '6px';
                        focusPrevBtn.addEventListener('click', () => {
                            const elems = [xFilter, ...Array.from(comboExtras.querySelectorAll('input.combo-extra'))];
                            const active = document.activeElement; let idx = elems.indexOf(active); if (idx === -1) idx = 0;
                            const prev = (idx - 1 + elems.length) % elems.length; try { elems[prev].focus(); } catch (e) { }
                        });
                        focusNextBtn.addEventListener('click', () => {
                            const elems = [xFilter, ...Array.from(comboExtras.querySelectorAll('input.combo-extra'))];
                            const active = document.activeElement; let idx = elems.indexOf(active); if (idx === -1) idx = 0;
                            const nxt = (idx + 1) % elems.length; try { elems[nxt].focus(); } catch (e) { }
                        });
                    }
                } catch (e) { }
                // ensure nav wiring after rebuild
                try { setupFocusNavigation(); } catch (e) { }
            }

            // rebuild extras when comb selection changes
            xSel.addEventListener('change', () => {
                const newComb = parseInt(xSel.value, 10) || 1;
                const oldCount = Math.max(0, prevComb - 1);
                const newCount = Math.max(0, newComb - 1);
                if (newCount >= oldCount) {
                    // preserve existing values when increasing or same size
                    const existing = Array.from(comboExtras.querySelectorAll('input[type="number"].combo-extra')).map(i => i.value ?? '');
                    rebuildComboExtras(existing);
                    // dispatch input for preserved values to trigger any UI updates
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => { if ((inp.value ?? '').trim() !== '') inp.dispatchEvent(new Event('input')); });
                } else {
                    // shrinking: preserve leading values up to newCount
                    const existing = Array.from(comboExtras.querySelectorAll('input[type="number"].combo-extra')).map(i => i.value ?? '');
                    const prefill = existing.slice(0, newCount);
                    rebuildComboExtras(prefill);
                    // dispatch input for preserved values to trigger any UI updates
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach((inp, idx) => {
                        if ((prefill[idx] ?? '').trim() !== '') inp.dispatchEvent(new Event('input'));
                    });
                }
                prevComb = newComb;
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            // initial build
            rebuildComboExtras();

            // Trash toggle (copied from Cell5.5): compact include/exclude toggle button
            const trashSel = document.createElement('button');
            try { trashSel.id = 'cell6_5_trashSel'; trashSel.className = 'trash-mode trash-toggle'; } catch (e) { }
            trashSel.type = 'button';
            trashSel.value = 'include';
            trashSel.textContent = 'include';
            trashSel.title = 'Click to toggle trash mode (include/exclude)';
            trashSel.style.cssText = 'width:120px;';
            trashSel.addEventListener('click', () => {
                try {
                    trashSel.value = (trashSel.value === 'include') ? 'exclude' : 'include';
                    trashSel.textContent = trashSel.value;
                    try { const other = document.getElementById('cell6_6_trashSel'); if (other) { other.value = trashSel.value; if (other.textContent !== undefined) other.textContent = trashSel.value; } } catch (e) { }
                    try { trashSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                } catch (e) { }
            });

            // Special input for Unpair mode: only one numeric field 'numtrash' (1..44)
            // Remove any previously-created wrappers to avoid duplicate labels after re-renders
            try {
                const old = document.querySelectorAll('#cell6_5 .numtrash-wrapper');
                old.forEach(n => { try { n.remove(); } catch (e) { /* ignore */ } });
            } catch (e) { /* ignore */ }
            const numTrashInput = document.createElement('input');
            numTrashInput.type = 'number';
            numTrashInput.min = 1; numTrashInput.max = 44; numTrashInput.value = 3;
            numTrashInput.style.width = '80px';
            numTrashInput.title = 'Số lượng nhóm cuối cùng (1-44)';
            // Create +/- buttons styled like the Số x control
            const numTrashContainer = document.createElement('div');
            numTrashContainer.style.cssText = 'position:relative;display:inline-block;vertical-align:middle;margin-right:8px;';
            numTrashInput.style.paddingRight = '40px';
            numTrashInput.style.boxSizing = 'border-box';
            const numBtnGroup = document.createElement('div');
            numBtnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
            const numArrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
            const numUpBtn = document.createElement('button'); numUpBtn.type = 'button'; numUpBtn.className = 'arrow-up'; numUpBtn.id = 'cell6_5_numtrash_up'; numUpBtn.innerHTML = '▲'; numUpBtn.title = 'Tăng 1'; numUpBtn.style.cssText = numArrowStyle;
            const numDownBtn = document.createElement('button'); numDownBtn.type = 'button'; numDownBtn.className = 'arrow-down'; numDownBtn.id = 'cell6_5_numtrash_down'; numDownBtn.innerHTML = '▼'; numDownBtn.title = 'Giảm 1'; numDownBtn.style.cssText = numArrowStyle;

            numUpBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(numTrashInput.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n + 1;
                if (n > 44) n = 1; // wrap
                if (n < 1) n = 1;
                numTrashInput.value = String(n);
                numTrashInput.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });
            numDownBtn.addEventListener('click', (e) => {
                e.preventDefault();
                let n = parseInt(String(numTrashInput.value ?? '').trim(), 10);
                if (!Number.isFinite(n)) n = 0;
                n = n - 1;
                if (n < 1) n = 44; // wrap
                if (n > 44) n = 44;
                numTrashInput.value = String(n);
                numTrashInput.dispatchEvent(new Event('input'));
                if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
            });

            numBtnGroup.appendChild(numUpBtn);
            numBtnGroup.appendChild(numDownBtn);
            numTrashContainer.appendChild(numTrashInput);
            numTrashContainer.appendChild(numBtnGroup);

            const numTrashLabel = document.createElement('label');
            numTrashLabel.className = 'flex';
            numTrashLabel.classList.add('numtrash-wrapper');
            numTrashLabel.style.alignItems = 'center';
            numTrashLabel.style.gap = '6px';
            numTrashLabel.append(document.createTextNode('numtrash:'), numTrashContainer);
            // hidden by default; shown only when trashSel === 'unpair'
            numTrashLabel.style.display = 'none';

            // Optimize checkbox: shown only in Unpair mode alongside numtrash
            const optChk = document.createElement('input'); optChk.type = 'checkbox'; optChk.id = 'cell6_5_optimize';
            const optLabel = document.createElement('label'); optLabel.className = 'flex';
            optLabel.classList.add('numtrash-wrapper'); // ensure visibility only in unpair-mode
            optLabel.style.alignItems = 'center'; optLabel.style.gap = '6px';
            optLabel.append(optChk, document.createTextNode('Tối ưu'));
            // dropdown for optimize mode: 'nền xanh' (green) or 'nền đỏ' (red)
            const optSel = document.createElement('select');
            optSel.id = 'cell6_5_optMode';
            const o1 = document.createElement('option'); o1.value = 'green'; o1.textContent = 'nền xanh'; optSel.appendChild(o1);
            const o2 = document.createElement('option'); o2.value = 'red'; o2.textContent = 'nền đỏ'; optSel.appendChild(o2);
            optSel.value = 'green';
            optSel.disabled = true; // enabled only when checkbox is checked
            optSel.style.marginLeft = '8px';
            optLabel.appendChild(optSel);
            optLabel.style.display = 'none';

            // --- Unpair mode: six distinct number inputs (1..45) ---
            const unpairInputs = document.createElement('div');
            unpairInputs.className = 'numtrash-wrapper';
            unpairInputs.style.display = 'none';
            unpairInputs.style.alignItems = 'center';
            unpairInputs.style.gap = '6px';
            unpairInputs.style.marginLeft = '6px';
            // informational field that shows computed candidate and its dontmatch set in Unpair mode
            const unpairInfo = document.createElement('span');
            unpairInfo.className = 'numtrash-wrapper';
            unpairInfo.style.display = 'none';
            unpairInfo.style.alignItems = 'center';
            unpairInfo.style.gap = '6px';
            unpairInfo.style.marginLeft = '6px';
            unpairInfo.style.fontWeight = '700';
            unpairInfo.style.minWidth = '180px';
            unpairInfo.textContent = '';
            unpairInfo.style.cursor = 'pointer';
            unpairInfo.title = 'Click to recompute from the 6 inputs';
            unpairInfo.addEventListener('click', (ev) => {
                try {
                    // If there's no displayed text, give a visual cue and exit
                    const txt = (unpairInfo && String(unpairInfo.textContent || '').trim()) || '';
                    if (!txt) {
                        try { ev.target.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 320 }); } catch (e) { }
                        return;
                    }
                    // Format for clipboard: remove spaces around '>' and append newline
                    let formatted = txt.replace(/\s*>\s*/g, '>');
                    // Ensure trailing newline
                    if (!formatted.endsWith('\n')) formatted += '\n';
                    // Try Clipboard API, fallback to textarea
                    (async () => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                await navigator.clipboard.writeText(formatted);
                            } else {
                                const ta = document.createElement('textarea');
                                ta.style.position = 'fixed'; ta.style.left = '-9999px'; ta.value = formatted; document.body.appendChild(ta); ta.select(); try { document.execCommand('copy'); } catch (e) { }
                                try { document.body.removeChild(ta); } catch (e) { }
                            }
                            try { ev.target.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 180 }); } catch (e) { }
                        } catch (e) {
                            try { ev.target.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 320 }); } catch (ee) { }
                        }
                    })();
                } catch (e) { }
            });
            // create six inputs styled like Cell6.6 (drag-input-container + up/down buttons)
            const unpairInputEls = [];
            for (let i = 0; i < 6; i++) {
                const inp = document.createElement('input');
                inp.type = 'number'; inp.min = 1; inp.max = 45; inp.placeholder = `#${i + 1}`;
                inp.id = `cell6_5_unpair_input_${i + 1}`;
                inp.style.width = '70px'; inp.style.boxSizing = 'border-box';

                const container = document.createElement('div');
                container.className = 'drag-input-container';
                container.style.cssText = 'position:relative;display:inline-block;margin-right:6px;vertical-align:middle;';

                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = 'relative'; inp.style.zIndex = '1'; inp.style.paddingRight = '40px'; inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n + 1;
                    if (n > 45) n = 1; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    n = n - 1;
                    if (n < 1) n = 45; // wrap
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                });

                btnGroup.appendChild(up); btnGroup.appendChild(down);
                container.appendChild(inp); container.appendChild(btnGroup); container.appendChild(dragHandle);

                // make container draggable when it has a value and expose visual state
                container.__dropHandled = false;
                container.__dragging = false;

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const has = v !== '';
                    container.draggable = has;
                    try { dragHandle.style.pointerEvents = has ? 'auto' : 'none'; dragHandle.style.cursor = has ? 'grab' : 'default'; } catch (e) { }
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = has ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = has ? '1' : '0.9';
                };
                // expose updater so external code (swap handlers) can refresh visuals without
                // triggering input events / recompute. Call as `container.updateDraggable()`.
                try { container.updateDraggable = updateDraggable; } catch (e) { }
                updateDraggable();

                // uniqueness visual + input events
                inp.addEventListener('input', () => {
                    try {
                        clampForNumber();
                        const vals = unpairInputEls.map(e => e.value).filter(s => s !== '');
                        unpairInputEls.forEach(el => {
                            if (el.value !== '' && vals.indexOf(el.value) !== vals.lastIndexOf(el.value)) el.style.borderColor = 'red'; else el.style.borderColor = '';
                        });
                        try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                        // If all 6 inputs are filled with distinct numbers, compute best numTrash and num
                        try {
                            const filled = unpairInputEls.map(e => (e.value || '').trim()).filter(s => s !== '');
                            if (filled.length >= 1) {
                                const nums = filled.map(s => parseInt(s, 10)).filter(n => Number.isFinite(n) && n >= 1 && n <= 45);
                                const uniq = Array.from(new Set(nums));
                                if (uniq.length >= 1) {
                                    try { computeAndApplyUnpairBest(uniq); } catch (e) { }
                                }
                            } else {
                                // clear the informational field when no inputs provided
                                try { if (typeof unpairInfo !== 'undefined' && unpairInfo) unpairInfo.textContent = ''; } catch (e) { }
                            }
                        } catch (e) { }
                    } catch (e) { }
                    try { updateDraggable(); } catch (e) { }
                    // Sync place boxes with unpair inputs when Cell6.5 is in unpair mode
                    try {
                        const __c65 = document.getElementById('cell6_5');
                        if (__c65 && __c65.style.display !== 'none' && __c65.querySelector('.controls.unpair-mode')) {
                            const plVals = unpairInputEls.map(el => (el.value || '').trim());
                            if (typeof window.setPlaceValues === 'function') window.setPlaceValues(plVals);
                        }
                    } catch (e) { }
                });

                // Arrow left/right: cycle focus between the 6 unpair inputs (circular)
                inp.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); unpairInputEls[(i - 1 + unpairInputEls.length) % unpairInputEls.length].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); unpairInputEls[(i + 1) % unpairInputEls.length].focus(); }
                });

                // drag/drop: support swapping with other dynamic inputs, accept place-index/place-set,
                // and clear value on dragend if drop was not handled (matching Cell6.6 behavior)
                container.addEventListener('dragstart', (e) => {
                    container.__dragging = true;
                    container.__dropHandled = false;
                    container.style.opacity = '0.5';
                    try { window.__draggingDynamic = { type: 'cell6_5_unpair', input: inp, container: container, value: String(inp.value ?? '') }; } catch (err) { }
                    try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (er) { }
                    try { e.dataTransfer.setData('text/plain', String(inp.value ?? '')); } catch (er) { }
                    try { e.dataTransfer.setData('application/x-place-set', JSON.stringify(window.getPlaceValues ? window.getPlaceValues() : [])); } catch (er) { }
                });

                container.addEventListener('dragend', (e) => {
                    container.style.opacity = '';
                    try { window.__draggingDynamic = null; } catch (err) { }
                    if (!container.__dropHandled && container.__dragging && String(inp.value ?? '').trim() !== '') {
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                        try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                    }
                    container.__dragging = false;
                    container.__dropHandled = false;
                });

                container.addEventListener('dragover', (e) => { e.preventDefault(); try { e.dataTransfer.dropEffect = 'copy'; } catch (er) { } container.style.backgroundColor = 'rgba(56, 239, 125, 0.04)'; });
                container.addEventListener('dragleave', () => { container.style.backgroundColor = ''; });
                container.addEventListener('drop', (e) => {
                    e.preventDefault(); container.style.backgroundColor = ''; container.__dropHandled = true;
                    const txt = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');
                    let value = null;
                    // If dragging from another dynamic input, swap values instead of replacing
                    try {
                        if (window.__draggingDynamic && window.__draggingDynamic.input && window.__draggingDynamic.input !== inp) {
                            const srcInput = window.__draggingDynamic.input;
                            const srcVal = String(srcInput.value ?? '');
                            const tgtVal = String(inp.value ?? '');
                            // perform silent swap: set values but DO NOT dispatch 'input' events
                            // to avoid triggering recompute or changing the current UI highlights.
                            try { srcInput.value = tgtVal; } catch (e) { srcInput.value = tgtVal; }
                            try { inp.value = srcVal; } catch (e) { inp.value = srcVal; }
                            // update drag visuals (draggability / handle) without recomputing
                            try { if (srcInput.parentElement && typeof srcInput.parentElement.updateDraggable === 'function') srcInput.parentElement.updateDraggable(); } catch (e) { }
                            try { if (container && typeof container.updateDraggable === 'function') container.updateDraggable(); } catch (e) { }
                            // mark both containers as handled to avoid clearing on dragend
                            try { srcInput.parentElement.__dropHandled = true; } catch (e) { }
                            container.__dropHandled = true;
                            try { window.__draggingDynamic = null; } catch (err) { }
                            return;
                        }
                    } catch (err) { }

                    if (placeIndexData) {
                        const idx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(idx) && placeVals && idx >= 0 && idx < 6) value = placeVals[idx];
                    } else if (placeSetData) {
                        try {
                            const arr = JSON.parse(placeSetData);
                            if (Array.isArray(arr) && arr.length === 6) {
                                // if full set dropped, pick corresponding index if possible, else first non-empty
                                try {
                                    const placeIdx = parseInt(e.dataTransfer.getData('application/x-place-target-index') || '-1', 10);
                                } catch (er) { }
                                // fallback: pick first non-empty
                                if (Array.isArray(arr) && arr.length) {
                                    for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } }
                                }
                            } else if (Array.isArray(arr) && arr.length) {
                                for (const v of arr) { if (v !== null && v !== undefined && String(v).trim() !== '') { value = v; break; } }
                            }
                        } catch (err) { }
                    } else if (txt && String(txt).trim() !== '' && !String(txt).trim().startsWith('[')) {
                        value = txt;
                    } else if (labelData) { value = labelData; }

                    if (value !== null && value !== undefined) {
                        let n = parseInt(String(value).trim(), 10);
                        if (Number.isFinite(n)) {
                            if (n < 1) n = 1;
                            if (n > 45) n = 45;
                            inp.value = String(n);
                            inp.dispatchEvent(new Event('input'));
                            try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                        }
                    }
                });

                unpairInputs.appendChild(container);
                unpairInputEls.push(inp);
            }

            // dblclick quickpaste for the unpair inputs: read clipboard or prompt and apply
            unpairInputs.addEventListener('dblclick', async (ev) => {
                try {
                    const popup = document.getElementById('numberPickerPopup');
                    if (popup && popup.contains(ev.target)) return;
                } catch (e) { }
                let text = null;
                try { if (navigator.clipboard && navigator.clipboard.readText) text = await navigator.clipboard.readText(); } catch (e) { text = null; }
                if (!text || String(text).trim() === '') {
                    try { const res = window.prompt('Paste 6 numbers (comma or space separated), e.g. 29,3,35,24,18,30', ''); if (res && String(res).trim() !== '') text = res.trim(); } catch (e) { text = null; }
                }
                if (!text) return;
                try {
                    const nums = parseSixNumbersFromString(text);
                    if (!nums) {
                        try { ev.target.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (e) { }
                        return;
                    }
                    for (let k = 0; k < 6; k++) {
                        unpairInputEls[k].value = String(nums[k]);
                        unpairInputEls[k].dispatchEvent(new Event('input'));
                    }
                    try { ev.target.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (e) { }
                    // clear any lingering number-picker hover highlights (orange border)
                    try {
                        if (typeof clearPopupHighlights === 'function') clearPopupHighlights();
                        try { window.__popupHighlights = null; window.__popupHighlightSource = null; } catch (e) { }
                    } catch (e) { }
                } catch (err) { console.warn('unpair quickpaste failed', err); }
            });

            // Compute best numTrash and corresponding num for the provided 6 numbers,
            // then update `numTrashInput`, set trash to the found dontmatch set and
            // trigger UI updates (highlights + trash popup update).
            function computeAndApplyUnpairBest(sixNums) {
                try {
                    if (!Array.isArray(sixNums) || sixNums.length === 0) return;
                    // ensure numeric
                    const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n) && n >= 1 && n <= 45);
                    if (userNums.length === 0) return;
                    // build pair counts across dataset
                    const pairCounts = new Map();
                    try {
                        rows.forEach(r => {
                            try {
                                const nums = Array.isArray(r.nums) ? r.nums.slice().sort((a, b) => a - b) : [];
                                for (let i = 0; i < nums.length; i++) {
                                    for (let j = i + 1; j < nums.length; j++) {
                                        const a = nums[i], b = nums[j];
                                        const key = `${a}-${b}`;
                                        pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
                                    }
                                }
                            } catch (e) { }
                        });
                    } catch (e) { }

                    // try largest n down to 1
                    const MAX_N = Math.min(44, 44);
                    let found = null;
                    for (let n = MAX_N; n >= 1; n--) {
                        for (const cand of userNums) {
                            // build least-frequent others for cand
                            const others = [];
                            for (let y = 1; y <= 45; y++) {
                                if (y === cand) continue;
                                const a = Math.min(cand, y), b = Math.max(cand, y);
                                const key = `${a}-${b}`;
                                const c = pairCounts.get(key) || 0;
                                others.push({ y, c });
                            }
                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                            const pick = others.slice(0, n).map(o => o.y);
                            // ensure pick does NOT contain any of the other five user numbers
                            const otherFive = userNums.filter(x => x !== cand);
                            const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                            if (!conflict) {
                                found = { n, cand, pick };
                                break;
                            }
                        }
                        if (found) break;
                    }

                    if (!found) {
                        // fallback: n = 1 with first candidate's least-frequent
                        const cand = userNums[0];
                        const others = [];
                        for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = pairCounts.get(key) || 0; others.push({ y, c }); }
                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                        found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                    }

                    try {
                        // 1) update numTrash input first so Cell6.5 can re-render using the new k
                        if (typeof numTrashInput !== 'undefined' && numTrashInput) {
                            numTrashInput.value = String(found.n);
                            try { numTrashInput.dispatchEvent(new Event('input', { bubbles: true })); } catch (e) { try { numTrashInput.dispatchEvent(new Event('input')); } catch (ee) { } }
                            // update the unpair info display (show candidate > {dontmatch list})
                            try {
                                if (typeof unpairInfo !== 'undefined' && unpairInfo) {
                                    // display candidate and the other five input numbers (remaining from the six)
                                    try {
                                        const remaining = (userNums || []).filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                                        const k = (typeof numTrashInput !== 'undefined' && numTrashInput) ? String(numTrashInput.value || '') : String(found.n || '');
                                        if (remaining && remaining.length) {
                                            remaining.sort((a, b) => a - b);
                                            // append current numTrash value in brackets
                                            unpairInfo.innerHTML = `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${k}]</span>`;
                                        } else {
                                            // single number only — show candidate and k
                                            unpairInfo.innerHTML = `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span><span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${k}]</span>`;
                                        }
                                    } catch (ee) { unpairInfo.textContent = '' }
                                }
                            } catch (e) { }
                        }
                    } catch (e) { }

                    // 2b) Update fav with the candidate number (remove previous candidate, add new one)
                    try {
                        const prevCand = window.__cell6_5_lastCand || null;
                        if (prevCand !== null && Number(prevCand) !== Number(found.cand)) {
                            try { if (typeof window.removeFromFav === 'function') window.removeFromFav(Number(prevCand)); } catch (e) { }
                        }
                        try { if (typeof window.addToFav === 'function') window.addToFav(Number(found.cand)); } catch (e) { }
                        window.__cell6_5_lastCand = Number(found.cand);
                        // Keep hover re-apply in sync with the computed candidate
                        // so w/s numtrash changes re-focus on this candidate, not an old hover
                        try { window.__lastHoveredUnpairNum = Number(found.cand); } catch (e) { }
                    } catch (e) { }

                    // 3) wait for the Cell6.5 table to reflect the new numTrash (if it rerenders),
                    // then move dontmatch numbers into trash and finally apply styling.
                    try {
                        const runAfterTableUpdate = () => {
                            try {
                                const uniq = Array.from(new Set(found.pick.map(n => Number(n)).filter(Number.isFinite)));
                                if (!uniq.length) return;

                                // Clear ALL existing trash first (avoid hover contamination),
                                // then add only the new dontmatch set.
                                try {
                                    // Reset hover state flags
                                    try { window.__hoverActive = false; } catch (e) { }
                                    try { window.__hoverPrevTrash = null; } catch (e) { }

                                    // Clear all trash items using the proper exposed function
                                    try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }

                                    // Helper: directly apply green highlight to candidate row
                                    const directHighlightCandidate = () => {
                                        try {
                                            const tbl = document.querySelector('#cell6_5 table');
                                            if (!tbl) return;
                                            const rowsDom = Array.from(tbl.querySelectorAll('tbody tr'));
                                            for (const r of rowsDom) {
                                                try {
                                                    const numTd = r.children && r.children[0] ? r.children[0] : null;
                                                    if (!numTd) continue;
                                                    const val = Number((numTd.textContent || '').trim());
                                                    if (Number.isFinite(val) && val === Number(found.cand)) {
                                                        numTd.classList.add('cell6-num-highlight');
                                                        numTd.classList.remove('cell6-num-in-trash');
                                                        r.classList.add('dragged-out');
                                                        try { r.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
                                                        try { r.animate([{ transform: 'scale(1.02)' }, { transform: 'scale(1)' }], { duration: 260 }); } catch (e) { }
                                                    }
                                                } catch (e) { }
                                            }
                                        } catch (e) { }
                                    };

                                    // Handler that applies highlights/pulse AFTER the trash move
                                    const onTrashUpdated = () => {
                                        try {
                                            // remember latest dontmatch set for next time
                                            try { window.__cell6_5_lastDontmatch = new Set(uniq); } catch (e) { }
                                            try { if (typeof window.updateCell6_5Highlights === 'function') window.updateCell6_5Highlights(); } catch (e) { }
                                            // directly apply green highlight to candidate row
                                            directHighlightCandidate();
                                        } catch (e) { }
                                    };

                                    // Now move only the new dontmatch into trash
                                    try { (document.getElementById('trashPopup') || document.body).addEventListener('trashupdated', onTrashUpdated, { once: true }); } catch (e) { }
                                    try { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: uniq }, bubbles: true, composed: true })); } catch (e) { }
                                } catch (e) { }
                            } catch (e) { }
                        };

                        // If the table body exists, observe it for changes (re-render). Use a short timeout fallback.
                        const tb = document.querySelector('#cell6_5 table tbody');
                        if (tb) {
                            let called = false;
                            const mo = new MutationObserver(() => {
                                if (called) return;
                                called = true;
                                try { mo.disconnect(); } catch (e) { }
                                runAfterTableUpdate();
                            });
                            try { mo.observe(tb, { childList: true, subtree: true, characterData: true }); } catch (e) { runAfterTableUpdate(); }
                            // fallback: if no mutation within 700ms, proceed anyway
                            setTimeout(() => { if (!called) { try { mo.disconnect(); } catch (e) { } called = true; runAfterTableUpdate(); } }, 700);
                        } else {
                            // no table body found; proceed immediately
                            runAfterTableUpdate();
                        }
                    } catch (e) { }

                    // Safety fallback: directly apply green highlight to candidate row after 1.2s
                    // in case the trash event chain doesn't trigger properly
                    try {
                        const candNum = Number(found.cand);
                        setTimeout(() => {
                            try {
                                const tbl = document.querySelector('#cell6_5 table');
                                if (!tbl) return;
                                const allRows = Array.from(tbl.querySelectorAll('tbody tr'));
                                for (const r of allRows) {
                                    try {
                                        const td0 = r.children && r.children[0];
                                        if (!td0) continue;
                                        const v = Number((td0.textContent || '').trim());
                                        if (Number.isFinite(v) && v === candNum) {
                                            if (!td0.classList.contains('cell6-num-highlight')) {
                                                td0.classList.add('cell6-num-highlight');
                                                td0.classList.remove('cell6-num-in-trash');
                                                r.classList.add('dragged-out');
                                            }
                                            try { r.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
                                        }
                                    } catch (e) { }
                                }
                                // also re-run global highlight sync
                                try { if (typeof window.updateCell6_5Highlights === 'function') window.updateCell6_5Highlights(); } catch (e) { }
                            } catch (e) { }
                        }, 1200);
                    } catch (e) { }
                } catch (err) { console.warn('computeAndApplyUnpairBest failed', err); }
            }
            // Expose to global scope so external Shift+click handlers can call it
            try { window.computeAndApplyUnpairBest = computeAndApplyUnpairBest; } catch (e) { }

            // Mirror Cell6.6's selector syncing: when this selector changes,
            // propagate value to Cell6.6's selector, dispatch a global trashchange
            // and trigger a local recompute. Also listen for external trashchange
            // events to keep this selector in sync when Cell6.6 or popup updates.
            try {
                // helper to toggle UI when Unpair is selected
                function updateTrashModeUI(mode) {
                    try {
                        const isUnpair = String(mode) === 'unpair';
                        try { controls.classList.toggle('unpair-mode', isUnpair); } catch (e) { }

                        try {
                            // Wrap plain-text label nodes into span.control-label so we can hide them
                            Array.from(controls.childNodes).forEach(node => {
                                try {
                                    if (node && node.nodeType === Node.TEXT_NODE && String(node.textContent || '').trim()) {
                                        const txt = node.textContent;
                                        const span = document.createElement('span');
                                        span.className = 'control-label';
                                        span.textContent = txt;
                                        controls.replaceChild(span, node);
                                    }
                                } catch (e) { /* ignore */ }
                            });

                            // Toggle visibility: show only .numtrash-wrapper when in Unpair
                            Array.from(controls.children).forEach(el => {
                                try {
                                    if (el.classList && el.classList.contains('numtrash-wrapper')) {
                                        el.style.display = isUnpair ? 'flex' : '';
                                        // also restore visibility/pointer events when showing
                                        el.style.visibility = isUnpair ? 'visible' : '';
                                        el.style.pointerEvents = isUnpair ? 'auto' : '';
                                        try { Array.from(el.querySelectorAll('input,select,button')).forEach(i => { try { i.disabled = !isUnpair; } catch (e) { } }); } catch (e) { }
                                    } else {
                                        el.style.display = isUnpair ? 'none' : '';
                                    }
                                } catch (e) { }
                            });

                            // ensure main controls are visible when entering Unpair
                            if (isUnpair) {
                                try { controls.style.display = ''; } catch (e) { }
                            }

                            // enable/disable optimizer checkbox/select and numTrash input
                            try { if (typeof optChk !== 'undefined' && optChk) optChk.disabled = !isUnpair; } catch (e) { }
                            try { if (typeof numTrashInput !== 'undefined' && numTrashInput) numTrashInput.disabled = !isUnpair; } catch (e) { }
                            try { if (typeof optSel !== 'undefined' && optSel) optSel.disabled = !(isUnpair && optChk && optChk.checked); } catch (e) { }

                            const lk = (body && body.__lkControls) ? body.__lkControls : null;
                            const modeSelect = (body && body.__modeSel) ? body.__modeSel : null;
                            if (lk) {
                                try {
                                    if (isUnpair) {
                                        lk.style.display = 'none';
                                    } else if (modeSelect && String(modeSelect.value || '') !== 'lienket') {
                                        // only show lienket controls when header mode is explicitly 'lienket'
                                        lk.style.display = 'none';
                                    } else {
                                        lk.style.display = '';
                                    }
                                } catch (e) { }
                            }
                        } catch (e) { }
                    } catch (e) { }
                }

                trashSel.addEventListener('change', () => {
                    try {
                        const other = document.getElementById('cell6_6_trashSel');
                        if (other) other.value = trashSel.value;
                    } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                    try {
                        updateTrashModeUI(trashSel.value);
                        // Enable/disable place sync with unpair inputs
                        try {
                            if (String(trashSel.value) === 'unpair') {
                                window.__cell6_5_placeSync = true;
                                if (typeof window.__syncUnpairToPlace === 'function') window.__syncUnpairToPlace();
                            } else {
                                window.__cell6_5_placeSync = false;
                            }
                        } catch (e) { }
                        if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                    } catch (e) { try { if (typeof group === 'function') group(); } catch (er) { } }
                });
            } catch (e) { }

            try {
                document.addEventListener('trashchange', () => {
                    try {
                        const other = document.getElementById('cell6_6_trashSel');
                        if (other && trashSel && trashSel.value !== other.value) trashSel.value = other.value;
                    } catch (e) { }
                    try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                });
            } catch (e) { }

            // Fav filter toggle (click to toggle include|exclude) - default exclude
            const favSel = document.createElement('button');
            try { favSel.id = 'cell6_5_favSel'; favSel.className = 'fav-mode fav-toggle'; } catch (e) { }
            favSel.type = 'button';
            favSel.value = 'exclude';
            favSel.textContent = 'exclude';
            favSel.title = 'Click to toggle fav mode (include/exclude)';
            favSel.style.padding = '6px 10px';
            favSel.style.marginLeft = '6px';
            favSel.addEventListener('click', () => {
                try {
                    favSel.value = (favSel.value === 'include') ? 'exclude' : 'include';
                    favSel.textContent = favSel.value;
                    try { favSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { if (typeof group === 'function') group(); } catch (e) { }
                } catch (e) { }
            });

            // Ensure Cell6.5 redraws when the fav popup changes (only add listener once)
            try {
                if (!window.__cell6_5_fav_listener_added) {
                    document.addEventListener('favchange', function () {
                        try {
                            const cur = document.getElementById('cell6_5_favSel');
                            const other = document.getElementById('cell6_6_favSel');
                            const isInclude = (cur && String(cur.value) === 'include') || (other && String(other.value) === 'include');
                            if (isInclude) {
                                try { groupCache = null; } catch (e) { }
                                try { cacheKey = null; } catch (e) { }
                                try { baselineArrAll = null; baselineArrGlobal = null; baselineCountsMap = null; baselineAllKeys = null; baselineGlobalKeys = null; } catch (e) { }
                                try { if (typeof draw === 'function') draw(); else if (typeof group === 'function') group(); } catch (err) { /* ignore */ }
                            }
                        } catch (e) { }
                    });
                    window.__cell6_5_fav_listener_added = true;
                }
            } catch (e) { /* ignore */ }

            // Download rules button: exports visible history rows as Excel (SpreadsheetML)
            // Download rules button: exports visible history rows as Excel (.xlsx OOXML chuẩn)
            const ruleBtn = document.createElement('button');
            ruleBtn.type = 'button';
            ruleBtn.textContent = 'Download rules';
            ruleBtn.title = 'Download visible history as rule.xlsx (OOXML format)';
            ruleBtn.style.marginLeft = '8px';
            ruleBtn.style.padding = '6px 10px';
            ruleBtn.classList.add('numtrash-wrapper');

            ruleBtn.addEventListener('click', async (ev) => {
                try {
                    const resp = await fetch('data.json');
                    if (!resp.ok) {
                        console.warn('Download rules: data.json fetch returned', resp && resp.status);
                        try { ev.target.animate([{ transform: 'translateY(-4px)' }, { transform: 'translateY(0px)' }], { duration: 180 }); } catch (e) { }
                        alert('Không thể tải data.json (HTTP ' + (resp && resp.status) + '). Vui lòng chạy trang qua HTTP hoặc đặt data.json cùng thư mục.');
                        return;
                    }
                    const data = await resp.json();

                    // 1. parse results into arrays (Giữ nguyên logic cũ)
                    const parsedRows = (Array.isArray(data) ? data : []).map(obj => {
                        const res = (obj && (obj.Result || obj.result)) || '';
                        return (res || '').split(/\s*,\s*/).map(s => parseInt(s, 10)).filter(Number.isFinite);
                    });

                    // 2. build global pair counts (Giữ nguyên logic cũ)
                    const pairCounts = new Map();
                    parsedRows.forEach(nums => {
                        if (!Array.isArray(nums) || nums.length !== 6) return;
                        const ns = nums.slice().sort((a, b) => a - b);
                        for (let i = 0; i < ns.length; i++) {
                            for (let j = i + 1; j < ns.length; j++) {
                                const a = ns[i], b = ns[j];
                                const key = `${a}-${b}`;
                                pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
                            }
                        }
                    });

                    // 3. computeRule function (Giữ nguyên logic cũ)
                    const computeRule = (sixNums) => {
                        try {
                            if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                            const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                            if (userNums.length !== 6) return '';
                            const MAX_N = 44;
                            let found = null;
                            for (let n = MAX_N; n >= 1; n--) {
                                for (const cand of userNums) {
                                    const others = [];
                                    for (let y = 1; y <= 45; y++) {
                                        if (y === cand) continue;
                                        const a = Math.min(cand, y), b = Math.max(cand, y);
                                        const key = `${a}-${b}`;
                                        const c = pairCounts.get(key) || 0;
                                        others.push({ y, c });
                                    }
                                    others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                    const pick = others.slice(0, n).map(o => o.y);
                                    const otherFive = userNums.filter(x => x !== cand);
                                    const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                    if (!conflict) { found = { n, cand, pick }; break; }
                                }
                                if (found) break;
                            }
                            if (!found) {
                                const cand = userNums[0];
                                const others = [];
                                for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = pairCounts.get(key) || 0; others.push({ y, c }); }
                                others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                            }
                            const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                            remaining.sort((a, b) => a - b);
                            return `${found.cand}>{${remaining.join(',')}}[${found.n}]`;
                        } catch (e) { return ''; }
                    };

                    // --- PHẦN THAY ĐỔI ĐỂ TẠO FILE XLSX CHUẨN ---

                    // 4. Chuẩn bị mảng dữ liệu (AOA - Array of Arrays)
                    const excelData = [['date', 'result', 'rule']]; // Header dòng 1

                    for (let i = 0; i < (Array.isArray(data) ? data.length : 0); i++) {
                        try {
                            const obj = data[i] || {};
                            const dateVal = obj.date || obj.Date || '';
                            const resultVal = obj.Result || obj.result || '';
                            const nums = (resultVal || '').split(/\s*,\s*/).map(s => parseInt(s, 10)).filter(Number.isFinite);
                            const rule = (nums.length === 6) ? computeRule(nums) : '';

                            // Thêm dòng dữ liệu vào mảng thay vì cộng chuỗi XML
                            excelData.push([dateVal, resultVal, rule]);
                        } catch (e) { }
                    }

                    // 5. Sử dụng thư viện XLSX để xuất file
                    // Đảm bảo `XLSX` đã được nạp (runtime fallback nếu CDN không load trước)
                    if (typeof XLSX === 'undefined') {
                        await new Promise((resolve) => {
                            const s = document.createElement('script');
                            s.src = 'https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js';
                            s.onload = () => { console.info('Loaded XLSX at runtime'); resolve(); };
                            s.onerror = () => { console.error('Failed to load XLSX library'); resolve(); };
                            document.head.appendChild(s);
                        });
                    }
                    if (typeof XLSX === 'undefined') {
                        alert('Không thể tải thư viện XLSX; không thể xuất file .xlsx.');
                        return;
                    }
                    // Tạo một worksheet từ mảng dữ liệu
                    const ws = XLSX.utils.aoa_to_sheet(excelData);
                    // Tạo một workbook mới
                    const wb = XLSX.utils.book_new();
                    // Thêm worksheet vào workbook với tên "Rules"
                    XLSX.utils.book_append_sheet(wb, ws, "Rules");

                    // 6. Kích hoạt tải về file chuẩn định dạng .xlsx
                    XLSX.writeFile(wb, 'rule.xlsx');

                } catch (e) {
                    console.error("Export Error:", e);
                    try { ev.target.animate([{ transform: 'translateY(-4px)' }, { transform: 'translateY(0px)' }], { duration: 180 }); } catch (er) { }
                    alert('Lỗi khi xuất file. Xem console để biết chi tiết.');
                }
            });


            controls.append("Số x:", xContainer, typeof focusPrevBtn !== 'undefined' ? focusPrevBtn : document.createElement('span'), typeof focusNextBtn !== 'undefined' ? focusNextBtn : document.createElement('span'), comboExtras, (body && body.__xSelWrapper) ? body.__xSelWrapper : xSel, consecLabel, orderLabel, "Trash:", trashSel, "Fav:", favSel, unpairInputs, unpairInfo, numTrashLabel, optLabel, sortSel, recencySel, ruleBtn);
            // wire numTrash input to trigger recompute when changed
            try { numTrashInput.addEventListener('input', () => { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); }); } catch (e) { }
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);

            let groupCache = null;
            let cacheKey = null;
            // baseline (after main-x filter but before trash exclude) — keys preserved for stable rank
            let baselineArrAll = null;
            // global baseline (before applying main x filter) used to show overall rank
            let baselineArrGlobal = null;
            // map of original occurrence counts per key (computed before trash/exclude)
            let baselineCountsMap = null;
            // helper arrays of keys for quick rank lookups
            let baselineAllKeys = null;
            let baselineGlobalKeys = null;
            // --- Optimization: compute which unpair row when dragged-out (its dontmatch numbers
            // added to trash) would maximize the number of rows whose `dontmatch` lists are
            // fully present in the trash (i.e., rows that become green). When the user
            // checks the `optChk` checkbox we perform the computation and dispatch
            // a `moveMultipleToTrash` for the chosen row's numbers. Unchecking restores.
            function clearOptimizeUI() {
                try {
                    const prev = wrap.querySelectorAll('[data-optimal]');
                    prev.forEach(el => {
                        try { el.removeAttribute('data-optimal'); el.style.boxShadow = ''; el.style.outline = ''; } catch (e) { }
                    });
                    const prevTd = wrap.querySelectorAll('.optimal-dontmatch');
                    prevTd.forEach(td => { try { td.classList.remove('optimal-dontmatch'); td.style.background = ''; td.style.borderColor = ''; } catch (e) { } });
                    try { window.__optCandidateNums = null; } catch (e) { }
                } catch (e) { }
            }

            async function computeOptimize(force = false) {
                try {
                    clearOptimizeUI();
                    if (!force && (!optChk || !optChk.checked)) return;
                    const currentTrash = (typeof window.getTrashItems === 'function') ? (window.getTrashItems() || []) : (window.__trashItems || []);
                    const baseSet = new Set((currentTrash || []).map(n => Number(n)));
                    const tbl = wrap.querySelector('table');
                    if (!tbl) return;
                    const rowsDom = Array.from(tbl.querySelectorAll('tbody tr'));
                    if (!rowsDom.length) return;
                    const parsed = rowsDom.map(tr => {
                        try {
                            const dontTd = tr.children && tr.children[1] ? tr.children[1] : null;
                            const raw = dontTd ? (dontTd.textContent || '').trim() : '';
                            const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                            return { tr, nums };
                        } catch (e) { return { tr, nums: [] }; }
                    });

                    let best = null;
                    let bestCount = -1;
                    for (const cand of parsed) {
                        try {
                            const candSet = new Set(baseSet);
                            cand.nums.forEach(n => { if (Number.isFinite(n)) candSet.add(Number(n)); });
                            const optMode = (typeof optSel !== 'undefined' && optSel && optSel.value) ? String(optSel.value) : 'green';
                            let cnt = 0;
                            if (optMode === 'green') {
                                for (const p of parsed) {
                                    try {
                                        const others = p.nums || [];
                                        if (!others || others.length === 0) continue;
                                        let mainNum = null;
                                        try {
                                            const numTd = p.tr.children && p.tr.children[0] ? p.tr.children[0] : null;
                                            const rawNum = numTd ? (numTd.textContent || '').trim() : '';
                                            mainNum = Number(rawNum);
                                        } catch (e) { mainNum = null; }
                                        if (Number.isFinite(mainNum) && candSet.has(Number(mainNum))) continue;
                                        let ok = true;
                                        for (const o of others) if (!candSet.has(Number(o))) { ok = false; break; }
                                        if (ok) cnt++;
                                    } catch (e) { }
                                }
                            } else if (optMode === 'red') {
                                for (const p of parsed) {
                                    try {
                                        let mainNum = null;
                                        try {
                                            const numTd = p.tr.children && p.tr.children[0] ? p.tr.children[0] : null;
                                            const rawNum = numTd ? (numTd.textContent || '').trim() : '';
                                            mainNum = Number(rawNum);
                                        } catch (e) { mainNum = null; }
                                        if (Number.isFinite(mainNum) && candSet.has(Number(mainNum))) cnt++;
                                    } catch (e) { }
                                }
                            }
                            if (cnt > bestCount) { bestCount = cnt; best = cand; }
                        } catch (e) { }
                    }

                    if (best && best.nums && best.nums.length) {
                        try {
                            const uniq = Array.from(new Set(best.nums.map(n => Number(n)).filter(n => Number.isFinite(n)))).sort((a, b) => a - b);
                            if (uniq.length) {
                                try { window.__optAddedToTrash = uniq.slice(); } catch (e) { window.__optAddedToTrash = uniq.slice(); }
                                try { window.__optCandidateNums = uniq.slice(); } catch (e) { window.__optCandidateNums = uniq.slice(); }

                                const applyStylingAfterTrash = () => {
                                    try {
                                        clearOptimizeUI();
                                        const tblNow = wrap.querySelector('table');
                                        if (!tblNow) return;
                                        const rowsNow = Array.from(tblNow.querySelectorAll('tbody tr'));
                                        const targetSet = new Set((window.__optCandidateNums || []).map(n => Number(n)));
                                        for (const tr of rowsNow) {
                                            try {
                                                const dontTd = tr.children && tr.children[1] ? tr.children[1] : null;
                                                const raw = dontTd ? (dontTd.textContent || '').trim() : '';
                                                const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                                                const s = new Set(nums.map(n => Number(n)));
                                                if (s.size === targetSet.size) {
                                                    let eq = true;
                                                    for (const v of s) if (!targetSet.has(v)) { eq = false; break; }
                                                    if (eq) {
                                                        try { tr.setAttribute('data-optimal', '1'); tr.style.outline = '3px solid rgba(102,126,234,0.25)'; tr.style.boxShadow = '0 6px 18px rgba(102,126,234,0.12)'; }
                                                        catch (e) { }
                                                        const dontTdNow = tr.children && tr.children[1] ? tr.children[1] : null;
                                                        if (dontTdNow) { try { dontTdNow.classList.add('optimal-dontmatch'); dontTdNow.style.background = 'rgba(102,126,234,0.06)'; dontTdNow.style.borderColor = 'var(--accent-2)'; } catch (e) { } }
                                                        break;
                                                    }
                                                }
                                            } catch (e) { }
                                        }
                                    } catch (e) { }
                                };

                                const once = () => { try { applyStylingAfterTrash(); } catch (e) { } finally { try { document.removeEventListener('trashupdated', once); } catch (er) { } } };
                                try { document.addEventListener('trashupdated', once); } catch (e) { setTimeout(() => { try { applyStylingAfterTrash(); } catch (er) { } }, 120); }

                                try { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: uniq }, bubbles: true, composed: true })); }
                                catch (e) { }
                            }
                        } catch (e) { }
                    }
                } catch (e) { }
            }

            try {
                if (optChk) {
                    optChk.addEventListener('change', (e) => {
                        try {
                            try { if (typeof optSel !== 'undefined') optSel.disabled = !optChk.checked; } catch (e) { }
                            if (!optChk.checked) {
                                try {
                                    // emulate pressing the trash popup "Xóa" button so behavior is identical
                                    const clearBtn = document.getElementById('trashClearBtn') || (typeof trashPopup !== 'undefined' && trashPopup ? trashPopup.querySelector('#trashClearBtn') : null);
                                    if (clearBtn) {
                                        try { clearBtn.click(); } catch (err) { try { clearBtn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true })); } catch (e) { } }
                                    }
                                } catch (e) { }
                                return;
                            } else {
                                // When in Unpair mode, the optimizer must replace the trash contents
                                // instead of unioning with existing items. Clear trash first so the
                                // compute+moveMultipleToTrash operate on a clean state.
                                try {
                                    const isUnpair = (controls && controls.classList && controls.classList.contains('unpair-mode'));
                                    if (isUnpair) {
                                        try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }
                                    }
                                } catch (e) { }
                                computeOptimize();
                            }
                        } catch (err) { }
                    });

                    try {
                        if (typeof optSel !== 'undefined') {
                            try { optSel._prevMode = String(optSel.value || 'green'); } catch (e) { optSel._prevMode = 'green'; }
                            optSel.addEventListener('change', () => {
                                try {
                                    const prev = String(optSel._prevMode || 'green');
                                    const curr = String(optSel.value || 'green');
                                    if (prev !== curr) {
                                        try {
                                            // Ensure trash is cleared/rendered before computing when mode changes
                                            try {
                                                const isUnpair = (controls && controls.classList && controls.classList.contains('unpair-mode'));
                                                if (isUnpair) {
                                                    try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }
                                                }
                                            } catch (e) { }
                                            // Compute immediately after ensuring trash UI updated
                                            try { computeOptimize(true); } catch (e) { }
                                        } catch (ee) { try { setTimeout(() => { try { computeOptimize(true); } catch (er) { } }, 80); } catch (er) { } }
                                    } else {
                                        try { computeOptimize(true); } catch (e) { }
                                    }
                                    optSel._prevMode = curr;
                                } catch (e) { }
                            });
                        }
                    } catch (e) { }

                    try { document.addEventListener('trashupdated', () => { try { if (optChk && optChk.checked) computeOptimize(); } catch (e) { } }); } catch (e) { }
                }
            } catch (e) { }
            let isComputing = false;

            // Mode switching: if the header-inserted selector exists, wire it to show/hide
            try {
                const modeSel = body && body.__modeSel ? body.__modeSel : null;
                const lkControls = body && body.__lkControls ? body.__lkControls : null;
                const lkTopInput = body && body.__lkTopInput ? body.__lkTopInput : null;
                const lkSetSel = body && body.__lkSetSel ? body.__lkSetSel : null;
                if (modeSel) {
                    const switchToTruy = () => {
                        controls.style.display = '';
                        try { controls.classList.remove('unpair-mode'); } catch (e) { }
                        try { numTrashLabel.style.display = 'none'; } catch (e) { }
                        try { controls.querySelectorAll('.numtrash-wrapper').forEach(n => { try { n.style.display = 'none'; } catch (e) { } }); } catch (e) { }
                        // ensure trash selector returns to a non-unpair value so group() doesn't
                        // accidentally re-enter the unpair rendering branch
                        try { if (trashSel) trashSel.value = 'include'; } catch (e) { }
                        try { if (typeof updateTrashModeUI === 'function') updateTrashModeUI('include'); } catch (e) { }
                        try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        if (lkControls) lkControls.style.display = 'none';
                        // clear any lienket output
                        try { wrap.innerHTML = ''; } catch (e) { }
                        groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null;
                        // re-run group to show Truy x UI
                        try { group(); } catch (e) { }
                    };
                    const switchToLienKet = () => {
                        controls.style.display = 'none';
                        if (lkControls) lkControls.style.display = 'flex';
                        // clear existing Truy x tables and caches
                        try { wrap.innerHTML = ''; } catch (e) { }
                        groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null;
                        // immediately compute lien ket using retained input values
                        try { if (typeof computeLienKet === 'function') computeLienKet(); } catch (e) { /* ignore */ }
                    };
                    modeSel.addEventListener('change', (ev) => {
                        const v = String(modeSel.value || 'truy');
                        if (v === 'lienket') switchToLienKet();
                        else if (v === 'unpair') {
                            // Do not set `trashSel.value` to 'unpair' because the
                            // Cell6.5 inline trash dropdown only supports include/exclude.
                            // Toggle UI and re-run the group computation in unpair mode.
                            try { if (typeof updateTrashModeUI === 'function') updateTrashModeUI('unpair'); } catch (e) { }
                            try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                            try { if (typeof debouncedGroup === 'function') debouncedGroup(); else group(); } catch (e) { }
                        } else switchToTruy();
                    });

                    // compute function for Liên kết x: take top-N combos of chosen bộ, aggregate number frequencies
                    function computeLienKet() {
                        if (!rows || !rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                        const topN = Math.max(1, parseInt(String(lkTopInput.value || '').trim(), 10) || 30);
                        const comb = Math.max(1, parseInt(String(lkSetSel.value || '2'), 10) || 2);
                        const groups = new Map();
                        rows.forEach((r, rowIndex) => {
                            const nums = r.nums;
                            // generate combos of size `comb` (order-insensitive)
                            const indexed = nums.map((v, i) => [i, v]);
                            const combos = kCombinations(indexed, comb);
                            combos.forEach(combo => {
                                const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                const key = values.join("-");
                                if (!groups.has(key)) groups.set(key, new Set());
                                groups.get(key).add(rowIndex);
                            });
                        });
                        let arr = [...groups.entries()].map(([key, set]) => [key, [...set]]);
                        // attach recency (most recent rowIndex) to stabilize ties
                        const arrWithRecency = arr.map(([key, idxs]) => [key, idxs, Math.max(...idxs)]);
                        // sort by occurrence count desc, then lexical key (stable)
                        arrWithRecency.sort((A, B) => {
                            const cntDiff = B[1].length - A[1].length;
                            if (cntDiff !== 0) return cntDiff;
                            return compareKey(A[0], B[0]);
                        });
                        const topEntries = arrWithRecency.slice(0, Math.max(0, Math.min(arrWithRecency.length, topN))).map(a => [a[0], a[1]]);
                        // aggregate number frequencies across the selected top entries
                        const freq = Object.create(null);
                        topEntries.forEach(([key]) => {
                            key.split('-').map(Number).forEach(n => { freq[n] = (freq[n] || 0) + 1; });
                        });
                        // Also prepare a human-readable compact listing of chosen top combos (no rows)
                        const topList = topEntries.map(([key, idxs]) => ({ key, count: idxs.length }));
                        // invert: count -> [numbers]
                        const inv = Object.create(null);
                        Object.keys(freq).forEach(k => {
                            const c = freq[k];
                            if (!inv[c]) inv[c] = [];
                            inv[c].push(Number(k));
                        });
                        const counts = Object.keys(inv).map(Number).sort((a, b) => b - a);
                        // build output grouped by occurrence count
                        let out = `<div style='margin-top:8px;'><div class='card'><div class='card-body'>`;
                        if (topEntries.length === 0) out += `<div class='muted'>Không tìm thấy bộ nào</div>`;
                        // show selected top combos compactly (key (count)), arranged N-per-line to reduce vertical space
                        out += `<div style='margin-bottom:8px;font-weight:700'>Top ${topN} bộ (key · số kỳ) — danh sách đã chọn:</div>`;
                        const perLine = 5;
                        for (let i = 0; i < topList.length; i += perLine) {
                            const slice = topList.slice(i, i + perLine).map(t => `<div class="lk-item">{<strong>${t.key.replace(/-/g, ', ')}</strong>} (${t.count})</div>`);
                            out += `<div class="lk-row" style="display:grid;grid-template-columns:repeat(${perLine},1fr);gap:8px;font-family:monospace;margin-left:6px;text-align:left">${slice.join('')}</div>`;
                        }
                        // compute numbers 1..45 that did not appear in the selected top combos
                        const allNums = Array.from({ length: 45 }, (_, i) => i + 1);
                        const present = new Set(Object.keys(freq).map(Number));
                        const missing = allNums.filter(n => !present.has(n));
                        if (missing.length > 0) {
                            const missingHtml = missing.map(n => `<strong style="color:#ff1744">${n}</strong>`).join(', ');
                            out += `<div style='margin-bottom:8px;font-weight:700'>không có ${missing.length} số: ${missingHtml}</div>`;
                        } else {
                            out += `<div style='margin-bottom:8px;font-weight:700' class='muted'>Tất cả số đều xuất hiện</div>`;
                        }
                        out += `<hr style='margin:8px 0'/>`;
                        counts.forEach(c => {
                            const nums = (inv[c] || []).sort((a, b) => a - b);
                            const numsHtml = nums.map(n => `<strong style="color:var(--accent)">${n}</strong>`).join(', ');
                            // add a per-row ⏭ button (data-nums contains comma-separated numbers)
                            out += `<div class='lk-count-row' data-nums='${nums.join(',')}' style='margin-bottom:6px;'>` +
                                `<span class='lk-count-text'>${numsHtml}: Xuất hiện ${c} lần.</span>` +
                                `<button type='button' class='lienket-prev-btn' data-nums='${nums.join(',')}'>⏮</button>` +
                                `<button type='button' class='lienket-next-btn' data-nums='${nums.join(',')}'>⏭</button>` +
                                `</div>`;
                        });
                        out += `</div></div></div>`;
                        wrap.innerHTML = out;
                        // Post-render: wire up per-row buttons to cycle-highlight numbers inside the Top list
                        try {
                            const strongs = Array.from(wrap.querySelectorAll('.lk-item strong'));
                            // store original text so we can restore later
                            strongs.forEach(s => { try { s.dataset.orig = s.textContent; } catch (e) { s.dataset.orig = s.innerText || ''; } });

                            // Wire up per-button handlers so each button cycles independently (restore original next behavior)
                            const nextButtons = Array.from(wrap.querySelectorAll('.lienket-next-btn'));
                            const prevButtons = Array.from(wrap.querySelectorAll('.lienket-prev-btn'));

                            nextButtons.forEach(btn => {
                                // use a shared index on the parent row so prev/next stay in sync
                                const row = btn.closest('.lk-count-row');
                                if (row && typeof row._idx === 'undefined') row._idx = -1;
                                btn.addEventListener('click', (e) => {
                                    try { e.preventDefault(); } catch (er) { }
                                    e.stopPropagation();
                                    const numsArr = String(btn.dataset.nums || '').split(',').map(s => s.trim()).filter(s => s !== '');
                                    if (!numsArr.length) return;
                                    const scrollTop = window.scrollY || document.documentElement.scrollTop || (document.scrollingElement && document.scrollingElement.scrollTop) || 0;
                                    const scrollLeft = window.scrollX || document.documentElement.scrollLeft || (document.scrollingElement && document.scrollingElement.scrollLeft) || 0;
                                    const prevActive = document.activeElement;

                                    // advance the shared row index
                                    if (row) row._idx = (Number(row._idx) + 1) % numsArr.length;
                                    const curr = row ? numsArr[row._idx] : numsArr[(0 + 1) % numsArr.length];

                                    strongs.forEach(s => { s.innerHTML = s.dataset.orig; });
                                    strongs.forEach(s => {
                                        const arr = String(s.dataset.orig || '').split(/\s*,\s*/);
                                        if (arr.includes(String(curr))) {
                                            s.innerHTML = arr.map(p => p === String(curr)
                                                ? `<span class='lienket-highlight' style='background:yellow;color:#000;padding:0 2px;border-radius:3px'>${p}</span>`
                                                : p
                                            ).join(', ');
                                        }
                                    });

                                    setTimeout(() => {
                                        try { window.scrollTo({ top: scrollTop, left: scrollLeft, behavior: 'auto' }); } catch (er) {
                                            try { if (document.scrollingElement) document.scrollingElement.scrollTop = scrollTop; } catch (e) { }
                                        }
                                        try { if (prevActive && typeof prevActive.focus === 'function') prevActive.focus(); } catch (e) { }
                                    }, 8);
                                });
                            });

                            prevButtons.forEach(btn => {
                                // use the same shared row index used by nextButtons
                                const row = btn.closest('.lk-count-row');
                                if (row && typeof row._idx === 'undefined') row._idx = 0;
                                btn.addEventListener('click', (e) => {
                                    try { e.preventDefault(); } catch (er) { }
                                    e.stopPropagation();
                                    const numsArr = String(btn.dataset.nums || '').split(',').map(s => s.trim()).filter(s => s !== '');
                                    if (!numsArr.length) return;
                                    const scrollTop = window.scrollY || document.documentElement.scrollTop || (document.scrollingElement && document.scrollingElement.scrollTop) || 0;
                                    const scrollLeft = window.scrollX || document.documentElement.scrollLeft || (document.scrollingElement && document.scrollingElement.scrollLeft) || 0;
                                    const prevActive = document.activeElement;

                                    // move the shared row index backward
                                    if (row) row._idx = (Number(row._idx) - 1 + numsArr.length) % numsArr.length;
                                    const curr = row ? numsArr[row._idx] : numsArr[(0 - 1 + numsArr.length) % numsArr.length];

                                    strongs.forEach(s => { s.innerHTML = s.dataset.orig; });
                                    strongs.forEach(s => {
                                        const arr = String(s.dataset.orig || '').split(/\s*,\s*/);
                                        if (arr.includes(String(curr))) {
                                            s.innerHTML = arr.map(p => p === String(curr)
                                                ? `<span class='lienket-highlight' style='background:yellow;color:#000;padding:0 2px;border-radius:3px'>${p}</span>`
                                                : p
                                            ).join(', ');
                                        }
                                    });

                                    setTimeout(() => {
                                        try { window.scrollTo({ top: scrollTop, left: scrollLeft, behavior: 'auto' }); } catch (er) {
                                            try { if (document.scrollingElement) document.scrollingElement.scrollTop = scrollTop; } catch (e) { }
                                        }
                                        try { if (prevActive && typeof prevActive.focus === 'function') prevActive.focus(); } catch (e) { }
                                    }, 8);
                                });
                            });
                        } catch (err) { /* ignore wiring errors */ }
                    }

                    // Auto-run compute on input/change with light debounce
                    const debouncedCompute = (typeof createDebounce === 'function') ? createDebounce(computeLienKet, 200) : computeLienKet;
                    if (lkTopInput) lkTopInput.addEventListener('input', debouncedCompute);
                    if (lkSetSel) lkSetSel.addEventListener('change', debouncedCompute);
                }
            } catch (e) { /* ignore */ }

            function group() {
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }

                // include extra combo inputs values in cache key so changing them invalidates cache
                const extraValsKey = (() => {
                    const inputs = comboExtras.querySelectorAll('input[type="number"].combo-extra');
                    return Array.from(inputs).map(i => (i.value ?? '').trim()).join(',');
                })();
                // Prefer Cell6.6's trash selector when present so the two cells stay in sync.
                let externalTrashEl = null;
                try { externalTrashEl = document.getElementById('cell6_6_trashSel'); } catch (e) { externalTrashEl = null; }
                const trashValue = (externalTrashEl && externalTrashEl.value) ? externalTrashEl.value : (trashSel && trashSel.value ? String(trashSel.value) : 'include');
                const newCacheKey = `${xSel.value}|${consec.checked}|${order.checked}|${sortSel.value}|${xFilter.value}|${extraValsKey}|${trashValue}|${recencySel ? recencySel.value : ''}`;
                if (cacheKey === newCacheKey && groupCache) {
                    renderGroupTable(groupCache);
                    return;
                }

                // Special 'unpair' mode: build per-number list of other numbers
                // that appear least often when paired with the given number.
                // Uses `numTrashInput` as the number of items to return (1..44).
                // Unpair may be indicated either by the trash selector (external)
                // or by the controls being put into `.unpair-mode` by the header.
                if (String(trashValue) === 'unpair' || (controls && controls.classList && controls.classList.contains('unpair-mode'))) {
                    // validate num
                    let n = 16;
                    try { n = Math.max(1, Math.min(44, parseInt(String(numTrashInput.value || '').trim(), 10) || 16)); } catch (e) { n = 16; }

                    // build pair counts
                    const pairCounts = new Map();
                    try {
                        rows.forEach(r => {
                            try {
                                const nums = Array.isArray(r.nums) ? r.nums.slice().sort((a, b) => a - b) : [];
                                for (let i = 0; i < nums.length; i++) {
                                    for (let j = i + 1; j < nums.length; j++) {
                                        const a = nums[i], b = nums[j];
                                        const key = `${a}-${b}`;
                                        pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
                                    }
                                }
                            } catch (e) { }
                        });
                    } catch (e) { }

                    // build table html
                    let html = "<div class='muted header-summary' style='flex-basis:100%;margin-bottom:8px'>Unpair — trả về các số ít gặp khi ghép với x</div>";
                    html += "<div class='grid-centered'><table class='table'><thead><tr><th>num</th><th>dontmatch</th></tr></thead><tbody>";
                    for (let xnum = 1; xnum <= 45; xnum++) {
                        const others = [];
                        for (let y = 1; y <= 45; y++) {
                            if (y === xnum) continue;
                            const a = Math.min(xnum, y), b = Math.max(xnum, y);
                            const key = `${a}-${b}`;
                            const c = pairCounts.get(key) || 0;
                            others.push({ y, c });
                        }
                        // sort ascending by count (least frequent first), tie-breaker by numeric
                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                        const pick = others.slice(0, n).map(o => String(o.y)).join(',');
                        html += `<tr><td>${xnum}</td><td>${pick}</td></tr>`;
                    }
                    html += "</tbody></table></div>";
                    try { wrap.innerHTML = html; } catch (e) { }
                    try {
                        // Attach drag handlers to each unpair table row so users can drag
                        // a row out to add its `dontmatch` numbers into the trash popup.
                        const tbl = wrap.querySelector('table');
                        if (tbl) {
                            const tbody = tbl.querySelector('tbody');
                            if (tbody) {
                                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                    try {
                                        tr.draggable = true;
                                        tr.addEventListener('dragstart', (e) => {
                                            try {
                                                const dontTd = tr.children && tr.children[1] ? tr.children[1] : null;
                                                const raw = dontTd ? (dontTd.textContent || '').trim() : '';
                                                const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                                                // compute a stable key for this row (sorted unique numbers)
                                                const key = Array.from(new Set(nums.map(n => Number(n)).filter(Number.isFinite))).sort((a, b) => a - b).join(',');
                                                // support toggle: consult persistent set rather than transient DOM class
                                                try { window.__draggedUnpairRowKeys = window.__draggedUnpairRowKeys || new Set(); } catch (e) { window.__draggedUnpairRowKeys = new Set(); }
                                                const action = window.__draggedUnpairRowKeys.has(key) ? 'restore' : 'add';
                                                window.__draggingUnpair = { nums: nums.slice(), tr: tr, handled: false, action, key };
                                                // visually mark the row as being dragged out
                                                try { tr.classList.add('dragging-out'); } catch (er) { }
                                                try { e.dataTransfer.setData('application/x-nums', JSON.stringify(nums)); } catch (err) { e.dataTransfer.setData('text/plain', (nums || []).join(',')); }
                                                try { e.dataTransfer.setData('source', 'cell6_5_unpair'); } catch (err) { }
                                                try { e.dataTransfer.effectAllowed = 'copyMove'; } catch (err) { }
                                            } catch (err) { }
                                        });

                                        // Hover behavior: when number-picker popup is hovered and
                                        // we're in Unpair mode, temporarily replace trash with
                                        // this row's `dontmatch` numbers. Restore on leave.
                                        tr.addEventListener('mouseenter', (ev) => {
                                            try {
                                                const popup = document.getElementById('numberPickerPopup');
                                                if (!popup) return;
                                                // active when the popup is visible (open) or hovered
                                                const popupVisible = popup && (popup.style.display === 'block' || popup.classList.contains('show'));
                                                if (!popupVisible && !popup.matches(':hover')) return;
                                                // Respect quick-place mode: only act when user selected 'hover'
                                                const quickPlaceMode = (window.getQuickPlaceMode && typeof window.getQuickPlaceMode === 'function') ? window.getQuickPlaceMode() : (localStorage.getItem('quickPlaceMode') || 'normal');
                                                if (quickPlaceMode !== 'hover') return;
                                                // only in unpair mode controls
                                                if (!(controls && controls.classList && controls.classList.contains('unpair-mode'))) return;
                                                // Remember hovered num so w/s numtrash re-apply works after re-render
                                                try { window.__lastHoveredUnpairNum = parseInt((tr.children[0] || {}).textContent || '', 10) || null; } catch (e) { }
                                                // Temporarily add candidate (num) to fav so popup shows yellow highlight
                                                try {
                                                    const __hovCand = window.__lastHoveredUnpairNum;
                                                    if (__hovCand && typeof window.addToFav === 'function') {
                                                        // remove previous hover-fav candidate if different
                                                        const __prevHovFav = window.__cell6_5_hoverFavCand || null;
                                                        if (__prevHovFav !== null && __prevHovFav !== __hovCand && typeof window.removeFromFav === 'function') {
                                                            window.removeFromFav(__prevHovFav);
                                                        }
                                                        window.addToFav(__hovCand);
                                                        window.__cell6_5_hoverFavCand = __hovCand;
                                                    }
                                                } catch (e) { }
                                                const dontTd = tr.children && tr.children[1] ? tr.children[1] : null;
                                                const raw = dontTd ? (dontTd.textContent || '').trim() : '';
                                                const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                                                const uniq = Array.from(new Set(nums.map(n => Number(n)).filter(Number.isFinite)));

                                                // save previous trash once per hover session (use shared global array when available)
                                                try {
                                                    const gTrash = (window.__trashItems && Array.isArray(window.__trashItems)) ? window.__trashItems : null;
                                                    if (!window.__hoverPrevTrash) {
                                                        try { window.__hoverPrevTrash = Array.isArray(gTrash) ? gTrash.slice() : (window.getTrashItems ? window.getTrashItems() : []); } catch (e) { window.__hoverPrevTrash = []; }
                                                    }
                                                    window.__hoverActive = true;

                                                    // Replace current trash with the hovered set (clear then add)
                                                    try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }
                                                    // Now add hovered numbers into trash via documented event
                                                    try { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: uniq }, bubbles: true, composed: true })); } catch (e) { }
                                                } catch (e) { }

                                                // update in-popup cell visuals
                                                try {
                                                    const pickerTable = document.getElementById('numberPickerTable');
                                                    if (pickerTable) {
                                                        const prev = pickerTable.querySelectorAll('td.in-trash');
                                                        prev.forEach(c => { try { c.classList.remove('in-trash'); c.classList.remove('in-trash-dim'); } catch (e) { } });
                                                        const __plVH = (window.getPlaceValues ? window.getPlaceValues() : []).map(Number);
                                                        uniq.forEach(n => {
                                                            try { const src = pickerTable.querySelector('td[data-number="' + n + '"]'); if (src) { src.classList.add('in-trash'); if (__plVH.includes(Number(n))) src.classList.add('in-trash-dim'); } } catch (e) { }
                                                        });
                                                    }
                                                } catch (e) { }

                                                try { renderTrash(); } catch (e) { }
                                                try { (document.getElementById('trashPopup') || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                                            } catch (e) { }
                                        });

                                        tr.addEventListener('mouseleave', (ev) => {
                                            try {
                                                if (!window.__hoverActive) return;
                                                const related = ev.relatedTarget;
                                                // if moving to another row in same table, don't restore yet
                                                if (related && related.closest && related.closest('#cell6_5 table tbody')) return;

                                                // If moving out to empty space (not another row), keep the
                                                // last-hovered numbers in trash instead of restoring the old set.
                                                // We simply mark hover as inactive and leave the current trash state.
                                                try { window.__hoverActive = false; } catch (e) { }
                                                // NOTE: `window.__hoverPrevTrash` intentionally preserved so
                                                // the original pre-hover state remains available if needed.
                                                // Remove temporary hover-fav candidate
                                                try {
                                                    const __hfc = window.__cell6_5_hoverFavCand;
                                                    if (__hfc != null && typeof window.removeFromFav === 'function') {
                                                        window.removeFromFav(__hfc);
                                                        window.__cell6_5_hoverFavCand = null;
                                                    }
                                                } catch (e) { }
                                            } catch (e) { }
                                        });

                                        tr.addEventListener('dragend', (e) => {
                                            try {
                                                // `trashToggle` element removed; trash is always on.
                                                const trashIsOn = true;
                                                const state = window.__draggingUnpair || null;
                                                let addedToTrash = false;
                                                let restoredFromTrash = false;

                                                if (state && Array.isArray(state.nums) && state.nums.length) {
                                                    const uniq = Array.from(new Set(state.nums.map(n => Number(n)).filter(Number.isFinite)));
                                                    if (state.action === 'restore') {
                                                        // restore each number from trash (toggle off)
                                                        try {
                                                            document.dispatchEvent(new CustomEvent('restoreMultipleFromTrash', { detail: { nums: uniq }, bubbles: true, composed: true }));
                                                            restoredFromTrash = true;
                                                            // remove persistent key tracking so future drags act as add
                                                            try { if (state.key) window.__draggedUnpairRowKeys.delete(state.key); } catch (e) { }
                                                            // remove dragged-out class from any matching rows in DOM
                                                            try { toggleDraggedOutForKey(state.key, false); } catch (e) { }
                                                        } catch (err) { }
                                                    } else {
                                                        // default behavior: if not handled by a drop target and trash is on,
                                                        // add numbers to trash (union semantics)
                                                        if (!state.handled && trashIsOn && uniq.length) {
                                                            try {
                                                                document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: uniq }, bubbles: true, composed: true }));
                                                                addedToTrash = true;
                                                                // mark row key as dragged-out so subsequent drags toggle
                                                                try { if (state.key) window.__draggedUnpairRowKeys.add(state.key); } catch (e) { }
                                                                try { toggleDraggedOutForKey(state.key, true); } catch (e) { }
                                                            } catch (err) { }
                                                        }
                                                    }
                                                }

                                                // remove transient dragging class
                                                try { tr.classList.remove('dragging-out'); } catch (er) { }

                                                // if the drop was handled (or we added via fallback) mark row dragged-out
                                                if ((state && state.handled) || addedToTrash) {
                                                    try { tr.classList.add('dragged-out'); } catch (er) { }
                                                }

                                                // if we restored from trash, remove the dragged-out marker
                                                if (restoredFromTrash) {
                                                    try { tr.classList.remove('dragged-out'); } catch (er) { }
                                                }

                                                try { window.__draggingUnpair = null; } catch (e) { }
                                            } catch (err) { }
                                        });
                                    } catch (e) { }
                                });
                            }
                        }
                    } catch (e) { }
                    // After unpair re-render, re-apply hover state for last-hovered num
                    // so w/s (numtrash +/-) updates trash for the same num
                    try {
                        if (window.__lastHoveredUnpairNum) {
                            const targetNum = window.__lastHoveredUnpairNum;
                            const tbody = wrap.querySelector('table tbody');
                            if (tbody) {
                                const targetRow = Array.from(tbody.querySelectorAll('tr')).find(r => {
                                    return r.children[0] && parseInt(r.children[0].textContent, 10) === targetNum;
                                });
                                if (targetRow) {
                                    const dTd = targetRow.children[1];
                                    const dRaw = dTd ? dTd.textContent.trim() : '';
                                    const dNums = dRaw ? dRaw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                                    const dUniq = Array.from(new Set(dNums));
                                    // Clear trash
                                    try { if (typeof window.clearAllTrash === 'function') window.clearAllTrash(); } catch (e) { }
                                    // Add dontmatch to trash
                                    if (dUniq.length) {
                                        try { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: dUniq }, bubbles: true, composed: true })); } catch (e) { }
                                    }
                                    // Update picker table visuals directly (safety net)
                                    try {
                                        const pt = document.getElementById('numberPickerTable');
                                        if (pt) {
                                            pt.querySelectorAll('td.in-trash').forEach(c => { c.classList.remove('in-trash'); c.classList.remove('in-trash-dim'); });
                                            const __plV = (window.getPlaceValues ? window.getPlaceValues() : []).map(Number);
                                            dUniq.forEach(dn => { try { const td = pt.querySelector('td[data-number="' + dn + '"]'); if (td) { td.classList.add('in-trash'); if (__plV.includes(dn)) td.classList.add('in-trash-dim'); } } catch (e) { } });
                                        }
                                    } catch (e) { }
                                    try { renderTrash(); } catch (e) { }
                                    try { (document.getElementById('trashPopup') || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                                    // Green highlight on num cell
                                    try { targetRow.children[0].classList.add('cell6-num-highlight'); } catch (e) { }
                                    // Add candidate to fav so popup shows yellow
                                    try {
                                        if (typeof window.addToFav === 'function') {
                                            const __prevHF = window.__cell6_5_hoverFavCand;
                                            if (__prevHF != null && __prevHF !== targetNum && typeof window.removeFromFav === 'function') window.removeFromFav(__prevHF);
                                            window.addToFav(targetNum);
                                            window.__cell6_5_hoverFavCand = targetNum;
                                        }
                                    } catch (e) { }
                                    // Scroll to row
                                    try { requestAnimationFrame(() => { try { targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { } }); } catch (e) { }
                                }
                            }
                        }
                    } catch (e) { }
                    isComputing = false;
                    // don't continue normal flow
                    return;
                }

                if (isComputing) return;
                isComputing = true;
                wrap.innerHTML = "<div class='loader'>Đang xử lý (trên background thread)...</div>";

                const x = parseInt(xSel.value, 10);

                // Defer heavy work slightly so the loader can paint.
                // For small x or consecutive mode use quick path. For moderate x (7..12)
                // we still try the quick pairing heuristic. For larger requested group
                // sizes (13+), fallback to the worker-based computation which can handle larger unions.
                setTimeout(() => {
                    try {
                        if (x <= 2 || consec.checked || (x > 6 && x <= 12)) {
                            computeQuick();
                        } else {
                            computeWithWorker();
                        }
                    } catch (err) {
                        // Ensure we clear computing flag on unexpected errors
                        isComputing = false;
                        wrap.innerHTML = "<div class='error'>Lỗi khi xử lý</div>";
                    }
                }, 12);

                function computeQuick() {
                    // Groups map: key -> Set(rowIndex)
                    const groups = new Map();

                    // If requested group size is larger than typical row length (6),
                    // build candidate groups by pairing rows (heuristic) and then
                    // include any row that contains at least 6 numbers from the
                    // candidate group (user example: bộ 9 -> include rows with 6/9)
                    if (x > 6 && !consec.checked) {
                        const seen = new Set();
                        // limit pairs processed for performance on large datasets
                        const MAX_ROWS_FOR_PAIRING = 500;
                        const limitedRows = rows.slice(0, Math.min(rows.length, MAX_ROWS_FOR_PAIRING));
                        for (let i = 0; i < limitedRows.length; i++) {
                            for (let j = i + 1; j < limitedRows.length; j++) {
                                try {
                                    const a = limitedRows[i].nums || [];
                                    const b = limitedRows[j].nums || [];
                                    const union = Array.from(new Set([...a, ...b])).sort((p, q) => p - q);
                                    if (union.length !== x) continue; // we want candidate groups of exact size
                                    const key = union.join('-');
                                    if (seen.has(key)) continue;
                                    seen.add(key);
                                    groups.set(key, new Set());
                                } catch (e) { /* ignore row parsing errors */ }
                            }
                        }

                        // For each candidate group, include rows that have intersection >= 6
                        const threshold = 6;
                        for (const [key] of Array.from(groups.entries())) {
                            const parts = key.split('-').map(Number);
                            rows.forEach((r, rowIndex) => {
                                try {
                                    const common = r.nums.filter(n => parts.includes(n)).length;
                                    if (common >= threshold) groups.get(key).add(rowIndex);
                                } catch (e) { }
                            });
                        }
                    } else {
                        // existing logic for x <= 6 or consecutive
                        rows.forEach((r, rowIndex) => {
                            const nums = r.nums;
                            if (consec.checked) {
                                for (let i = 0; i <= nums.length - x; i++) {
                                    const slice = nums.slice(i, i + x).slice();
                                    const key = order.checked ? slice.join("-") : slice.slice().sort((a, b) => a - b).join("-");
                                    if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                }
                            } else {
                                const indexed = nums.map((v, i) => [i, v]);
                                const combos = kCombinations(indexed, x);
                                combos.forEach(combo => {
                                    const values = combo.map(c => c[1]).sort((a, b) => a - b);
                                    const key = values.join("-");
                                    if (!groups.has(key)) groups.set(key, new Set());
                                    groups.get(key).add(rowIndex);
                                });
                            }
                        });
                    }

                    let arr = [...groups.entries()]
                        .map(([key, indices]) => [key, [...indices].map(i => rows[i])])
                        .filter(([, list]) => list.length >= 2);

                    // record original occurrence counts per key (before any UI-level excludes)
                    try {
                        const m = new Map();
                        arr.forEach(([k, list]) => { m.set(k, list.length); });
                        baselineCountsMap = m;
                    } catch (e) { baselineCountsMap = null; }

                    // capture global baseline (before applying main x filter) and sort it
                    baselineArrGlobal = arr.slice();
                    const baselineSort = sortSel.value;
                    if (baselineSort === "value_asc") baselineArrGlobal.sort((a, b) => compareKey(a[0], b[0]));
                    else if (baselineSort === "value_desc") baselineArrGlobal.sort((a, b) => compareKey(b[0], a[0]));
                    else if (baselineSort === "count_asc") baselineArrGlobal.sort((a, b) => a[1].length - b[1].length);
                    else baselineArrGlobal.sort((a, b) => b[1].length - a[1].length);

                    try { baselineGlobalKeys = baselineArrGlobal.map(([k]) => k); } catch (e) { baselineGlobalKeys = null; }

                    // apply main x filter first (if provided) so baseline is the set of combos containing x
                    const mainX = parseInt(xFilter.value, 10);
                    if (!Number.isNaN(mainX)) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            return nums.includes(mainX);
                        });
                    }

                    // capture baseline (after main x filter, before dynamic extras)
                    baselineArrAll = arr.slice();
                    try { baselineAllKeys = baselineArrAll.map(([k]) => k); } catch (e) { baselineAllKeys = null; }
                    // sort baselineArrAll the same way so rank/sum are stable for filtered view
                    if (baselineSort === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                    else if (baselineSort === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                    else if (baselineSort === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                    else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                    // now apply dynamic extra filters (extras besides mainX)
                    const extras = [];
                    comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                        const v = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isNaN(v)) extras.push(v);
                    });
                    if (extras.length > 0) {
                        arr = arr.filter(([key]) => {
                            const nums = key.split('-').map(Number);
                            for (const f of extras) if (!nums.includes(f)) return false;
                            return true;
                        });
                    }

                    // If trash exclude mode is active, filter rows inside each group
                    // but keep the group entry (so ordering can be based on visible counts)
                    try {
                        let trashedSet = null;
                        if (String(trashValue) === 'exclude') {
                            const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                            trashedSet = new Set((trashed || []).map(n => Number(n)));
                        }
                        if (trashedSet && trashedSet.size) {
                            arr = arr.map(([key, list]) => {
                                const filtered = (list || []).filter(r => {
                                    try {
                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                        return true;
                                    } catch (err) { return true; }
                                });
                                return [key, filtered];
                            });
                        }
                    } catch (e) { /* ignore */ }

                    // Apply fav-include filter when requested: mirror Cell5.5 behavior
                    try {
                        const favEl = document.getElementById('cell6_5_favSel');
                        if (typeof favEl !== 'undefined' && favEl && String(favEl.value) === 'include') {
                            let favs = [];
                            try {
                                if (window.getFavItems && typeof window.getFavItems === 'function') {
                                    favs = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                                } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                                    favs = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                                } else {
                                    const f = document.getElementById('favPopup');
                                    if (f) {
                                        favs = Array.from(f.querySelectorAll('td.fav-number')).map(td => {
                                            try {
                                                const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                                if (dn) return Number(dn);
                                                const txt = String(td.textContent || '');
                                                const m = txt.match(/(\d+)/);
                                                return m ? Number(m[1]) : null;
                                            } catch (e) { return null; }
                                        }).filter(n => Number.isFinite(n));
                                    }
                                }
                            } catch (e) { favs = []; }
                            if (favs && favs.length) {
                                const fset = new Set((favs || []).map(n => Number(n)));
                                // read filter operator/count from favPopup controls (fallbacks provided)
                                let op = '>=';
                                let req = 1;
                                try {
                                    const fpop = document.getElementById('favPopup');
                                    if (fpop) {
                                        const opEl = fpop.querySelector('#favFilterOp');
                                        const cntEl = fpop.querySelector('#favFilterCount');
                                        if (opEl && ['>=', '<=', '='].includes(opEl.value)) op = opEl.value;
                                        if (cntEl) {
                                            const v = Number(cntEl.value);
                                            if (Number.isFinite(v)) req = Math.max(0, Math.min(6, Math.floor(v)));
                                        }
                                    }
                                } catch (e) { }

                                arr = arr.filter(([key, list]) => {
                                    try {
                                        // count matches of fav numbers inside the combo key
                                        const nums = key.split('-').map(Number);
                                        let matchCount = 0;
                                        for (const n of nums) if (fset.has(Number(n))) matchCount++;
                                        if (op === '>=') return matchCount >= req;
                                        if (op === '=') return matchCount === req;
                                        if (op === '<=') return matchCount <= req;
                                        return matchCount >= req;
                                    } catch (e) { return false; }
                                });
                            }
                        }
                    } catch (e) { /* ignore fav filter errors */ }
                    const sort = sortSel.value;
                    if (sort === "value_asc") arr.sort((a, b) => compareKey(a[0], b[0]));
                    else if (sort === "value_desc") arr.sort((a, b) => compareKey(b[0], a[0]));
                    else if (sort === "count_asc") arr.sort((a, b) => a[1].length - b[1].length);
                    else arr.sort((a, b) => b[1].length - a[1].length);
                    groupCache = arr;
                    cacheKey = newCacheKey;
                    isComputing = false;
                    renderGroupTable(arr);
                }

                function computeWithWorker() {
                    const worker = getWorker();
                    // send only numeric arrays to reduce serialization cost
                    const rowsForWorker = rows.map(r => ({ nums: r.nums }));

                    worker.onmessage = (e) => {
                        let arr = e.data.result.map(([key, indices]) => [key, indices.map(i => rows[i])]);
                        // record original counts (before UI-level excludes)
                        try {
                            const m = new Map();
                            arr.forEach(([k, list]) => { m.set(k, (list && list.length) ? list.length : 0); });
                            baselineCountsMap = m;
                        } catch (e) { baselineCountsMap = null; }

                        // capture global baseline (before applying main x filter) and sort it
                        baselineArrGlobal = arr.slice();
                        const baselineSortW = sortSel.value;
                        if (baselineSortW === "value_asc") baselineArrGlobal.sort((a, b) => compareKey(a[0], b[0]));
                        else if (baselineSortW === "value_desc") baselineArrGlobal.sort((a, b) => compareKey(b[0], a[0]));
                        else if (baselineSortW === "count_asc") baselineArrGlobal.sort((a, b) => a[1].length - b[1].length);
                        else baselineArrGlobal.sort((a, b) => b[1].length - a[1].length);

                        try { baselineGlobalKeys = baselineArrGlobal.map(([k]) => k); } catch (e) { baselineGlobalKeys = null; }

                        // apply main x filter so baseline reflects combos that include x
                        const mainXw = parseInt(xFilter.value, 10);
                        if (!Number.isNaN(mainXw)) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                return nums.includes(mainXw);
                            });
                        }

                        // capture baseline before applying dynamic extras (filtered by mainX)
                        baselineArrAll = arr.slice();
                        try { baselineAllKeys = baselineArrAll.map(([k]) => k); } catch (e) { baselineAllKeys = null; }
                        if (baselineSortW === "value_asc") baselineArrAll.sort((a, b) => compareKey(a[0], b[0]));
                        else if (baselineSortW === "value_desc") baselineArrAll.sort((a, b) => compareKey(b[0], a[0]));
                        else if (baselineSortW === "count_asc") baselineArrAll.sort((a, b) => a[1].length - b[1].length);
                        else baselineArrAll.sort((a, b) => b[1].length - a[1].length);

                        // now apply dynamic extras (excluding mainX)
                        const extrasW = [];
                        comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                            const v = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isNaN(v)) extrasW.push(v);
                        });
                        if (extrasW.length > 0) {
                            arr = arr.filter(([key]) => {
                                const nums = key.split('-').map(Number);
                                for (const f of extrasW) if (!nums.includes(f)) return false;
                                return true;
                            });
                        }

                        // Apply trash exclude if active (mirror Cell5.5 behavior)
                        try {
                            let trashedSetW = null;
                            if (String(trashValue) === 'exclude') {
                                const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                                trashedSetW = new Set((trashed || []).map(n => Number(n)));
                            }
                            if (trashedSetW && trashedSetW.size) {
                                arr = arr.map(([key, list]) => {
                                    const filtered = (list || []).filter(r => {
                                        try {
                                            if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                            for (const nn of r.nums) if (trashedSetW.has(Number(nn))) return false;
                                            return true;
                                        } catch (err) { return true; }
                                    });
                                    return [key, filtered];
                                });
                            }
                        } catch (e) { /* ignore */ }

                        // Apply fav-include filter when requested (worker path)
                        try {
                            const favElW = document.getElementById('cell6_5_favSel');
                            if (typeof favElW !== 'undefined' && favElW && String(favElW.value) === 'include') {
                                let favsW = [];
                                try {
                                    if (window.getFavItems && typeof window.getFavItems === 'function') {
                                        favsW = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                                    } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                                        favsW = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                                    } else {
                                        const f = document.getElementById('favPopup');
                                        if (f) {
                                            favsW = Array.from(f.querySelectorAll('td.fav-number')).map(td => {
                                                try {
                                                    const dn = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                                                    if (dn) return Number(dn);
                                                    const txt = String(td.textContent || '');
                                                    const m = txt.match(/(\d+)/);
                                                    return m ? Number(m[1]) : null;
                                                } catch (e) { return null; }
                                            }).filter(n => Number.isFinite(n));
                                        }
                                    }
                                } catch (e) { favsW = []; }
                                if (favsW && favsW.length) {
                                    const fsetW = new Set((favsW || []).map(n => Number(n)));
                                    let opW = '>='; let reqW = 1;
                                    try {
                                        const fpop = document.getElementById('favPopup');
                                        if (fpop) {
                                            const opEl = fpop.querySelector('#favFilterOp');
                                            const cntEl = fpop.querySelector('#favFilterCount');
                                            if (opEl && ['>=', '<=', '='].includes(opEl.value)) opW = opEl.value;
                                            if (cntEl) {
                                                const v = Number(cntEl.value);
                                                if (Number.isFinite(v)) reqW = Math.max(0, Math.min(6, Math.floor(v)));
                                            }
                                        }
                                    } catch (e) { }

                                    arr = arr.filter(([key, list]) => {
                                        try {
                                            const nums = key.split('-').map(Number);
                                            let matchCount = 0;
                                            for (const n of nums) if (fsetW.has(Number(n))) matchCount++;
                                            if (opW === '>=') return matchCount >= reqW;
                                            if (opW === '=') return matchCount === reqW;
                                            if (opW === '<=') return matchCount <= reqW;
                                            return matchCount >= reqW;
                                        } catch (e) { return false; }
                                    });
                                }
                            }
                        } catch (e) { /* ignore fav filter errors */ }

                        groupCache = arr;
                        cacheKey = newCacheKey;
                        isComputing = false;
                        renderGroupTable(arr);
                    };

                    worker.postMessage({
                        rows: rowsForWorker,
                        xSel: xSel.value,
                        consec: consec.checked,
                        order: order.checked,
                        sortSel: sortSel.value,
                        workerType: 'groupBySet'
                    });
                }
            }

            function renderGroupTable(arr) {
                // Header + empty grid container so the browser can paint quickly
                // Use baselineArrAll (unfiltered) for totals/rank while grid shows filtered arr
                const baselineTotal = (typeof baselineArrAll !== 'undefined' && baselineArrAll && Array.isArray(baselineArrAll)) ? baselineArrAll.length : arr.length;
                // build a readable filter text from xFilter + extras
                const fs = [];
                const mx = parseInt(xFilter.value, 10);
                if (!Number.isNaN(mx)) fs.push(String(mx));
                comboExtras.querySelectorAll('input[type="number"].combo-extra').forEach(inp => {
                    const v = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isNaN(v)) fs.push(String(v));
                });
                const filterText = fs.length ? ` — lọc theo Số x: {<span class="label-chip highlight">${fs.join(',')}</span>}` : ' — lọc theo Số x';

                // determine baseline rank/occ for the first displayed group
                let rankText = '';
                if (arr.length > 0 && baselineArrAll && baselineArrAll.length > 0) {
                    const firstKey = arr[0][0];
                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === firstKey);
                    if (idxInBaseline >= 0) {
                        const occ = baselineArrAll[idxInBaseline][1].length;
                        rankText = ` — vị trí ${idxInBaseline + 1}/${baselineArrAll.length} (\u00A0${occ} kỳ)`;
                    }
                }

                // BEFORE rendering, ensure groups are ordered by visible counts
                try {
                    // Determine effective trash mode and trashed set
                    let trashModeEl = null;
                    try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                    if (!trashModeEl) { try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; } }
                    const trashMode = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';
                    let trashedSet = null;
                    if (String(trashMode) === 'exclude') {
                        const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                        trashedSet = new Set((trashed || []).map(n => Number(n)));
                    }

                    if (trashedSet && trashedSet.size && Array.isArray(arr)) {
                        // build a temporary array of { key, origList, visibleList }
                        const tmp = arr.map(([key, list]) => {
                            const visible = (list || []).filter(r => {
                                try {
                                    if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                    for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                    return true;
                                } catch (err) { return true; }
                            });
                            return { key, orig: list, visible };
                        });
                        // sort tmp according to current sortSel but using visible.length for count sorts
                        const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                        tmp.sort((A, B) => {
                            if (currentSort === 'value_asc') return compareKey(A.key, B.key);
                            if (currentSort === 'value_desc') return compareKey(B.key, A.key);
                            if (currentSort === 'count_asc') return (A.visible ? A.visible.length : 0) - (B.visible ? B.visible.length : 0);
                            return (B.visible ? B.visible.length : 0) - (A.visible ? A.visible.length : 0);
                        });
                        // replace arr with visible lists in sorted order
                        arr = tmp.map(t => [t.key, t.visible]);
                    }
                } catch (e) { /* ignore ordering errors */ }

                wrap.innerHTML = `<div class='muted header-summary' style='flex-basis:100%;margin-bottom:8px'>${baselineTotal} nhóm (>=2 kỳ)${filterText}${rankText}</div>` +
                    `<div class='grid-centered' id='groupGrid'></div>`;
                const grid = wrap.querySelector('#groupGrid');
                const headerEl = wrap.querySelector('.header-summary');
                // number of rows per page used by each group's table
                const pageSizeRows = 15;
                const updateHeaderCount = () => {
                    try {
                        // Count one table per group (even if a group's table would paginate)
                        const totalTables = Array.isArray(arr) ? arr.length : 0;
                        // Simplified display: only show group count, filter and total tables
                        // Show current displayed table count and also indicate full baseline total
                        headerEl.innerHTML = `${baselineTotal} nhóm (>=2 kỳ)${filterText} — Số bảng (hiện tại): <span class="euclid-total-pill">${totalTables}</span>`;
                    } catch (e) { /* ignore */ }
                };

                // Caches and mount window for smooth scroll
                const htmlCache = new Map(); // key -> innerHTML (key: `${idx}|${page}`)
                const heightCache = new Map(); // idx -> measured height
                const lruQueue = [];
                const MAX_CACHE = 160;
                const cardRefs = new Map();
                const mountedSet = new Set();
                const MAX_MOUNTED = 40;

                const setCache = (cacheKey, html, idx) => {
                    htmlCache.set(cacheKey, html);
                    lruQueue.push(cacheKey);
                    if (lruQueue.length > MAX_CACHE) {
                        const rm = lruQueue.shift();
                        if (!mountedSet.has(idx)) htmlCache.delete(rm);
                    }
                };

                const mount = (card, idx) => {
                    const [key, list] = arr[idx] || [];
                    if (!key) return;
                    const body = card.querySelector('.card-body');

                    const pageSizeRows = 15;
                    // build a display list that respects recency selection; default is 'asc' (old->new)
                    let displayList = (list && list.slice) ? list.slice() : [];
                    try { if (recencySel && recencySel.value === 'desc') displayList.reverse(); } catch (e) { }

                    // SAFETY FILTER: remove any rows that contain trashed numbers when trash mode is 'exclude'
                    try {
                        // Determine effective trash mode (prefer cell6_6 selector when present)
                        let trashModeEl = null;
                        try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                        if (!trashModeEl) {
                            try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                        }
                        const trashMode = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';
                        if (String(trashMode) === 'exclude') {
                            const trashedArr = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                            const trashedSet = new Set((trashedArr || []).map(n => Number(n)));
                            if (trashedSet.size) {
                                displayList = displayList.filter(r => {
                                    try {
                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                        return true;
                                    } catch (err) { return true; }
                                });
                            }
                        }
                    } catch (e) { /* ignore safety-filter errors */ }

                    const totalPages = Math.max(1, Math.ceil(displayList.length / pageSizeRows));
                    const page = Math.max(0, Math.min(totalPages - 1, Number(card.dataset.page || 0)));
                    if (card.dataset.mounted === '1' && card.dataset.currentPage === String(page)) return;
                    const cacheKey = `${idx}|${page}|${recencySel ? recencySel.value : ''}`;

                    let inner = htmlCache.get(cacheKey);
                    if (!inner) {
                        const setValues = new Set(key.split('-').map(Number));
                        const x = parseInt(xSel.value, 10);
                        const start = page * pageSizeRows;
                        const slice = displayList.slice(start, start + pageSizeRows);
                        // Build per-card header (rendered inside mounted body) to mirror Cell6.6
                        const visibleCount = (displayList && Array.isArray(displayList)) ? displayList.length : 0;
                        let baselineCount = visibleCount;
                        try {
                            if (baselineCountsMap && typeof baselineCountsMap.get === 'function') {
                                const c = baselineCountsMap.get(key);
                                if (Number.isFinite(c)) baselineCount = c;
                            }
                        } catch (e) { baselineCount = visibleCount; }
                        // If trash 'exclude' is active, show only visible count (user requested)
                        let occDisplay;
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) === 'exclude') occDisplay = `${visibleCount} kỳ`;
                            else occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`;
                        } catch (e) { occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`; }
                        // compute within-x and global ranks when available
                        let rankDisplay = `${idx + 1}/${arr.length}`;
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) !== 'exclude') {
                                if (baselineArrAll && Array.isArray(baselineArrAll)) {
                                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === key);
                                    if (idxInBaseline >= 0) rankDisplay = `${idxInBaseline + 1}/${baselineArrAll.length}`;
                                }
                            }
                        } catch (e) { }
                        let globalRankDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (baselineGlobalKeys && Array.isArray(baselineGlobalKeys)) {
                                let keysArr = baselineGlobalKeys.slice();
                                if (String(tMode) === 'exclude') {
                                    const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                                    if (trashed && trashed.length && Array.isArray(trashed)) {
                                        const trashedSet = new Set((trashed || []).map(v => Number(v)));
                                        keysArr = keysArr.filter(k => {
                                            const parts = String(k).split('-').map(p => Number(p));
                                            for (const p of parts) if (trashedSet.has(p)) return false;
                                            return true;
                                        });

                                        // compute visible counts safely from baselineArrGlobal
                                        const visibleMap = new Map();
                                        try {
                                            if (Array.isArray(baselineArrGlobal)) {
                                                baselineArrGlobal.forEach(([k, list]) => {
                                                    if (!k || !Array.isArray(list)) { visibleMap.set(k, 0); return; }
                                                    let c = 0;
                                                    for (const r of list) {
                                                        if (!r || !r.nums || !Array.isArray(r.nums)) continue;
                                                        let ok = true;
                                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) { ok = false; break; }
                                                        if (ok) c++;
                                                    }
                                                    visibleMap.set(k, c);
                                                });
                                            }
                                        } catch (e) { }

                                        const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                                        keysArr.sort((a, b) => {
                                            if (currentSort === 'value_asc') return compareKey(a, b);
                                            if (currentSort === 'value_desc') return compareKey(b, a);
                                            const va = visibleMap.has(a) ? visibleMap.get(a) : 0;
                                            const vb = visibleMap.has(b) ? visibleMap.get(b) : 0;
                                            if (currentSort === 'count_asc') return va - vb;
                                            return vb - va;
                                        });
                                    }
                                }
                                const idxInGlobal = keysArr.indexOf(key);
                                if (idxInGlobal >= 0) globalRankDisplay = `${idxInGlobal + 1}/${keysArr.length}`;
                            }
                        } catch (e) { }
                        let leftRankHtml = '';
                        if (globalRankDisplay && baselineArrAll && baselineArrGlobal && baselineArrGlobal.length !== baselineArrAll.length) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                                `<span class='muted' title='Toàn bộ' style='font-weight:800;margin-left:6px'>${globalRankDisplay}</span>`;
                        } else if (globalRankDisplay) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${globalRankDisplay}</span>`;
                        } else {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>`;
                        }

                        const headerHtml = `<div class='flex' style='justify-content:space-between;align-items:center'>` +
                            `<strong>{${key.replace(/-/g, ',')}}</strong>` +
                            `<div style='display:flex;align-items:center;gap:8px'>` +
                            `${leftRankHtml}` +
                            `<span class='badge'>${occDisplay}</span>` +
                            `</div>` +
                            `</div>`;

                        const navHtml = `<div class='flex' style='justify-content:flex-end;gap:8px;margin-bottom:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        inner = headerHtml + navHtml;
                        inner += `<table style="width:100%"><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>`;
                        // If there are rows to render, compute per-row `k` using the same
                        // greedy trash-popup semantics so we can annotate each <tr>
                        if (slice.length === 0) {
                            inner += `<tr><td colspan='4' class='muted'>Không có kết quả</td></tr>`;
                        } else {
                            // Build mapping from stable row key -> global indices
                            const rowKeyToIndices = new Map();
                            try {
                                rows.forEach((rr, gi) => {
                                    try {
                                        const rk = (rr.nums && Array.isArray(rr.nums) ? rr.nums.join(',') : '') + '|' + (rr.date || '');
                                        if (!rowKeyToIndices.has(rk)) rowKeyToIndices.set(rk, []);
                                        rowKeyToIndices.get(rk).push(gi);
                                    } catch (err) { }
                                });
                            } catch (err) { }

                            // Determine pool (use numberPickerTable order if available)
                            let pool = [];
                            try {
                                const npTable = document.getElementById('numberPickerTable');
                                if (npTable) {
                                    const tds = Array.from(npTable.querySelectorAll('td[data-number]'));
                                    pool = tds.map(td => Number(td.dataset.number)).filter(n => Number.isFinite(n));
                                }
                            } catch (e) { }
                            if (!pool || !pool.length) pool = Array.from({ length: 45 }, (_, i) => i + 1);

                            // Greedy simulation: compute first-k when each global row becomes excluded
                            const rowFirstExcludedAt = new Array(rows.length).fill(null);
                            const chosen = new Set();
                            const maxK = pool.length;
                            for (let kIdx = 1; kIdx <= maxK; kIdx++) {
                                let best = null; let bestNew = Infinity;
                                for (const cand of pool) {
                                    if (chosen.has(cand)) continue;
                                    let newExcl = 0;
                                    for (let gi = 0; gi < rows.length; gi++) {
                                        if (rowFirstExcludedAt[gi] !== null) continue;
                                        const rr = rows[gi];
                                        if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                        for (const nn of rr.nums) { if (Number(nn) === cand) { newExcl++; break; } }
                                    }
                                    if (newExcl < bestNew) { bestNew = newExcl; best = cand; }
                                }
                                if (best === null) break;
                                for (let gi = 0; gi < rows.length; gi++) {
                                    if (rowFirstExcludedAt[gi] !== null) continue;
                                    const rr = rows[gi];
                                    if (!rr || !rr.nums || !Array.isArray(rr.nums)) continue;
                                    for (const nn of rr.nums) { if (Number(nn) === best) { rowFirstExcludedAt[gi] = kIdx; break; } }
                                }
                                chosen.add(best);
                            }

                            // Build pairCounts & computeRule for rule column (same as Cell5.5)
                            const __c65_pairCounts = new Map();
                            try {
                                rows.forEach(rr => {
                                    try {
                                        const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                                        for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                            const key = `${ns[i]}-${ns[j]}`;
                                            __c65_pairCounts.set(key, (__c65_pairCounts.get(key) || 0) + 1);
                                        }
                                    } catch (e) { }
                                });
                            } catch (e) { }
                            const __c65_computeRule = (sixNums) => {
                                try {
                                    if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                                    const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                                    if (userNums.length !== 6) return '';
                                    const MAX_N = 44;
                                    let found = null;
                                    for (let n = MAX_N; n >= 1; n--) {
                                        for (const cand of userNums) {
                                            const others = [];
                                            for (let y = 1; y <= 45; y++) {
                                                if (y === cand) continue;
                                                const a = Math.min(cand, y), b = Math.max(cand, y);
                                                const key = `${a}-${b}`;
                                                const c = __c65_pairCounts.get(key) || 0;
                                                others.push({ y, c });
                                            }
                                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                            const pick = others.slice(0, n).map(o => o.y);
                                            const otherFive = userNums.filter(x => x !== cand);
                                            const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                            if (!conflict) { found = { n, cand, pick }; break; }
                                        }
                                        if (found) break;
                                    }
                                    if (!found) {
                                        const cand = userNums[0];
                                        const others = [];
                                        for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = __c65_pairCounts.get(key) || 0; others.push({ y, c }); }
                                        others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                        found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                                    }
                                    const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                                    remaining.sort((a, b) => a - b);
                                    return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                                } catch (e) { return ''; }
                            };

                            // Emit rows with computed t (largest k for which row remains visible)
                            slice.forEach(r => {
                                const orderedSeq = key.split('-').map(Number);
                                const requireOrder = !!(consec.checked && order && order.checked);
                                const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setValues, x, consec.checked, orderedSeq, requireOrder);
                                const labelHtml = renderHighlightedLabel(r.label, positions);
                                const ruleHtml = (Array.isArray(r.nums) && r.nums.length === 6) ? __c65_computeRule(r.nums) : '';

                                let t = pool.length;
                                try {
                                    const rk = (r.nums && Array.isArray(r.nums) ? r.nums.join(',') : '') + '|' + (r.date || '');
                                    const gids = rowKeyToIndices.get(rk) || [];
                                    const gi = (gids && gids.length) ? gids[0] : null;
                                    if (gi !== null && rowFirstExcludedAt[gi] !== null) t = Math.max(0, rowFirstExcludedAt[gi] - 1);
                                } catch (err) { }

                                inner += `<tr data-result="${r.nums.join(',')}" title="k=x=${t}" data-k="${t}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                            });
                        }
                        if (displayList.length > (page + 1) * pageSizeRows) inner += `<tr><td colspan='4' class='muted'>... ${displayList.length - (page + 1) * pageSizeRows} dòng nữa</td></tr>`;
                        inner += `</tbody></table>`;
                        inner += `<div class='flex' style='justify-content:flex-end;gap:8px;margin-top:8px;'>` +
                            `<button class='nav-btn prev'>◀</button>` +
                            `<input type='number' class='page-input' min='1' max='${totalPages}' value='${page + 1}' style='width:64px;text-align:center'/>` +
                            `<div class='muted' style='align-self:center;margin-left:6px'>/ ${totalPages}</div>` +
                            `<button class='nav-btn next'>▶</button>` +
                            `</div>`;
                        setCache(cacheKey, inner, idx);
                    }
                    body.style.minHeight = '';
                    body.innerHTML = inner;
                    // Reapply persisted Ctrl-selected highlight (persist across renders)
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell6_5_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = body.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // attach hover handler to tbody so hovering a row will
                    // read the card header <strong> (e.g. {18,29}) and
                    // highlight corresponding numbers in the popup table
                    (function attachRowHoverToPopup() {
                        try {
                            const _tbody = body.querySelector('tbody');
                            if (!_tbody) return;

                            function parseStrongNumbers(text) {
                                if (!text) return [];
                                // remove braces and split on non-digits
                                return text.replace(/[{}]/g, '')
                                    .split(/[^0-9]+/)
                                    .map(s => parseInt(s, 10))
                                    .filter(n => Number.isFinite(n));
                            }

                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = parseStrongNumbers(s.textContent.trim());
                                if (nums.length) {
                                    // remember current highlights so regenerating the popup can reapply
                                    try {
                                        window.__popupHighlights = nums.slice();
                                        // store the card element that produced these highlights so
                                        // we can clear them when the user hovers a different record
                                        window.__popupHighlightSource = cardEl;
                                    } catch (e) { }
                                    applyPopupHighlights(nums);
                                }
                            });

                            _tbody.addEventListener('mouseout', (ev) => {
                                // Persist highlights even when the mouse leaves the tbody.
                                // No-op.
                                return;
                            });

                            // Ctrl+click a row: switch to cell6_6, paste its 6 numbers, and mark row with yellow border
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    // parse numbers (use existing helper)
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;

                                    // clear any previous ctrl-selected rows globally and mark this one
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    // persist selection so it survives remounts/navigation
                                    try { localStorage.setItem('cell6_5_ctrl_selected', result); } catch (e) { }

                                    // Ensure target section is rendered then navigate to it after a short delay
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) {
                                        setTimeout(() => {
                                            try { navBtn.click(); } catch (e) { }
                                            // apply numbers after nav; give a small delay to allow render
                                            setTimeout(() => {
                                                try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { }
                                            }, 220);
                                        }, 200);
                                    } else {
                                        // fallback: apply even if nav button missing
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                    }
                                } catch (e) { /* ignore */ }
                            });
                        } catch (err) { /* ignore */ }
                    })();

                    try { updateHeaderCount(); } catch (e) { }
                    const prevBtns = body.querySelectorAll('.prev');
                    const nextBtns = body.querySelectorAll('.next');
                    prevBtns.forEach(prevBtn => prevBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur - 1 + totalPages) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));
                    nextBtns.forEach(nextBtn => nextBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const cur = Number(card.dataset.page || 0);
                        const newPage = (cur + 1) % totalPages;
                        card.dataset.page = String(newPage);
                        mount(card, idx);
                    }));

                    const pageInputs = body.querySelectorAll('.page-input');
                    pageInputs.forEach(inp => {
                        inp.addEventListener('change', (ev) => {
                            ev.stopPropagation();
                            const v = Number(inp.value);
                            if (!Number.isFinite(v)) { inp.value = String(page + 1); return; }
                            const newPage = v - 1;
                            if (newPage >= 0 && newPage < totalPages) {
                                card.dataset.page = String(newPage);
                                mount(card, idx);
                            } else {
                                inp.value = String(page + 1);
                            }
                        });
                        inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') inp.dispatchEvent(new Event('change')); });
                    });

                    card.dataset.mounted = '1';
                    card.dataset.currentPage = String(page);
                    mountedSet.add(idx);
                    if (!heightCache.has(idx)) heightCache.set(idx, body.offsetHeight || 120);
                    enforceMountedBudget(idx);
                };

                const unmount = (card, idx) => {
                    if (card.dataset.mounted !== '1') return;
                    const body = card.querySelector('.card-body');
                    const h = heightCache.get(idx);
                    if (h) body.style.minHeight = `${h}px`;
                    body.innerHTML = '';
                    try { updateHeaderCount(); } catch (e) { }
                    card.dataset.mounted = '0';
                    mountedSet.delete(idx);
                };

                const enforceMountedBudget = (preferKeepIdx) => {
                    if (mountedSet.size <= MAX_MOUNTED) return;
                    const vh = window.innerHeight; const center = vh / 2;
                    const candidates = Array.from(mountedSet).filter(i => i !== preferKeepIdx).map(i => {
                        const el = cardRefs.get(i);
                        const rect = el ? el.getBoundingClientRect() : { top: 1e9 };
                        return { i, d: Math.abs(rect.top - center) };
                    }).sort((a, b) => b.d - a.d);
                    while (mountedSet.size > MAX_MOUNTED && candidates.length) {
                        const { i } = candidates.shift();
                        const el = cardRefs.get(i);
                        if (el) unmount(el, i);
                    }
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const idx = parseInt(entry.target.dataset.index, 10);
                        if (Number.isNaN(idx)) return;
                        if (entry.isIntersecting) mount(entry.target, idx);
                        else unmount(entry.target, idx);
                    });
                }, { root: null, rootMargin: '600px 0px', threshold: 0 });

                // Create card shells in chunks
                const totalGroups = arr.length;
                let created = 0;
                const chunkSize = 8;
                const createChunk = () => {
                    const end = Math.min(created + chunkSize, arr.length);
                    for (let i = created; i < end; i++) {
                        const [key, list] = arr[i];
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.index = String(i);
                        card.dataset.mounted = '0';
                        card.dataset.page = '0';
                        card.dataset.currentPage = '-1';
                        // Prefer baseline (pre-trash) values for rank/occurrence when available
                        let rankDisplay = `${i + 1}/${totalGroups}`;
                        // visibleCount = number of rows currently displayed for this group (after trash filter)
                        const visibleCount = (list && list.length) ? list.length : 0;
                        let baselineCount = visibleCount;
                        try {
                            if (baselineCountsMap && typeof baselineCountsMap.get === 'function') {
                                const c = baselineCountsMap.get(key);
                                if (Number.isFinite(c)) baselineCount = c;
                            }
                        } catch (e) { baselineCount = visibleCount; }
                        // show as visible/baseline when they differ, otherwise single number
                        let occDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) === 'exclude') occDisplay = `${visibleCount} kỳ`;
                            else occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`;
                        } catch (e) { occDisplay = baselineCount !== visibleCount ? `${visibleCount}/${baselineCount} kỳ` : `${baselineCount} kỳ`; }
                        try {
                            // within-x rank: use baselineAllKeys (captured before trash exclude)
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (String(tMode) !== 'exclude') {
                                if (baselineArrAll && Array.isArray(baselineArrAll)) {
                                    const idxInBaseline = baselineArrAll.findIndex(([k]) => k === key);
                                    if (idxInBaseline >= 0) rankDisplay = `${idxInBaseline + 1}/${baselineArrAll.length}`;
                                }
                            }
                        } catch (e) { }

                        // Compute global rank (before main-x filter) if available using baselineGlobalKeys
                        let globalRankDisplay = '';
                        try {
                            const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel'));
                            const tMode = (tEl && tEl.value) ? tEl.value : 'include';
                            if (baselineGlobalKeys && Array.isArray(baselineGlobalKeys)) {
                                let keysArr = baselineGlobalKeys;
                                if (String(tMode) === 'exclude') {
                                    const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                                    if (trashed && trashed.length && Array.isArray(trashed)) {
                                        const trashedSet = new Set(trashed.map(v => String(Number(v))));
                                        keysArr = baselineGlobalKeys.filter(k => {
                                            const parts = String(k).split('-').map(p => String(Number(p)));
                                            for (const p of parts) if (trashedSet.has(p)) return false;
                                            return true;
                                        });
                                    }
                                }
                                const idxInGlobal = keysArr.indexOf(key);
                                if (idxInGlobal >= 0) globalRankDisplay = `${idxInGlobal + 1}/${keysArr.length}`;
                            }
                        } catch (e) { }

                        // Decide what to show: if global differs from filtered, show both (filtered then global).
                        // Otherwise show just the global (or filtered fallback).
                        let leftRankHtml = '';
                        if (globalRankDisplay && baselineArrAll && baselineArrGlobal && baselineArrGlobal.length !== baselineArrAll.length) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>` +
                                `<span class='muted' title='Toàn bộ' style='font-weight:800;margin-left:6px'>${globalRankDisplay}</span>`;
                        } else if (globalRankDisplay) {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${globalRankDisplay}</span>`;
                        } else {
                            leftRankHtml = `<span class='muted' style='font-weight:800'>${rankDisplay}</span>`;
                        }

                        // Create an empty card body; header will be rendered inside mount
                        card.innerHTML = `<div class='card-body' style='min-height:120px'></div>`;
                        grid.appendChild(card);
                        cardRefs.set(i, card);
                        observer.observe(card);
                    }
                    created = end;
                    // refresh header count after building a new chunk
                    try { updateHeaderCount(); } catch (e) { }
                    if (created < arr.length) requestAnimationFrame(createChunk);
                };
                createChunk();

                // After chunked creation completes, scroll viewport to 240px so
                // the `.controls` area and new results are visible. Use a small
                // timeout + rAF to wait for layout/paint to settle.
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        try {
                            window.scrollTo({ top: 240, behavior: 'auto' });
                        } catch (e) {
                            try { document.scrollingElement.scrollTop = 240; } catch (err) { }
                        }
                    });
                }, 160);

            }

            const debouncedGroup = createDebounce(group, 300);
            // expose the current debouncedGroup on the section so external listeners
            // can call the latest function even if this renderer re-runs
            try {
                const sec = document.getElementById('cell6_5');
                if (sec) {
                    sec.__group = debouncedGroup;
                    // provide an invalidate helper so external listeners can clear
                    // internal caches and force a fresh compute/render
                    sec.__invalidate = function () {
                        try { groupCache = null; cacheKey = null; baselineArrAll = null; baselineArrGlobal = null; isComputing = false; } catch (e) { }
                        try { if (wrap) wrap.innerHTML = ''; } catch (e) { }
                    };
                }
            } catch (e) { }
            // Add a local listener on the section to respond to popup trash changes.
            // Using a section-scoped listener avoids depending solely on a global lookup
            // and ensures the current renderer instance handles updates reliably.
            try {
                if (body && !body.__trash_listener_added) {
                    body.addEventListener('trashchange', () => {
                        try {
                            try { console.log('cell6_5: section-local trashchange received'); } catch (e) { }
                            // Invalidate renderer state then trigger recompute like other inputs
                            try { const sec = document.getElementById('cell6_5'); if (sec && typeof sec.__invalidate === 'function') sec.__invalidate(); } catch (e) { }
                            if (typeof debouncedGroup === 'function') debouncedGroup(); else group();
                        } catch (err) { /* ignore */ }
                    });
                    body.__trash_listener_added = true;
                }
            } catch (e) { /* ignore */ }
            consec.onchange = () => { order.disabled = !consec.checked; if (!consec.checked) order.checked = false; debouncedGroup(); };
            xSel.onchange = sortSel.onchange = order.onchange = recencySel.onchange = trashSel.onchange = debouncedGroup;
            xFilter.onchange = debouncedGroup;
            if (recencySel) recencySel.onchange = debouncedGroup;
            // Register a single global listener to respond to popup trash changes.
            // It looks up the current selector (`cell6_5_trashSel`) and calls the
            // section's `__group` function so the call targets the latest instance.
            try {
                if (!window.__cell6_5_trash_watch) {
                    document.addEventListener('trashchange', () => {
                        try {
                            try { console.log('cell6_5: global trashchange received'); } catch (e) { }
                            const sec = document.getElementById('cell6_5');
                            if (sec && typeof sec.__invalidate === 'function') {
                                try { sec.__invalidate(); } catch (e) { }
                            }
                            // Recompute visible rows per group based on current trash mode
                            try {
                                // determine effective trash mode (prefer cell6_6 selector)
                                let trashModeEl = null;
                                try { trashModeEl = document.getElementById('cell6_6_trashSel'); } catch (e) { trashModeEl = null; }
                                if (!trashModeEl) {
                                    try { trashModeEl = document.getElementById('cell6_5_trashSel'); } catch (e) { trashModeEl = null; }
                                }
                                const trashValue = (trashModeEl && trashModeEl.value) ? trashModeEl.value : 'include';

                                if (groupCache && Array.isArray(groupCache)) {
                                    if (String(trashValue) === 'exclude') {
                                        const trashed = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems ? window.__trashItems.slice() : []);
                                        const trashedSet = new Set((trashed || []).map(n => Number(n)));
                                        if (trashedSet.size) {
                                            groupCache = groupCache.map(([key, list]) => {
                                                const filtered = (list || []).filter(r => {
                                                    try {
                                                        if (!r || !r.nums || !Array.isArray(r.nums)) return false;
                                                        for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                                                        return true;
                                                    } catch (err) { return true; }
                                                });
                                                return [key, filtered];
                                            });
                                        }
                                    } else {
                                        // include mode: restore visible lists from baseline (if available)
                                        if (baselineArrAll && Array.isArray(baselineArrAll)) {
                                            try { groupCache = baselineArrAll.map(([k, l]) => [k, (l && l.slice) ? l.slice() : []]); } catch (e) { /* ignore */ }
                                        }
                                    }
                                }
                                // Ensure groups are re-ordered according to current sort selection
                                try {
                                    const currentSort = (typeof sortSel !== 'undefined' && sortSel && sortSel.value) ? sortSel.value : 'count_desc';
                                    if (groupCache && Array.isArray(groupCache)) {
                                        if (currentSort === 'value_asc') groupCache.sort((a, b) => compareKey(a[0], b[0]));
                                        else if (currentSort === 'value_desc') groupCache.sort((a, b) => compareKey(b[0], a[0]));
                                        else if (currentSort === 'count_asc') groupCache.sort((a, b) => (a[1] ? a[1].length : 0) - (b[1] ? b[1].length : 0));
                                        else groupCache.sort((a, b) => (b[1] ? b[1].length : 0) - (a[1] ? a[1].length : 0));
                                    }
                                } catch (e) { /* ignore sort errors */ }
                            } catch (e) { /* ignore recompute errors */ }

                            // Force a fresh render by clearing cacheKey so group() will
                            // re-evaluate sorting and pagination using current controls.
                            try { cacheKey = null; isComputing = false; } catch (e) { }
                            const fn = sec && sec.__group ? sec.__group : null;
                            if (typeof fn === 'function') fn();
                        } catch (e) { /* ignore */ }
                    });
                    window.__cell6_5_trash_watch = true;
                }
            } catch (e) { /* ignore */ }

            group();
        }

        // Cell8: reverse query by label pattern (6 chars, _ wildcard)
        function renderCell8() {
            const body = sectionShell("cell8", "Cell8 · Tìm kiếm theo Label", "Nhập 6 ký tự label (1-6 hoặc _) để tìm các kỳ có label khớp. Có thể kéo thả giữa các vị trí.");
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });

            // Create draggable containers for inputs and add small up/down arrows inside the input on the right
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                // container sized to the input; buttons will be absolutely positioned inside it
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                // small left-side grip so it doesn't cover the whole input and block typing
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                // keep input as text to allow wildcard '_', but visually reserve space for buttons
                inp.type = 'text';
                inp.maxLength = 1;
                inp.placeholder = '_';
                inp.size = 1;
                inp.style.width = '70px';
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';
                inp.style.position = 'relative';
                inp.style.zIndex = '1';

                // small vertical arrow buttons inside the input, right-aligned
                const btnGroup = document.createElement('div');
                // absolutely position the buttons so they sit inside the input's right edge
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';

                // make arrows compact so they don't overflow the input border
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';

                const up = document.createElement('button');
                up.type = 'button';
                up.className = 'arrow-up';
                up.innerHTML = '▲';
                up.title = 'Tăng 1';
                up.style.cssText = arrowStyle;

                const down = document.createElement('button');
                down.type = 'button';
                down.className = 'arrow-down';
                down.innerHTML = '▼';
                down.title = 'Giảm 1';
                down.style.cssText = arrowStyle;

                // clamp helper: allow '' and '_' as wildcard, otherwise clamp to [1,6]
                const clampValue = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '' || raw === '_') return;
                    const n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: after 6 -> 1
                    n = n + 1;
                    if (n > 6) n = 1;
                    if (n < 1) n = 1;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    let n = parseInt(String(inp.value ?? '').trim(), 10);
                    if (!Number.isFinite(n)) n = 0;
                    // wrap-around: before 1 -> 6
                    n = n - 1;
                    if (n < 1) n = 6;
                    if (n > 6) n = 6;
                    inp.value = String(n);
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '' && v !== '_';
                    container.draggable = hasValue;
                    // only enable pointer events on the small grip (left) so the input remains editable
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    // keep padding and border radius constant so container height doesn't jump
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    // use transparent border when empty to preserve box size, and accent border when filled
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => { clampValue(); updateDraggable(); });
                inp.addEventListener('change', () => { clampValue(); updateDraggable(); });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    if (draggedIndex !== null && draggedIndex !== idx) {
                        container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                        container.style.transform = "scale(1.05)";
                    }
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Kéo từ bảng label C1-C6 trực tiếp từ popup
                    if (labelData) {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run();
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                        return;
                    }

                    // Swap với 1 place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                            const incomingRaw = placeVals[srcIdx];
                            const incoming = incomingRaw && popupMode === 'number' ? getCol(parseInt(incomingRaw, 10)) : incomingRaw;
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Nếu kéo cả bộ place (6 giá trị)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : 'number';
                                for (let i = 0; i < 6; i++) {
                                    const val = values[i];
                                    let col = '';
                                    if (val) {
                                        const numVal = parseInt(val, 10);
                                        col = popupMode === 'number' ? getCol(numVal) : numVal;
                                    }
                                    inputs[i].value = col || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                run();
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                draggedIndex = null;
                                return;
                            }
                        } catch (err) { }
                    }
                    // Kéo số trực tiếp từ popup → chuyển sang cột (chỉ nếu không phải internal drag)
                    if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                        const numVal = parseInt(draggedData, 10);
                        if (numVal >= 1 && numVal <= 45) {
                            const col = getCol(numVal);
                            inputs[idx].value = col || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            run();
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Hoán đổi nội bộ
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        run();
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const wrapInputs = document.createElement("div"); wrapInputs.className = "controls";
            const labelText = document.createElement("span"); labelText.textContent = "Label:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px";
            wrapInputs.appendChild(labelText);
            containers.forEach(c => wrapInputs.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', run);
            body.appendChild(wrapInputs);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; wrapInputs.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            wrapInputs.appendChild(hint);
            try { wrapInputs.appendChild(recencySel); } catch (e) { }

            function run() {
                const pattern = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : "_"; }).join("");
                if (!rows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                if (pattern.length !== 6) { wrap.innerHTML = "<div class='error'>Cần 6 ký tự</div>"; return; }

                // Build pairCounts & computeRule for rule column (same as Cell6.5)
                const __c8_pairCounts = new Map();
                try {
                    rows.forEach(rr => {
                        try {
                            const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                            for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                const key = `${ns[i]}-${ns[j]}`;
                                __c8_pairCounts.set(key, (__c8_pairCounts.get(key) || 0) + 1);
                            }
                        } catch (e) { }
                    });
                } catch (e) { }
                const __c8_computeRule = (sixNums) => {
                    try {
                        if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                        const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                        if (userNums.length !== 6) return '';
                        const MAX_N = 44;
                        let found = null;
                        for (let n = MAX_N; n >= 1; n--) {
                            for (const cand of userNums) {
                                const others = [];
                                for (let y = 1; y <= 45; y++) {
                                    if (y === cand) continue;
                                    const a = Math.min(cand, y), b = Math.max(cand, y);
                                    const key = `${a}-${b}`;
                                    const c = __c8_pairCounts.get(key) || 0;
                                    others.push({ y, c });
                                }
                                others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                const pick = others.slice(0, n).map(o => o.y);
                                const otherFive = userNums.filter(x => x !== cand);
                                const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                if (!conflict) { found = { n, cand, pick }; break; }
                            }
                            if (found) break;
                        }
                        if (!found) {
                            const cand = userNums[0];
                            const others = [];
                            for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = __c8_pairCounts.get(key) || 0; others.push({ y, c }); }
                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                            found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                        }
                        const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                        remaining.sort((a, b) => a - b);
                        return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                    } catch (e) { return ''; }
                };

                const records = rows.filter(r => {
                    const label = r.label;
                    for (let i = 0; i < 6; i++) if (pattern[i] !== "_" && pattern[i] !== label[i]) return false;
                    return true;
                });
                if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào khớp pattern</div>"; return; }
                let display = records.slice();
                if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                const chunk = 15;
                for (let i = 0; i < display.length; i += chunk) {
                    html += "<div class='card'><table style='width:100%'><thead><tr><th>Ngày</th><th>Kết quả</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                    display.slice(i, i + chunk).forEach(r => {
                        const nums = r.nums.map((v, idx) => pattern[idx] !== "_"
                            ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                            : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
                        ).join(" ");
                        const labelHtml = r.label.split("").map((ch, idx) => pattern[idx] === "_" ? `<span>${ch}</span>` : `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`).join(" ");
                        const ruleHtml = (Array.isArray(r.nums) && r.nums.length === 6) ? __c8_computeRule(r.nums) : '';
                        html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td style='white-space:nowrap;'>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                    });
                    html += "</tbody></table></div>";
                }
                html += "</div>";
                wrap.innerHTML = html;
                // Reapply persisted Ctrl-selected highlight (persist across renders) for cell8
                try {
                    const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                    if (persisted) {
                        const _tbody_reapply = wrap.querySelector('tbody');
                        if (_tbody_reapply) {
                            const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                            if (m) m.classList.add('ctrl-selected');
                        }
                    }
                } catch (e) { /* ignore reapply errors */ }

                // Attach delegated hover + Ctrl+click handlers so rows can be highlighted and Ctrl-clicked
                (function attachRowHoverAndCtrlClick_cell8_labelMode() {
                    try {
                        wrap.addEventListener('mouseover', (ev) => {
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                            if (!tr) return;
                            const res = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                            if (!res) return;
                            const nums = res.split(/[^0-9]+/).map(s => parseInt(s, 10)).filter(Number.isFinite);
                            if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = tr.closest('.card') || wrap; } catch (e) { } applyPopupHighlights(nums); }
                        });

                        wrap.addEventListener('click', (ev) => {
                            try {
                                if (!ev || !ev.ctrlKey) return;
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                ev.preventDefault();
                                const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                if (!result) return;
                                const nums = parseSixNumbersFromString(result);
                                if (!nums) return;

                                try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                tr.classList.add('ctrl-selected');
                                try { localStorage.setItem('cell8_ctrl_selected', result); } catch (e) { }

                                try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                if (navBtn) {
                                    setTimeout(() => {
                                        try { navBtn.click(); } catch (e) { }
                                        setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220);
                                    }, 200);
                                } else {
                                    setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260);
                                }
                            } catch (e) { /* ignore */ }
                        });
                    } catch (err) { /* ignore */ }
                })();

                // scroll to 240px so the controls sit under header consistently
                setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function compareKey(a, b) {
            const pa = a.split("-").map(Number); const pb = b.split("-").map(Number);
            for (let i = 0; i < Math.min(pa.length, pb.length); i++) { if (pa[i] !== pb[i]) return pa[i] - pb[i]; }
            return pa.length - pb.length;
        }
        function findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            if (requireConsecutive) {
                for (let i = 0; i <= nums.length - blockSize; i++) {
                    const block = nums.slice(i, i + blockSize);
                    if (block.length !== blockSize) continue;
                    if (requireOrder && Array.isArray(orderedSeq) && orderedSeq.length === blockSize) {
                        let matches = true;
                        for (let k = 0; k < blockSize; k++) {
                            if (block[k] !== orderedSeq[k]) { matches = false; break; }
                        }
                        if (matches) return Array.from({ length: blockSize }, (_, k) => i + k);
                    } else {
                        if (block.every(v => setValues.has(v)) && new Set(block).size === setValues.size) {
                            return Array.from({ length: blockSize }, (_, k) => i + k);
                        }
                    }
                }
            }
            const positions = [];
            nums.forEach((v, idx) => { if (setValues.has(v)) positions.push(idx); });
            return positions;
        }
        function renderHighlightedNums(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder) {
            const positions = findHighlightPositions(nums, setValues, blockSize, requireConsecutive, orderedSeq, requireOrder);
            const posSet = new Set(positions);
            const html = nums.map((v, idx) => posSet.has(idx)
                ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>`
                : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`
            ).join(" ");
            return { html, positions };
        }
        function renderHighlightedLabel(labelStr, highlightPositions) {
            const posSet = new Set(highlightPositions);
            return labelStr.split("").map((ch, idx) => posSet.has(idx)
                ? `<span style='background:var(--highlight-bg);color:var(--highlight-text);padding:2px 6px;border-radius:4px;font-weight:700;'>${ch}</span>`
                : `<span>${ch}</span>`
            ).join(" ");
        }

        // Helper for main thread combos (same algorithm available inside worker)
        function kCombinations(set, k) {
            const combs = [];
            const n = set.length;
            function pick(start, acc) {
                if (acc.length === k) { combs.push(acc.slice()); return; }
                for (let i = start; i < n; i++) { acc.push(set[i]); pick(i + 1, acc); acc.pop(); }
            }
            pick(0, []);
            return combs;
        }

        // Cell9: draws containing user set
        function renderCell9() {
            const body = sectionShell("cell9", "Cell9 · Tổ hợp chứa bộ số hoặc label", "Chọn tìm theo bộ số (1-45) hoặc label (1-6). Có thể kéo thả giữa các vị trí.");

            // Mode toggle integrated with Number Picker
            const getNumberPickerMode = window.getNumberPickerMode || (() => "number");
            const setNumberPickerMode = window.setNumberPickerMode || (() => { });
            const onNumberPickerModeChange = window.onNumberPickerModeChange || (() => () => { });
            let cell9ModeState = getNumberPickerMode();
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell9ModeState === 'number' ? 'Bộ số (1-45)' : 'Label (1-6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === "number") {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });
                }
            };

            let inputs = createInputs(cell9ModeState);

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                    container.draggable = false;

                    // small left-side grip so it doesn't cover the whole input and block typing
                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                    // reserve space on the right for buttons
                    inp.style.position = "relative";
                    inp.style.zIndex = "1";
                    inp.style.paddingRight = '40px';
                    inp.style.boxSizing = 'border-box';

                    // button group inside input, right-aligned
                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                    // helpers per mode
                    const clampForNumberMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 45) inp.value = '45';
                        else inp.value = String(n);
                    };

                    const clampForLabelMode = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '' || raw === '_') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 6) inp.value = '6';
                        else inp.value = String(n);
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 45) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 6) n = 1; // wrap
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell9ModeState === 'number') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 45; // wrap
                            if (n > 45) n = 45;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 6; // wrap
                            if (n > 6) n = 6;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });

                    btnGroup.appendChild(up);
                    btnGroup.appendChild(down);

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const hasValue = inp.type === 'number' ? v !== '' : (v !== '' && v !== '_');
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                        dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                        container.style.borderRadius = '10px';
                        container.style.padding = '2px';
                        container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                        container.style.opacity = hasValue ? '1' : '0.85';
                    };

                    // attach input handlers depending on mode
                    inp.addEventListener('input', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    inp.addEventListener('change', () => {
                        if (cell9ModeState === 'number') clampForNumberMode(); else clampForLabelMode();
                        updateDraggable();
                    });
                    updateDraggable();

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    return container;
                });
            };
            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;


            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    // Track drag-over state to avoid redundant style updates
                    let isDragOverThis = false;

                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        dropHandled = false;
                        container.style.opacity = "0.4";
                        container.style.cursor = "grabbing";
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        container.style.cursor = "grab";
                        // If drop didn't happen (dragged outside), delete the value
                        if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                            inputs[idx].value = "";
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                        }
                        draggedIndex = null;
                        dropHandled = false;
                        isDragOverThis = false;
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";

                        // Only update styles if not already in drag-over state
                        if (!isDragOverThis) {
                            isDragOverThis = true;
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        isDragOverThis = false;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        dropHandled = true;
                        const draggedData = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');
                        isDragOverThis = false;

                        // Swap with a single place box
                        if (placeIndexData !== null && placeIndexData !== '') {
                            const srcIdx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                                const incoming = placeVals[srcIdx];
                                const outgoing = inputs[idx].value;
                                inputs[idx].value = incoming || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                placeVals[srcIdx] = outgoing || '';
                                if (window.setPlaceValues) window.setPlaceValues(placeVals);
                                if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                                if (run) run();
                                draggedIndex = null;
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                return;
                            }
                        }
                        // Accept place set (6 numbers)
                        if (placeSetData) {
                            try {
                                let values = JSON.parse(placeSetData);
                                if (Array.isArray(values) && values.length === 6) {
                                    // In label mode, reverse values to match reversed display
                                    if (cell9ModeState === 'label') {
                                        values = values.reverse();
                                    }
                                    for (let i = 0; i < 6; i++) {
                                        inputs[i].value = values[i] || '';
                                        inputs[i].dispatchEvent(new Event("input"));
                                    }
                                    if (run) run();
                                }
                            } catch (err) { }
                        }
                        // Kéo số/label trực tiếp từ popup (chỉ nếu không phải internal drag)
                        else if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                            const numVal = parseInt(draggedData, 10);
                            if (cell9ModeState === 'number' && numVal >= 1 && numVal <= 45) {
                                inputs[idx].value = numVal;
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            } else if (cell9ModeState === 'label') {
                                const col = getCol(numVal);
                                inputs[idx].value = col || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            }
                        }
                        // Kéo label từ header popup khi mode = label
                        else if (draggedIndex === null && labelData && cell9ModeState === 'label') {
                            inputs[idx].value = labelData.replace('C', '');
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                            draggedIndex = null;
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            return;
                        }
                        // Otherwise swap
                        else if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            if (run) run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const consec = document.createElement("input"); consec.type = "checkbox"; const consecLabel = document.createElement("label"); consecLabel.className = "flex"; consecLabel.append(consec, document.createTextNode("Liền kề"));
            const controls = document.createElement("div"); controls.className = "controls";

            // Add mode toggle button
            controls.appendChild(modeBtn);

            const inputLabel = document.createElement("span"); inputLabel.textContent = cell9ModeState === "number" ? "Bộ số:" : "Label:"; inputLabel.style.fontWeight = "700"; inputLabel.style.fontSize = "14px"; inputLabel.style.marginLeft = "12px";
            controls.appendChild(inputLabel);

            // For label mode, reverse the containers for proper left-to-right display
            const containersToAdd = cell9ModeState === "label" ? [...containers].reverse() : containers;
            containersToAdd.forEach(c => controls.appendChild(c));
            controls.append(consecLabel);
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });
            body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            try { controls.appendChild(recencySel); } catch (e) { }

            function run() {
                const mode = cell9ModeState;

                // Build pairCounts & computeRule for rule column (same as Cell6.5)
                const __c9_pairCounts = new Map();
                try {
                    rows.forEach(rr => {
                        try {
                            const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                            for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                const key = `${ns[i]}-${ns[j]}`;
                                __c9_pairCounts.set(key, (__c9_pairCounts.get(key) || 0) + 1);
                            }
                        } catch (e) { }
                    });
                } catch (e) { }
                const __c9_computeRule = (sixNums) => {
                    try {
                        if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                        const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                        if (userNums.length !== 6) return '';
                        const MAX_N = 44;
                        let found = null;
                        for (let n = MAX_N; n >= 1; n--) {
                            for (const cand of userNums) {
                                const others = [];
                                for (let y = 1; y <= 45; y++) {
                                    if (y === cand) continue;
                                    const a = Math.min(cand, y), b = Math.max(cand, y);
                                    const key = `${a}-${b}`;
                                    const c = __c9_pairCounts.get(key) || 0;
                                    others.push({ y, c });
                                }
                                others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                const pick = others.slice(0, n).map(o => o.y);
                                const otherFive = userNums.filter(x => x !== cand);
                                const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                if (!conflict) { found = { n, cand, pick }; break; }
                            }
                            if (found) break;
                        }
                        if (!found) {
                            const cand = userNums[0];
                            const others = [];
                            for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = __c9_pairCounts.get(key) || 0; others.push({ y, c }); }
                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                            found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                        }
                        const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                        remaining.sort((a, b) => a - b);
                        return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                    } catch (e) { return ''; }
                };

                if (mode === "number") {
                    const vals = inputs.map(i => parseInt(i.value, 10)).filter(v => !isNaN(v) && v >= 1 && v <= 45);
                    if (!vals.length) { wrap.innerHTML = "<div class='loader'>Điền ít nhất 1 số...</div>"; return; }
                    const inputFreq = {};
                    vals.forEach(v => { inputFreq[v] = (inputFreq[v] || 0) + 1; });
                    const setVals = new Set(vals);
                    const records = rows.filter(r => {
                        const rowFreq = {};
                        r.nums.forEach(v => { rowFreq[v] = (rowFreq[v] || 0) + 1; });
                        for (const num in inputFreq) {
                            if ((rowFreq[num] || 0) < inputFreq[num]) return false;
                        }
                        if (consec.checked) return hasConsecutiveBlock(r.nums, setVals);
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào phù hợp</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, setVals, setVals.size, consec.checked);
                            const labelHtml = renderHighlightedLabel(r.label, positions);
                            const ruleHtml = __c9_computeRule(r.nums);
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell9
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell9_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = wrap.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // Attach Ctrl+click handler for cell9 (use delegation on wrap so all inner cards/tables are covered)
                    (function attachRowHoverAndCtrlClick_cell9() {
                        try {
                            wrap.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                                if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                            });

                            wrap.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell9_ctrl_selected', result); } catch (e) { }
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                    else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // Reapply persisted Ctrl-selected highlight (persist across renders) for cell8
                    try {
                        const persisted = (function () { try { return localStorage.getItem('cell8_ctrl_selected'); } catch (e) { return null; } })();
                        if (persisted) {
                            const _tbody_reapply = wrap.querySelector('tbody');
                            if (_tbody_reapply) {
                                const m = _tbody_reapply.querySelector(`tr[data-result="${persisted}"]`);
                                if (m) m.classList.add('ctrl-selected');
                            }
                        }
                    } catch (e) { /* ignore reapply errors */ }

                    // Attach Ctrl+click handler for cell8
                    (function attachRowHoverAndCtrlClick_cell8() {
                        try {
                            const _tbody = wrap.querySelector('tbody');
                            if (!_tbody) return;
                            _tbody.addEventListener('mouseover', (ev) => {
                                const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                if (!tr) return;
                                const cardEl = tr.closest('.card');
                                if (!cardEl) return;
                                const s = cardEl.querySelector('strong');
                                if (!s) return;
                                const nums = (s.textContent || '').replace(/[{}]/g, '').split(/[^0-9]+/).map(p => parseInt(p, 10)).filter(Number.isFinite);
                                if (nums.length) { try { window.__popupHighlights = nums.slice(); window.__popupHighlightSource = cardEl; } catch (e) { } applyPopupHighlights(nums); }
                            });
                            _tbody.addEventListener('click', (ev) => {
                                try {
                                    if (!ev || !ev.ctrlKey) return;
                                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                                    if (!tr) return;
                                    ev.preventDefault();
                                    const result = tr.dataset && tr.dataset.result ? tr.dataset.result : null;
                                    if (!result) return;
                                    const nums = parseSixNumbersFromString(result);
                                    if (!nums) return;
                                    try { document.querySelectorAll('tr.ctrl-selected').forEach(r => r.classList.remove('ctrl-selected')); } catch (e) { }
                                    tr.classList.add('ctrl-selected');
                                    try { localStorage.setItem('cell8_ctrl_selected', result); } catch (e) { }
                                    try { if (typeof window.ensureRendered === 'function') window.ensureRendered('cell6_6'); } catch (e) { }
                                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_6"]');
                                    if (navBtn) { setTimeout(() => { try { navBtn.click(); } catch (e) { } setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 220); }, 200); }
                                    else { setTimeout(() => { try { if (typeof applySixToCell6_6 === 'function') applySixToCell6_6(nums); } catch (e) { } }, 260); }
                                } catch (e) { }
                            });
                        } catch (err) { }
                    })();
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                } else {
                    const labels = inputs.map(i => { const v = i.value.trim(); return v ? v[0] : null; }).filter(v => v !== null);
                    if (!labels.length) { wrap.innerHTML = "<div class='loader'>Điền ít nhất 1 ký tự...</div>"; return; }
                    const inputFreq = {};
                    labels.forEach(ch => { inputFreq[ch] = (inputFreq[ch] || 0) + 1; });
                    const totalCount = labels.length;
                    const inputKeys = Object.keys(inputFreq);
                    const keySet = new Set(inputKeys);

                    const records = rows.filter(r => {
                        const labelStr = r.label;
                        const rowFreq = {};
                        for (const ch of labelStr) rowFreq[ch] = (rowFreq[ch] || 0) + 1;
                        for (const ch of inputKeys) {
                            if ((rowFreq[ch] || 0) < inputFreq[ch]) return false;
                        }
                        if (consec.checked) {
                            for (let i = 0; i <= labelStr.length - totalCount; i++) {
                                const block = labelStr.slice(i, i + totalCount);
                                const blockFreq = {};
                                for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                let ok = true;
                                for (const ch of inputKeys) {
                                    if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                }
                                if (ok) return true;
                            }
                            return false;
                        }
                        return true;
                    });
                    if (!records.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào phù hợp</div>"; return; }
                    let display = records.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted'>${records.length} kỳ</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const labelStr = r.label;
                            let highlightPos = [];
                            if (consec.checked) {
                                let start = -1;
                                for (let s = 0; s <= labelStr.length - totalCount && start === -1; s++) {
                                    const block = labelStr.slice(s, s + totalCount);
                                    const blockFreq = {};
                                    for (const ch of block) blockFreq[ch] = (blockFreq[ch] || 0) + 1;
                                    let ok = true;
                                    for (const ch of inputKeys) {
                                        if ((blockFreq[ch] || 0) < inputFreq[ch]) { ok = false; break; }
                                    }
                                    if (ok) start = s;
                                }
                                if (start !== -1) {
                                    highlightPos = Array.from({ length: totalCount }, (_, k) => start + k);
                                }
                            }
                            if (!highlightPos.length) {
                                for (let pos = 0; pos < labelStr.length; pos++) {
                                    if (keySet.has(labelStr[pos])) highlightPos.push(pos);
                                }
                            }
                            // Create a set of highlighted column numbers from label chars
                            const highlightedLabelChars = new Set(highlightPos.map(pos => labelStr[pos]));
                            // Convert column chars to numbers 1-45 that belong to those columns
                            const highlightedNums = new Set();
                            for (let num = 1; num <= 45; num++) {
                                if (highlightedLabelChars.has(String(getCol(num)))) {
                                    highlightedNums.add(num);
                                }
                            }
                            const { html: numsHtml, positions } = renderHighlightedNums(r.nums, highlightedNums, totalCount, consec.checked);
                            const labelHtml = renderHighlightedLabel(labelStr, highlightPos);
                            const ruleHtml = __c9_computeRule(r.nums);
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${numsHtml}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                    // ensure viewport shows controls + results consistently
                    setTimeout(() => { requestAnimationFrame(() => { try { window.scrollTo({ top: 240, behavior: 'auto' }); } catch (e) { try { document.scrollingElement.scrollTop = 240; } catch (err) { } } }); }, 160);
                }
            }

            const applyCell9Mode = (mode, { notify = true } = {}) => {
                if (mode !== 'number' && mode !== 'label') return;
                if (!notify && cell9ModeState === mode) return;

                cell9ModeState = mode;
                modeBtn.textContent = cell9ModeState === 'number' ? 'Bộ số (1-45)' : 'Label (1-6)';

                // Clear old drag listeners by removing and recreating containers
                document.querySelectorAll(".drag-input-container").forEach(c => {
                    c.style.opacity = "1";
                    c.style.transform = "";
                });

                inputs = createInputs(mode);
                containers = createContainers(inputs);

                // Reset draggedIndex to prevent stale references
                draggedIndex = null;

                setupDragListeners(containers);
                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                inputLabel.textContent = mode === "number" ? "Bộ số:" : "Label:";

                // Insert containers in visual order (avoid accidental reversal)
                const containersToAdd = mode === "label" ? [...containers].reverse() : containers;
                let anchor = inputLabel;
                containersToAdd.forEach(c => {
                    anchor.parentNode.insertBefore(c, anchor.nextSibling);
                    anchor = c;
                });

                // Navigation based on visual order (containersToAdd defines on-screen order)
                const navOrder = containersToAdd.map(c => parseInt(c.dataset.index, 10));
                const attachKeyHandlers = () => {
                    inputs.forEach((inp, logicalIdx) => {
                        inp.oninput = run;
                        inp.onkeydown = (e) => {
                            if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                            e.preventDefault();
                            const pos = navOrder.indexOf(logicalIdx);
                            if (pos === -1) return;
                            const nextPos = e.key === 'ArrowLeft'
                                ? (pos > 0 ? pos - 1 : navOrder.length - 1)
                                : (pos < navOrder.length - 1 ? pos + 1 : 0);
                            const targetIdx = navOrder[nextPos];
                            inputs[targetIdx]?.focus();
                        };
                    });
                };
                attachKeyHandlers();

                if (notify) setNumberPickerMode(mode);
                run();
            };

            // Toggle button click to switch modes and notify popup
            modeBtn.addEventListener('click', () => {
                const next = cell9ModeState === 'number' ? 'label' : 'number';
                applyCell9Mode(next, { notify: false });
            });

            // Initial handlers for first render: use current visual order
            const initialContainers = cell9ModeState === "label" ? [...containers].reverse() : containers;
            const initialNavOrder = initialContainers.map(c => parseInt(c.dataset.index, 10));
            inputs.forEach((inp, logicalIdx) => {
                inp.oninput = run;
                inp.onkeydown = (e) => {
                    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
                    e.preventDefault();
                    const pos = initialNavOrder.indexOf(logicalIdx);
                    if (pos === -1) return;
                    const nextPos = e.key === 'ArrowLeft'
                        ? (pos > 0 ? pos - 1 : initialNavOrder.length - 1)
                        : (pos < initialNavOrder.length - 1 ? pos + 1 : 0);
                    const targetIdx = initialNavOrder[nextPos];
                    inputs[targetIdx]?.focus();
                };
            });
            consec.onchange = run; clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }
        function setValsIsSubset(setVals, arr) { for (const v of setVals) if (!arr.includes(v)) return false; return true; }
        function hasConsecutiveBlock(nums, setVals) {
            const k = setVals.size;
            for (let i = 0; i <= nums.length - k; i++) {
                const block = nums.slice(i, i + k);
                if (block.length === k && setValsIsSubset(setVals, block) && new Set(block).size === setVals.size) return true;
            }
            return false;
        }

        // Cell10: analyze other positions given value at order
        function renderCell10() {
            const body = sectionShell("cell10", "Cell10 · Phân tích các vị trí khác", "Điền 1 giá trị vào 1 ô để xem phân bố ở 5 vị trí còn lại. Có thể kéo thả giữa các vị trí.");
            // Mode toggle: Number (1–45) vs Column (1–6)
            const popupMode = window.getNumberPickerMode ? window.getNumberPickerMode() : "number";
            let cell10ModeState = popupMode === "label" ? "column" : "number";
            const modeBtn = document.createElement('button');
            modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';
            const inputs = Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });

            // per-input scroll memory and last active index for cell10
            window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
            window._cell10LastIndex = window._cell10LastIndex ?? null;

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const containers = inputs.map((inp, idx) => {
                const container = document.createElement("div");
                container.className = "drag-input-container";
                container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                container.draggable = false;

                const dragHandle = document.createElement("div");
                dragHandle.className = "drag-handle";
                dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                inp.style.position = "relative";
                inp.style.zIndex = "1";
                inp.style.paddingRight = '40px';
                inp.style.boxSizing = 'border-box';

                const btnGroup = document.createElement('div');
                btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                const clampForNumber = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 45) inp.value = '45';
                    else inp.value = String(n);
                };
                const clampForColumn = () => {
                    const raw = String(inp.value ?? '').trim();
                    if (raw === '') return;
                    let n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) { inp.value = ''; return; }
                    if (n < 1) inp.value = '1';
                    else if (n > 6) inp.value = '6';
                    else inp.value = String(n);
                };

                up.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 45) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n + 1;
                        if (n > 6) n = 1;
                        if (n < 1) n = 1;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });
                down.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (cell10ModeState === 'number') {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 45;
                        if (n > 45) n = 45;
                        inp.value = String(n);
                    } else {
                        let n = parseInt(String(inp.value ?? '').trim(), 10);
                        if (!Number.isFinite(n)) n = 0;
                        n = n - 1;
                        if (n < 1) n = 6;
                        if (n > 6) n = 6;
                        inp.value = String(n);
                    }
                    inp.dispatchEvent(new Event('input'));
                    if (run) run();
                });

                btnGroup.appendChild(up);
                btnGroup.appendChild(down);

                const updateDraggable = () => {
                    const v = String(inp.value ?? '').trim();
                    const hasValue = v !== '';
                    container.draggable = hasValue;
                    dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                    dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                    container.style.borderRadius = '10px';
                    container.style.padding = '2px';
                    container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                    container.style.opacity = hasValue ? '1' : '0.85';
                };

                inp.addEventListener('input', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                inp.addEventListener('change', () => {
                    if (cell10ModeState === 'number') clampForNumber(); else clampForColumn();
                    updateDraggable();
                });
                updateDraggable();

                container.appendChild(inp);
                container.appendChild(btnGroup);
                container.appendChild(dragHandle);
                container.dataset.index = idx;

                return container;
            });

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            containers.forEach((container, idx) => {
                container.addEventListener("dragstart", (e) => {
                    draggedIndex = idx;
                    dropHandled = false;
                    container.style.opacity = "0.4";
                    container.style.cursor = "grabbing";
                    e.dataTransfer.effectAllowed = "copyMove";
                    e.dataTransfer.setData("text/plain", inputs[idx].value);
                });

                container.addEventListener("dragend", (e) => {
                    container.style.opacity = "";
                    container.style.cursor = "grab";
                    // If drop didn't happen (dragged outside), delete the value
                    if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                        inputs[idx].value = "";
                        inputs[idx].dispatchEvent(new Event("input"));
                        if (run) run();
                    }
                    draggedIndex = null;
                    dropHandled = false;
                    containers.forEach(c => {
                        c.style.backgroundColor = "";
                        c.style.transform = "";
                    });
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                    container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                    container.style.transform = "scale(1.05)";
                });

                container.addEventListener("dragleave", (e) => {
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                });

                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropHandled = true;
                    const draggedData = e.dataTransfer.getData('text/plain');
                    const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                    const placeSetData = e.dataTransfer.getData('application/x-place-set');
                    const labelData = e.dataTransfer.getData('application/x-label');

                    // Swap with a single place box
                    if (placeIndexData !== null && placeIndexData !== '') {
                        const srcIdx = parseInt(placeIndexData, 10);
                        const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                        if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                            const incoming = placeVals[srcIdx];
                            const outgoing = inputs[idx].value;
                            inputs[idx].value = incoming || '';
                            inputs[idx].dispatchEvent(new Event("input"));
                            placeVals[srcIdx] = outgoing || '';
                            if (window.setPlaceValues) window.setPlaceValues(placeVals);
                            if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                            if (run) run(idx);
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            draggedIndex = null;
                            return;
                        }
                    }
                    // Accept place set (6 numbers)
                    if (placeSetData) {
                        try {
                            const values = JSON.parse(placeSetData);
                            if (Array.isArray(values) && values.length === 6) {
                                for (let i = 0; i < 6; i++) {
                                    inputs[i].value = values[i] || '';
                                    inputs[i].dispatchEvent(new Event("input"));
                                }
                                if (run) run(0);
                            }
                        } catch (err) { }
                    }
                    // Kéo số trực tiếp từ popup (chỉ nếu không phải internal drag)
                    else if (draggedIndex === null && draggedData && !isNaN(draggedData)) {
                        const num = parseInt(draggedData, 10);
                        if (cell10ModeState === 'number' && num >= 1 && num <= 45) {
                            inputs[idx].value = num;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        } else if (cell10ModeState === 'column' && num >= 1 && num <= 45) {
                            const col = getCol(num);
                            inputs[idx].value = col;
                            inputs[idx].dispatchEvent(new Event("input"));
                            run(idx);
                            return;
                        }
                    }
                    // Kéo label từ header popup khi mode = column
                    else if (draggedIndex === null && labelData && cell10ModeState === 'column') {
                        inputs[idx].value = labelData.replace('C', '');
                        inputs[idx].dispatchEvent(new Event("input"));
                        run(idx);
                        draggedIndex = null;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        return;
                    }
                    // Otherwise swap
                    else if (draggedIndex !== null && draggedIndex !== idx) {
                        const tempValue = inputs[idx].value;
                        inputs[idx].value = inputs[draggedIndex].value;
                        inputs[draggedIndex].value = tempValue;

                        inputs[idx].dispatchEvent(new Event("input"));
                        inputs[draggedIndex].dispatchEvent(new Event("input"));

                        if (run) run(idx);
                    }
                    container.style.backgroundColor = "";
                    container.style.transform = "";
                    draggedIndex = null;
                });
            });

            const controls = document.createElement("div"); controls.className = "controls";
            // Add mode toggle button
            controls.append(modeBtn);
            containers.forEach(c => controls.appendChild(c)); body.appendChild(controls);
            const wrap = document.createElement("div"); wrap.className = "card"; body.appendChild(wrap);
            wrap.addEventListener('dblclick', handleRowCopyDblClick);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);

            function run(changeIdx) {
                const prevScroll = window.scrollY;
                try {
                    if (changeIdx !== undefined && changeIdx !== null) {
                        window._cell10LastIndex = changeIdx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(changeIdx, prevScroll);
                    }
                } catch (e) { }

                const filled = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).filter(x => !isNaN(x.val));
                if (filled.length > 1 && changeIdx !== undefined) {
                    filled.filter(f => f.idx !== changeIdx).forEach(f => {
                        inputs[f.idx].value = "";
                        // Refresh drag visuals when value is cleared programmatically
                        inputs[f.idx].dispatchEvent(new Event("input"));
                    });
                }
                const single = inputs.map((inp, idx) => ({ idx, val: parseInt(inp.value, 10) })).find(x => !isNaN(x.val));
                if (!single) {
                    wrap.innerHTML = cell10ModeState === "number"
                        ? "<div class='loader'>Điền 1 số (1–45) vào 1 ô...</div>"
                        : "<div class='loader'>Điền 1 cột (1–6) vào 1 ô...</div>";
                    // restore scroll for same-input edits
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const order = single.idx + 1; const value = single.val;
                const posCols = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] }; const posMaps = { 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {} };
                let total = 0, hit = 0;
                const selectedPosNumbers = []; // Collect numbers at selected position for column mode
                rows.forEach(r => {
                    if (r.nums.length !== 6) return; total++;
                    const matched = (cell10ModeState === "number") ? (r.nums[order - 1] === value) : (getCol(r.nums[order - 1]) === value);
                    if (!matched) return; hit++;
                    if (cell10ModeState === "column") selectedPosNumbers.push(r.nums[order - 1]);
                    for (let pos = 1; pos <= 6; pos++) { if (pos === order) continue; const v = r.nums[pos - 1]; const c = getCol(v); posCols[pos].push(c); (posMaps[pos][c] ||= []).push(v); }
                });
                if (!hit) {
                    const what = cell10ModeState === "number" ? value : `cột ${value}`;
                    wrap.innerHTML = `<div class='error'>Không có kỳ nào với ${what} ở vị trí ${order}</div>`;
                    if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                        setTimeout(() => window.scrollTo(0, prevScroll), 0);
                    }
                    return;
                }
                const pattern = Array(6).fill("_"); pattern[order - 1] = (cell10ModeState === "number") ? value : `C${value}`;
                let html = `<div class='muted'>${hit}/${total} kỳ (${(hit / total * 100).toFixed(2)}%) · Pattern: ${pattern.join(',')}</div>`;

                // Show numbers at selected position for column mode
                if (cell10ModeState === "column" && selectedPosNumbers.length > 0) {
                    const numCounts = countMap(selectedPosNumbers);
                    const numsHtml = Object.entries(numCounts).sort((a, b) => b[1] - a[1]).map(([num, count]) =>
                        `<strong>${num}</strong><span style='font-weight:400'>(${count})</span>`
                    ).join(', ');
                    html += `<div style='margin-top:8px;font-weight:700;color:var(--text-strong);'>${numsHtml}</div>`;
                }

                const positionsBefore = [1, 2, 3, 4, 5, 6].filter(p => p < order);
                const positionsAfter = [1, 2, 3, 4, 5, 6].filter(p => p > order);
                const renderPosTable = (pos) => {
                    const counts = countMap(posCols[pos]);
                    let rowsHtml = Object.entries(counts).sort((a, b) => b[1] - a[1]).map(([c, n]) => {
                        const vals = countMap(posMaps[pos][c] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        return `<tr><td style='font-weight:700'>Cột ${c}</td><td style='text-align:right;font-weight:700'>${n}</td><td style='text-align:right;font-weight:700'>${fmtPct(n / posCols[pos].length)}</td><td style='font-weight:700'>${valsHtml || '—'}</td></tr>`;
                    }).join("");
                    return `<div class='card'><h4>Vị trí ${pos}</h4><table><thead><tr><th>Cột</th><th>Số lần</th><th>Tỷ lệ</th><th>Số hay đi cùng</th></tr></thead><tbody>${rowsHtml}</tbody></table></div>`;
                };
                // Column-mode: compact 4-column table (Column | Count | Percentage | Numbers), 6 rows ranked
                const renderPosTableColumn = (pos) => {
                    const counts = countMap(posCols[pos]);
                    const totalPos = posCols[pos].length || 1;
                    const items = [1, 2, 3, 4, 5, 6].map(c => ({ col: c, count: counts[c] || 0, pct: (counts[c] || 0) / totalPos }));
                    items.sort((a, b) => b.count - a.count || a.col - b.col);
                    // Ensure each card is at most 1/3 of the row and centered
                    let t = `<div class='card' style='flex:0 1 calc(33.333% - 10px);'><h4 style='margin:0 0 8px;'>Vị trí ${pos}</h4><table><thead><tr><th>Cột</th><th>Số lần</th><th>Tỷ lệ</th><th>Số hay xuất hiện</th></tr></thead><tbody>`;
                    items.forEach((it, idx) => {
                        const vals = countMap(posMaps[pos][it.col] || []);
                        const valsHtml = Object.entries(vals).sort((a, b) => b[1] - a[1]).map(([v, k]) => `<strong>${v}</strong><span style='font-weight:400'>(${k})</span>`).join(', ');
                        t += `<tr><td style='font-weight:700'>${it.col}</td><td style='text-align:right;font-weight:700'>${it.count}</td><td style='text-align:right;font-weight:700'>${fmtPct(it.pct)}</td><td style='font-weight:700'>${valsHtml || '—'}</td></tr>`;
                    });
                    t += "</tbody></table></div>";
                    return t;
                };
                if (positionsBefore.length) html += `<h4>Vị trí trước</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsBefore.map(renderPosTable) : positionsBefore.map(renderPosTableColumn)).join('')}</div>`;
                if (positionsAfter.length) html += `<h4>Vị trí sau</h4><div class='grid-centered'>${(cell10ModeState === "number" ? positionsAfter.map(renderPosTable) : positionsAfter.map(renderPosTableColumn)).join('')}</div>`;
                wrap.innerHTML = html;
                // restore scroll for same-input edits (prevent jump-to-top)
                if (changeIdx !== undefined && changeIdx !== null && window._cell10LastIndex === changeIdx) {
                    // small timeout to let layout settle
                    setTimeout(() => window.scrollTo(0, prevScroll), 0);
                }
            }
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                };
                inp.addEventListener('focus', () => {
                    try {
                        window._cell10LastIndex = idx;
                        window._cell10ScrollByIndex = window._cell10ScrollByIndex || new Map();
                        window._cell10ScrollByIndex.set(idx, window.scrollY);
                    } catch (e) { }
                });
            });
            clearBtn.onclick = () => {
                inputs.forEach(i => {
                    i.value = "";
                    // Refresh drag visuals after clear
                    i.dispatchEvent(new Event("input"));
                });
                run();
            };
            // Toggle button: adjust constraints, notify popup, clear values, rerun
            modeBtn.addEventListener('click', () => {
                cell10ModeState = cell10ModeState === 'number' ? 'column' : 'number';
                modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
                const newPopupMode = cell10ModeState === 'column' ? 'label' : 'number';
                if (window.setNumberPickerMode) window.setNumberPickerMode(newPopupMode);
                inputs.forEach(inp => {
                    if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                    else { inp.min = 1; inp.max = 6; inp.placeholder = '1–6'; }
                    inp.value = '';
                    inp.dispatchEvent(new Event('input'));
                });
                run();
            });
            // Subscribe to external mode changes
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    cell10ModeState = mode === 'label' ? 'column' : 'number';
                    modeBtn.textContent = cell10ModeState === 'number' ? 'Số (1–45)' : 'Cột (1–6)';
                    inputs.forEach(inp => {
                        if (cell10ModeState === 'number') { inp.min = 1; inp.max = 45; inp.placeholder = ''; }
                        else { inp.min = 1; inp.max = 6; inp.placeholder = '1–6'; }
                        inp.value = '';
                        inp.dispatchEvent(new Event('input'));
                    });
                    run();
                });
            }
            run();
        }
        function countMap(arr) { const m = {}; arr.forEach(v => m[v] = (m[v] || 0) + 1); return m; }

        // Cell11: pattern search 6 positions with commas, _ wildcard
        function renderCell11() {
            const body = sectionShell("cell11", "Cell11 · Tìm kỳ theo Pattern / Label", "Nhập số (1-45) hoặc label (1-6) vào từng vị trí để tìm kỳ khớp. Toggle chế độ Pattern / Label.");

            // Mode state: 'pattern' or 'label'
            let cell11Mode = 'pattern';
            const modeBtn = document.createElement('button');
            modeBtn.textContent = 'Pattern (1-45)';
            modeBtn.style.padding = '6px 10px';
            modeBtn.style.fontSize = '12px';
            modeBtn.style.cursor = 'pointer';

            // Create inputs factory based on mode
            const createInputs = (mode) => {
                if (mode === 'pattern') {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "number"; inp.min = 1; inp.max = 45; inp.placeholder = ""; inp.style.width = "70px"; return inp; });
                } else {
                    return Array.from({ length: 6 }, () => { const inp = document.createElement("input"); inp.type = "text"; inp.maxLength = 1; inp.placeholder = "_"; inp.size = 1; inp.style.width = "70px"; return inp; });
                }
            };

            let inputs = createInputs(cell11Mode);

            // Create draggable containers for inputs — add in-input up/down buttons and consistent sizing
            const createContainers = (inputArray) => {
                return inputArray.map((inp, idx) => {
                    const container = document.createElement("div");
                    container.className = "drag-input-container";
                    container.style.cssText = "position:relative;display:inline-block;margin-right:6px;overflow:hidden;vertical-align:middle;";
                    container.draggable = false;

                    const dragHandle = document.createElement("div");
                    dragHandle.className = "drag-handle";
                    dragHandle.style.cssText = `position:absolute;left:6px;top:50%;transform:translateY(-50%);width:16px;height:16px;cursor:grab;z-index:2;pointer-events:none;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);`;

                    inp.style.position = "relative";
                    inp.style.zIndex = "1";
                    inp.style.paddingRight = '40px';
                    inp.style.boxSizing = 'border-box';

                    const btnGroup = document.createElement('div');
                    btnGroup.style.cssText = 'position:absolute;right:6px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;z-index:3;pointer-events:auto;width:32px;align-items:center;';
                    const arrowStyle = 'width:22px;height:12px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:10px;line-height:12px;text-align:center;font-weight:700;';
                    const up = document.createElement('button'); up.type = 'button'; up.className = 'arrow-up'; up.innerHTML = '▲'; up.title = 'Tăng 1'; up.style.cssText = arrowStyle;
                    const down = document.createElement('button'); down.type = 'button'; down.className = 'arrow-down'; down.innerHTML = '▼'; down.title = 'Giảm 1'; down.style.cssText = arrowStyle;

                    const clampForPattern = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 45) inp.value = '45';
                        else inp.value = String(n);
                    };

                    const clampForLabel = () => {
                        const raw = String(inp.value ?? '').trim();
                        if (raw === '' || raw === '_') return;
                        let n = parseInt(raw, 10);
                        if (!Number.isFinite(n)) { inp.value = ''; return; }
                        if (n < 1) inp.value = '1';
                        else if (n > 6) inp.value = '6';
                        else inp.value = String(n);
                    };

                    up.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell11Mode === 'pattern') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 45) n = 1;
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n + 1;
                            if (n > 6) n = 1;
                            if (n < 1) n = 1;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });
                    down.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (cell11Mode === 'pattern') {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 45;
                            if (n > 45) n = 45;
                            inp.value = String(n);
                        } else {
                            let n = parseInt(String(inp.value ?? '').trim(), 10);
                            if (!Number.isFinite(n)) n = 0;
                            n = n - 1;
                            if (n < 1) n = 6;
                            if (n > 6) n = 6;
                            inp.value = String(n);
                        }
                        inp.dispatchEvent(new Event('input'));
                        if (run) run();
                    });

                    btnGroup.appendChild(up);
                    btnGroup.appendChild(down);

                    const updateDraggable = () => {
                        const v = String(inp.value ?? '').trim();
                        const hasValue = inp.type === 'number' ? v !== '' : (v !== '' && v !== '_');
                        container.draggable = hasValue;
                        dragHandle.style.pointerEvents = hasValue ? 'auto' : 'none';
                        dragHandle.style.cursor = hasValue ? 'grab' : 'default';
                        container.style.borderRadius = '10px';
                        container.style.padding = '2px';
                        container.style.border = hasValue ? '2px solid var(--accent)' : '2px solid transparent';
                        container.style.opacity = hasValue ? '1' : '0.85';
                    };

                    inp.addEventListener('input', () => {
                        if (cell11Mode === 'pattern') clampForPattern(); else clampForLabel();
                        updateDraggable();
                    });
                    inp.addEventListener('change', () => {
                        if (cell11Mode === 'pattern') clampForPattern(); else clampForLabel();
                        updateDraggable();
                    });
                    updateDraggable();

                    container.appendChild(inp);
                    container.appendChild(btnGroup);
                    container.appendChild(dragHandle);
                    container.dataset.index = idx;

                    // Double-click to paste clipboard (6 numbers)
                    container.addEventListener('dblclick', async (e) => {
                        e.stopPropagation();
                        let text = null;
                        try { if (navigator.clipboard && navigator.clipboard.readText) text = await navigator.clipboard.readText(); } catch (err) { text = null; }
                        if (!text || String(text).trim() === '') {
                            try { const res = window.prompt('Paste 6 numbers (comma or space separated), e.g. 29,3,35,24,18,30', ''); if (res && String(res).trim() !== '') text = res.trim(); } catch (ex) { text = null; }
                        }
                        if (!text) return;
                        // Label mode: accept a raw 6-digit string like "152345" → 1,5,2,3,4,5
                        if (cell11Mode === 'label') {
                            const raw = text.trim();
                            if (/^\d{6}$/.test(raw)) {
                                const digits = raw.split('').map(d => parseInt(d, 10));
                                if (digits.every(d => d >= 1 && d <= 6)) {
                                    for (let ii = 0; ii < 6; ii++) { inputs[ii].value = String(digits[ii]); inputs[ii].dispatchEvent(new Event('input')); }
                                    try { container.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (ex) { }
                                    if (run) run();
                                    return;
                                }
                            }
                        }
                        const parts = text.split(/[^0-9]+/).map(p => p.trim()).filter(Boolean);
                        if (parts.length !== 6) { try { container.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (ex) { } return; }
                        const parsed = parts.map(p => parseInt(p, 10));
                        if (parsed.some(n => !Number.isFinite(n) || n < 1)) { try { container.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (ex) { } return; }
                        if (cell11Mode === 'pattern') {
                            // Pattern mode: 6 distinct numbers 1-45
                            if (parsed.some(n => n > 45) || new Set(parsed).size !== 6) { try { container.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (ex) { } return; }
                            for (let ii = 0; ii < 6; ii++) { inputs[ii].value = String(parsed[ii]); inputs[ii].dispatchEvent(new Event('input')); }
                        } else {
                            // Label mode: if all values ≤6, accept directly; otherwise convert via getCol
                            const allLabel = parsed.every(n => n >= 1 && n <= 6);
                            if (allLabel) {
                                for (let ii = 0; ii < 6; ii++) { inputs[ii].value = String(parsed[ii]); inputs[ii].dispatchEvent(new Event('input')); }
                            } else {
                                if (parsed.some(n => n > 45)) { try { container.animate([{ boxShadow: '0 0 0 6px rgba(255,0,0,0.18)' }, { boxShadow: '0 0 0 0 rgba(255,0,0,0)' }], { duration: 420 }); } catch (ex) { } return; }
                                for (let ii = 0; ii < 6; ii++) { const col = getCol(parsed[ii]); inputs[ii].value = col ? String(col) : ''; inputs[ii].dispatchEvent(new Event('input')); }
                            }
                        }
                        try { container.animate([{ transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 }); } catch (ex) { }
                        if (run) run();
                    });

                    return container;
                });
            };

            let containers = createContainers(inputs);

            // Drag and drop logic
            let draggedIndex = null;
            let dropHandled = false;

            const setupDragListeners = (containerArray) => {
                containerArray.forEach((container, idx) => {
                    let isDragOverThis = false;

                    container.addEventListener("dragstart", (e) => {
                        draggedIndex = idx;
                        dropHandled = false;
                        container.style.opacity = "0.4";
                        container.style.cursor = "grabbing";
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.dataTransfer.setData("text/plain", inputs[idx].value);
                    });

                    container.addEventListener("dragend", (e) => {
                        container.style.opacity = "";
                        container.style.cursor = "grab";
                        if (!dropHandled && draggedIndex === idx && inputs[idx].value) {
                            inputs[idx].value = "";
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                        }
                        draggedIndex = null;
                        dropHandled = false;
                        isDragOverThis = false;
                        containerArray.forEach(c => {
                            c.style.backgroundColor = "";
                            c.style.transform = "";
                        });
                    });

                    container.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = draggedIndex !== null ? "move" : "copy";
                        if (!isDragOverThis) {
                            isDragOverThis = true;
                            container.style.backgroundColor = "rgba(56, 239, 125, 0.2)";
                            container.style.transform = "scale(1.05)";
                        }
                    });

                    container.addEventListener("dragleave", (e) => {
                        isDragOverThis = false;
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                    });

                    container.addEventListener("drop", (e) => {
                        e.preventDefault();
                        dropHandled = true;
                        isDragOverThis = false;
                        const draggedData = e.dataTransfer.getData('text/plain');
                        const placeIndexData = e.dataTransfer.getData('application/x-place-index');
                        const placeSetData = e.dataTransfer.getData('application/x-place-set');
                        const labelData = e.dataTransfer.getData('application/x-label');

                        // Swap with a single place box
                        if (placeIndexData !== null && placeIndexData !== '') {
                            const srcIdx = parseInt(placeIndexData, 10);
                            const placeVals = window.getPlaceValues ? [...window.getPlaceValues()] : null;
                            if (!isNaN(srcIdx) && placeVals && srcIdx >= 0 && srcIdx < 6) {
                                const incoming = placeVals[srcIdx];
                                const outgoing = inputs[idx].value;
                                if (cell11Mode === 'label') {
                                    const col = incoming ? getCol(parseInt(incoming, 10)) : '';
                                    inputs[idx].value = col ? String(col) : '';
                                } else {
                                    inputs[idx].value = incoming || '';
                                }
                                inputs[idx].dispatchEvent(new Event("input"));
                                placeVals[srcIdx] = outgoing || '';
                                if (window.setPlaceValues) window.setPlaceValues(placeVals);
                                if (window.markPlaceDropHandled) window.markPlaceDropHandled();
                                run();
                                container.style.backgroundColor = "";
                                container.style.transform = "";
                                draggedIndex = null;
                                return;
                            }
                        }
                        // Accept place set (6 numbers)
                        if (placeSetData) {
                            try {
                                const values = JSON.parse(placeSetData);
                                if (Array.isArray(values) && values.length === 6) {
                                    for (let i = 0; i < 6; i++) {
                                        if (cell11Mode === 'label') {
                                            const col = values[i] ? getCol(parseInt(values[i], 10)) : '';
                                            inputs[i].value = col ? String(col) : '';
                                        } else {
                                            inputs[i].value = values[i] || '';
                                        }
                                        inputs[i].dispatchEvent(new Event("input"));
                                    }
                                    if (run) run();
                                }
                            } catch (err) { }
                        }
                        // Kéo số/label trực tiếp từ popup
                        else if (draggedIndex === null && !placeIndexData && draggedData && !isNaN(draggedData)) {
                            const numVal = parseInt(draggedData, 10);
                            if (cell11Mode === 'pattern' && numVal >= 1 && numVal <= 45) {
                                inputs[idx].value = numVal;
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            } else if (cell11Mode === 'label') {
                                const col = getCol(numVal);
                                inputs[idx].value = col || '';
                                inputs[idx].dispatchEvent(new Event("input"));
                                if (run) run();
                                return;
                            }
                        }
                        // Kéo label từ header popup khi mode = label
                        else if (draggedIndex === null && labelData && cell11Mode === 'label') {
                            inputs[idx].value = labelData.replace('C', '');
                            inputs[idx].dispatchEvent(new Event("input"));
                            if (run) run();
                            draggedIndex = null;
                            container.style.backgroundColor = "";
                            container.style.transform = "";
                            return;
                        }
                        // Otherwise swap
                        else if (draggedIndex !== null && draggedIndex !== idx) {
                            const tempValue = inputs[idx].value;
                            inputs[idx].value = inputs[draggedIndex].value;
                            inputs[draggedIndex].value = tempValue;

                            inputs[idx].dispatchEvent(new Event("input"));
                            inputs[draggedIndex].dispatchEvent(new Event("input"));

                            run();
                        }
                        container.style.backgroundColor = "";
                        container.style.transform = "";
                        draggedIndex = null;
                    });
                });
            };

            setupDragListeners(containers);

            const controls = document.createElement("div"); controls.className = "controls";
            // Mode toggle button
            controls.appendChild(modeBtn);
            const labelText = document.createElement("span"); labelText.textContent = "Pattern:"; labelText.style.fontWeight = "700"; labelText.style.fontSize = "14px"; labelText.style.marginLeft = "12px";
            controls.appendChild(labelText);
            containers.forEach(c => controls.appendChild(c));
            const recencySel = document.createElement('select');[["desc", "Mới → Cũ"], ["asc", "Cũ → Mới"]].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; recencySel.appendChild(o); }); recencySel.value = 'desc';
            recencySel.addEventListener('change', () => { try { run(); } catch (e) { } });

            // Trash toggle for Cell11 — synced with Cell6.5/Cell6.6
            const trashSel = document.createElement('button');
            try { trashSel.id = 'cell11_trashSel'; trashSel.className = 'trash-mode trash-toggle'; trashSel.style.cssText = 'padding:6px 10px;margin-left:4px;vertical-align:middle;'; } catch (e) { }
            trashSel.type = 'button';
            trashSel.value = 'include';
            trashSel.textContent = 'include';
            trashSel.title = 'Click to toggle trash mode (include/exclude)';
            trashSel.addEventListener('click', () => {
                try {
                    trashSel.value = (trashSel.value === 'include') ? 'exclude' : 'include';
                    trashSel.textContent = trashSel.value;
                    try { const other = document.getElementById('cell6_5_trashSel'); if (other) { other.value = trashSel.value; if (other.textContent !== undefined) other.textContent = trashSel.value; } } catch (e) { }
                    try { const other = document.getElementById('cell6_6_trashSel'); if (other) { other.value = trashSel.value; if (other.textContent !== undefined) other.textContent = trashSel.value; } } catch (e) { }
                    try { trashSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { run(); } catch (e) { }
                } catch (e) { }
            });
            // keep synced when popup or other cells update trash
            try {
                document.addEventListener('trashchange', () => {
                    try {
                        const other = document.getElementById('cell6_5_trashSel') || document.getElementById('cell6_6_trashSel');
                        if (other && trashSel && trashSel.value !== other.value) { trashSel.value = other.value; trashSel.textContent = other.value; }
                    } catch (e) { }
                    try { run(); } catch (e) { }
                });
            } catch (e) { }

            // Fav toggle for Cell11 — mirror Cell6.6
            const favSel = document.createElement('button');
            try { favSel.id = 'cell11_favSel'; favSel.className = 'fav-mode fav-toggle'; } catch (e) { }
            favSel.type = 'button';
            favSel.value = 'exclude';
            favSel.textContent = 'exclude';
            favSel.title = 'Click to toggle fav mode (include/exclude)';
            favSel.style.padding = '6px 10px';
            favSel.style.marginLeft = '6px';
            favSel.addEventListener('click', () => {
                try {
                    favSel.value = (favSel.value === 'include') ? 'exclude' : 'include';
                    favSel.textContent = favSel.value;
                    try { favSel.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { }
                    try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                    try { run(); } catch (e) { }
                } catch (e) { }
            });
            // Ensure Cell11 redraws when the fav popup changes
            try {
                const secEl = document.getElementById('cell11');
                if (secEl && !secEl.__favListenerAdded) {
                    secEl.__favListenerAdded = true;
                    document.addEventListener('favchange', function () {
                        try {
                            const cur = document.getElementById('cell11_favSel');
                            if (cur && String(cur.value) === 'include') {
                                try { run(); } catch (err) { }
                            }
                        } catch (e) { }
                    });
                }
            } catch (e) { }

            controls.append('Trash:', trashSel, 'Fav:', favSel);

            body.appendChild(controls);

            const wrap = document.createElement("div"); wrap.className = "card card-inner"; body.appendChild(wrap);
            const clearBtn = document.createElement("button"); clearBtn.textContent = "Xóa"; clearBtn.className = "clear-btn"; controls.appendChild(clearBtn);

            // Add hint text
            const hint = document.createElement("div");
            hint.className = "muted";
            hint.style.cssText = "margin-top:8px;font-size:12px;";
            controls.appendChild(hint);
            // place recency select at end of controls
            controls.appendChild(recencySel);

            // Helper: get trash/fav filtered rows
            function getFilteredRows() {
                let source = rows.slice();
                // Trash filter
                const trashMode = trashSel.value || 'include';
                if (trashMode === 'exclude') {
                    const trashedArr = (typeof window.getTrashItems === 'function') ? window.getTrashItems() : (window.__trashItems || []);
                    const trashedSet = new Set((trashedArr || []).map(n => Number(n)));
                    if (trashedSet.size) {
                        source = source.filter(r => {
                            for (const nn of r.nums) if (trashedSet.has(Number(nn))) return false;
                            return true;
                        });
                    }
                }
                // Fav filter
                const favMode = favSel.value || 'exclude';
                if (favMode === 'include') {
                    let favs = [];
                    try {
                        if (window.getFavItems && typeof window.getFavItems === 'function') {
                            favs = (window.getFavItems() || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                        } else if (Array.isArray(window.__favItems) && window.__favItems.length) {
                            favs = (window.__favItems || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                        }
                    } catch (e) { }
                    if (favs.length) {
                        const favSet = new Set(favs);
                        source = source.filter(r => {
                            for (const nn of r.nums) if (favSet.has(Number(nn))) return true;
                            return false;
                        });
                    }
                }
                return source;
            }

            function run(changeIdx) {
                // Build pairCounts & computeRule for rule column (same as Cell6.5)
                const __c11_pairCounts = new Map();
                try {
                    rows.forEach(rr => {
                        try {
                            const ns = Array.isArray(rr.nums) ? rr.nums.slice().sort((a, b) => a - b) : [];
                            for (let i = 0; i < ns.length; i++) for (let j = i + 1; j < ns.length; j++) {
                                const key = `${ns[i]}-${ns[j]}`;
                                __c11_pairCounts.set(key, (__c11_pairCounts.get(key) || 0) + 1);
                            }
                        } catch (e) { }
                    });
                } catch (e) { }
                const __c11_computeRule = (sixNums) => {
                    try {
                        if (!Array.isArray(sixNums) || sixNums.length !== 6) return '';
                        const userNums = sixNums.map(n => Number(n)).filter(n => Number.isFinite(n));
                        if (userNums.length !== 6) return '';
                        const MAX_N = 44;
                        let found = null;
                        for (let n = MAX_N; n >= 1; n--) {
                            for (const cand of userNums) {
                                const others = [];
                                for (let y = 1; y <= 45; y++) {
                                    if (y === cand) continue;
                                    const a = Math.min(cand, y), b = Math.max(cand, y);
                                    const key = `${a}-${b}`;
                                    const c = __c11_pairCounts.get(key) || 0;
                                    others.push({ y, c });
                                }
                                others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                const pick = others.slice(0, n).map(o => o.y);
                                const otherFive = userNums.filter(x => x !== cand);
                                const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                if (!conflict) { found = { n, cand, pick }; break; }
                            }
                            if (found) break;
                        }
                        if (!found) {
                            const cand = userNums[0];
                            const others = [];
                            for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = __c11_pairCounts.get(key) || 0; others.push({ y, c }); }
                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                            found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                        }
                        const remaining = userNums.filter(x => Number(x) !== Number(found.cand)).map(n => Number(n)).filter(Number.isFinite);
                        remaining.sort((a, b) => a - b);
                        return `<span style="background:#FFD600;color:#000;font-weight:700;padding:1px 3px;border-radius:4px;display:inline-block;min-width:20px;text-align:center">${found.cand}</span>>{${remaining.join(',')}}<span style="background:#FF1744;color:#fff;font-weight:700;padding:1px 2px;border-radius:4px">[${found.n}]</span>`;
                    } catch (e) { return ''; }
                };

                const filteredRows = getFilteredRows();

                if (cell11Mode === 'pattern') {
                    // === PATTERN MODE (original logic) ===
                    const pattern = inputs.map(inp => {
                        const v = inp.value.trim();
                        if (!v) return "_";
                        const n = parseInt(v, 10);
                        return (n >= 1 && n <= 45) ? String(n) : "_";
                    });
                    if (!filteredRows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                    if (pattern.every(p => p === "_")) { wrap.innerHTML = "<div class='loader'>Nhập vào 1 ô để tìm kiếm...</div>"; return; }
                    const results = filteredRows.filter(r => pattern.every((p, i) => p === "_" || r.nums[i] === Number(p)));
                    if (!results.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào khớp pattern</div>"; return; }
                    const patternStr = pattern.join(',');
                    let display = results.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted' style='flex-basis:100%'>${results.length} kỳ · pattern ${patternStr}</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const nums = r.nums.map((v, idx) => pattern[idx] !== "_" ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`).join(" ");
                            const highlightPositions = pattern.map((p, i) => p === "_" ? -1 : i).filter(i => i >= 0);
                            const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                            const ruleHtml = __c11_computeRule(r.nums);
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                } else {
                    // === LABEL MODE: strict positional match ===
                    // Each input corresponds to a position in the 6-char label.
                    // If input[i] has a value v (1-6), then row.label[i] must === String(v).
                    // Empty inputs match any label character at that position.
                    const labelPattern = inputs.map(inp => {
                        const v = String(inp.value ?? '').trim();
                        if (!v || v === '_') return null;
                        const n = parseInt(v, 10);
                        return (n >= 1 && n <= 6) ? String(n) : null;
                    });
                    if (!filteredRows.length) { wrap.innerHTML = "<div class='loader'>Chưa có dữ liệu</div>"; return; }
                    if (labelPattern.every(p => p === null)) { wrap.innerHTML = "<div class='loader'>Điền ít nhất 1 ô (1-6) để tìm label...</div>"; return; }

                    const results = filteredRows.filter(r => {
                        const lbl = r.label;
                        if (!lbl || lbl.length < 6) return false;
                        for (let i = 0; i < 6; i++) {
                            if (labelPattern[i] !== null && lbl[i] !== labelPattern[i]) return false;
                        }
                        return true;
                    });

                    if (!results.length) { wrap.innerHTML = "<div class='error'>Không có kỳ nào khớp label pattern</div>"; return; }
                    const patternStr = labelPattern.map(p => p === null ? '_' : p).join(',');
                    let display = results.slice();
                    if (typeof recencySel !== 'undefined' && recencySel.value === 'desc') display.reverse();
                    let html = `<div class='muted' style='flex-basis:100%'>${results.length} kỳ · label ${patternStr}</div><div class='grid-centered'>`;
                    const chunk = 15;
                    for (let i = 0; i < display.length; i += chunk) {
                        html += "<div class='card'><table style='width:100%'><thead><tr><th>Ngày</th><th>KQ</th><th>Label</th><th>rule</th></tr></thead><tbody>";
                        display.slice(i, i + chunk).forEach(r => {
                            const highlightPositions = labelPattern.map((p, i) => p !== null ? i : -1).filter(i => i >= 0);
                            const nums = r.nums.map((v, idx) => {
                                const isMatch = highlightPositions.includes(idx);
                                return isMatch ? `<span class='pill' style='${MATCH_STYLE}width:28px;display:inline-block;text-align:center;'>${v}</span>` : `<span class='pill' style='background:#fffbea;color:#000;font-weight:700;width:28px;display:inline-block;text-align:center;'>${v}</span>`;
                            }).join(" ");
                            const labelHtml = renderHighlightedLabel(r.label, highlightPositions);
                            const ruleHtml = __c11_computeRule(r.nums);
                            html += `<tr data-result="${r.nums.join(',')}" title="k=x=${getRowTrashK(r)}" data-k="${getRowTrashK(r)}"><td>${r.date}</td><td>${nums}</td><td style='white-space:nowrap;'>${labelHtml}</td><td style='white-space:nowrap;'>${ruleHtml}</td></tr>`;
                        });
                        html += "</tbody></table></div>";
                    }
                    html += "</div>";
                    wrap.innerHTML = html;
                }
            }

            // Mode toggle
            const applyCell11Mode = (mode) => {
                if (mode !== 'pattern' && mode !== 'label') return;
                cell11Mode = mode;
                modeBtn.textContent = mode === 'pattern' ? 'Pattern (1-45)' : 'Label (1-6)';

                inputs = createInputs(mode);
                containers = createContainers(inputs);
                draggedIndex = null;
                setupDragListeners(containers);

                const oldContainers = controls.querySelectorAll(".drag-input-container");
                oldContainers.forEach(c => c.remove());

                labelText.textContent = mode === 'pattern' ? 'Pattern:' : 'Label:';

                let anchor = labelText;
                containers.forEach(c => {
                    anchor.parentNode.insertBefore(c, anchor.nextSibling);
                    anchor = c;
                });

                // Keyboard navigation
                inputs.forEach((inp, logicalIdx) => {
                    inp.oninput = () => run(logicalIdx);
                    inp.onkeydown = (e) => {
                        if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[logicalIdx > 0 ? logicalIdx - 1 : inputs.length - 1].focus(); }
                        if (e.key === 'ArrowRight') { e.preventDefault(); inputs[logicalIdx < inputs.length - 1 ? logicalIdx + 1 : 0].focus(); }
                        if (e.key === 'ArrowUp') { e.preventDefault(); let n = parseInt(String(inp.value ?? '').trim(), 10); if (!Number.isFinite(n)) n = 0; n++; if (cell11Mode === 'label') { if (n > 6) n = 1; } else { if (n > 45) n = 1; } if (n < 1) n = 1; inp.value = String(n); inp.dispatchEvent(new Event('input')); run(); }
                        if (e.key === 'ArrowDown') { e.preventDefault(); let n = parseInt(String(inp.value ?? '').trim(), 10); if (!Number.isFinite(n)) n = 0; n--; if (cell11Mode === 'label') { if (n < 1) n = 6; } else { if (n < 1) n = 45; } inp.value = String(n); inp.dispatchEvent(new Event('input')); run(); }
                    };
                });

                run();
            };

            modeBtn.addEventListener('click', () => {
                const next = cell11Mode === 'pattern' ? 'label' : 'pattern';
                applyCell11Mode(next);
            });

            // Initial key handlers
            inputs.forEach((inp, idx) => {
                inp.oninput = () => run(idx);
                inp.onkeydown = (e) => {
                    if (e.key === 'ArrowLeft') { e.preventDefault(); inputs[idx > 0 ? idx - 1 : inputs.length - 1].focus(); }
                    if (e.key === 'ArrowRight') { e.preventDefault(); inputs[idx < inputs.length - 1 ? idx + 1 : 0].focus(); }
                    if (e.key === 'ArrowUp') { e.preventDefault(); let n = parseInt(String(inp.value ?? '').trim(), 10); if (!Number.isFinite(n)) n = 0; n++; if (cell11Mode === 'label') { if (n > 6) n = 1; } else { if (n > 45) n = 1; } if (n < 1) n = 1; inp.value = String(n); inp.dispatchEvent(new Event('input')); run(); }
                    if (e.key === 'ArrowDown') { e.preventDefault(); let n = parseInt(String(inp.value ?? '').trim(), 10); if (!Number.isFinite(n)) n = 0; n--; if (cell11Mode === 'label') { if (n < 1) n = 6; } else { if (n < 1) n = 45; } inp.value = String(n); inp.dispatchEvent(new Event('input')); run(); }
                };
            });
            clearBtn.onclick = () => { inputs.forEach(i => i.value = ""); run(); };
            run();
        }

        async function bootstrap() {
            // Number picker popup
            const htmlBadge = document.getElementById('htmlBadge');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');
            const placesGrid = document.getElementById('placesGrid');
            let isPopupVisible = false;

            // Place state: [value1, value2, value3, value4, value5, value6]
            const placeValues = ['', '', '', '', '', ''];
            let draggedNumber = null;
            let draggedPlaceIndex = null;
            let draggedPlaceValue = null;
            let lastDropInsidePlace = false; // track if a place drag was dropped back into place
            let currentMode = 'number'; // 'number' or 'label'
            const modeListeners = new Set();

            const notifyModeChange = (mode, source) => {
                modeListeners.forEach(fn => fn(mode, source));
            };

            const setNumberPickerMode = (mode, source = 'picker') => {
                if (mode !== 'number' && mode !== 'label') return;
                if (currentMode === mode) return;
                currentMode = mode;
                modeSelector.value = mode;
                // Clear place values when switching mode
                placeValues.fill('');
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                notifyModeChange(mode, source);

                // Update connection toggle state when mode changes
                if (window.updateConnectionToggleState) {
                    window.updateConnectionToggleState();
                }

                // Update label cell styling based on new mode and place values
                updateLabelCellStyles();
            };

            window.setNumberPickerMode = (mode) => setNumberPickerMode(mode, 'external');
            window.getNumberPickerMode = () => currentMode;
            window.onNumberPickerModeChange = (cb) => {
                modeListeners.add(cb);
                return () => modeListeners.delete(cb);
            };

            // Quick-place toggle: two modes -> 'normal' (default) and 'hover' (hover a record to fill places)
            const quickPlaceToggleEl = document.getElementById('quickPlaceToggle');
            let quickPlaceMode = localStorage.getItem('quickPlaceMode') || 'normal';
            const setQuickPlaceMode = (mode) => {
                quickPlaceMode = mode === 'hover' ? 'hover' : 'normal';
                if (quickPlaceToggleEl) {
                    quickPlaceToggleEl.textContent = quickPlaceMode === 'normal' ? 'Normal' : 'Hover';
                    quickPlaceToggleEl.title = quickPlaceMode === 'normal'
                        ? "Normal: dblclick copies record to clipboard (existing behavior)"
                        : "Hover: hovering a record fills the place boxes (dblclick-copy disabled)";
                }
                localStorage.setItem('quickPlaceMode', quickPlaceMode);
                // When switching back to normal mode, remove any popup highlights
                try {
                    if (quickPlaceMode !== 'hover' && typeof clearPopupHighlights === 'function') clearPopupHighlights();
                } catch (e) { /* ignore */ }
            };
            window.getQuickPlaceMode = () => quickPlaceMode;
            // initialize
            setQuickPlaceMode(quickPlaceMode);
            if (quickPlaceToggleEl) {
                quickPlaceToggleEl.addEventListener('click', () => {
                    setQuickPlaceMode(quickPlaceMode === 'normal' ? 'hover' : 'normal');
                });
            }

            // Hover handler: when in 'hover' mode, moving mouse over any record row (tr[data-result])
            // will populate the placeValues and refresh place boxes. Throttled to avoid excessive updates.
            const hoverToPlaceHandler = createThrottle((e) => {
                try {
                    if (quickPlaceMode !== 'hover') return;
                    const tr = e.target.closest && e.target.closest('tr[data-result]');
                    if (!tr) return;
                    const text = tr.dataset.result;
                    if (!text) return;
                    const arr = text.split(',').map(s => (s || '').trim());
                    if (arr.length !== 6) return;

                    // Normalize and compare to avoid unnecessary work
                    let identical = true;
                    for (let i = 0; i < 6; i++) {
                        const v = arr[i] || '';
                        if ((placeValues[i] || '') !== v) { identical = false; break; }
                    }
                    if (identical) return;

                    // Clear previous visual highlights and overlays first to avoid stale backgrounds
                    try {
                        if (numberPickerTable) {
                            const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                            prev.forEach(p => p.classList.remove('selected-number'));
                            const disabledCells = numberPickerTable.querySelectorAll('td.number-cell.disabled');
                            disabledCells.forEach(c => c.classList.remove('selected-number'));
                        }
                        const existingOverlays = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                        existingOverlays.forEach(n => n.remove());
                        const placeBoxes = placesGrid.querySelectorAll('.place-box');
                        placeBoxes.forEach(pb => {
                            pb.classList.remove('filled');
                            const val = pb.querySelector('.place-box-value');
                            if (val) val.textContent = '_';
                            pb.style.removeProperty('backgroundColor');
                            pb.style.removeProperty('borderColor');
                        });
                    } catch (err) { /* ignore visual cleanup errors */ }

                    // Apply hovered values (replace all previous values)
                    for (let i = 0; i < 6; i++) placeValues[i] = arr[i] || '';

                    // Re-render and sync highlights/connections
                    generateNumberPickerTable();
                    generatePlaceBoxes();
                    try { if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights(); } catch (e) { }
                    drawConnections();
                } catch (err) { /* ignore */ }
            }, 80);
            document.addEventListener('mousemove', hoverToPlaceHandler, true);

            // Popup scale state
            const popupScaleState = { scale: 1.0 };
            window.__popupScaleState = popupScaleState;

            const savePopupScale = () => {
                localStorage.setItem('popupScale', JSON.stringify(popupScaleState.scale));
            };
            window.__savePopupScale = savePopupScale;

            const loadPopupScale = () => {
                const saved = localStorage.getItem('popupScale');
                if (saved) {
                    popupScaleState.scale = parseFloat(saved);
                }
            };

            const applyPopupScale = () => {
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
                try {
                    const tp = document.getElementById('trashPopup');
                    if (tp) {
                        tp.style.transform = `scale(${popupScaleState.scale})`;
                        tp.style.transformOrigin = 'top right';
                    }
                } catch (e) { }
                try {
                    const fp = document.getElementById('favPopup');
                    if (fp) {
                        fp.style.transform = `scale(${popupScaleState.scale})`;
                        fp.style.transformOrigin = 'top right';
                    }
                } catch (e) { }
                try {
                    const dp = document.getElementById('draftPopup');
                    if (dp) {
                        dp.style.transform = `scale(${popupScaleState.scale})`;
                        dp.style.transformOrigin = 'top left';
                    }
                } catch (e) { }
                try { if (typeof adjustFavPosition === 'function') adjustFavPosition(); } catch (e) { }
            };
            window.__applyPopupScale = applyPopupScale;

            const applyPopupScaleInstant = () => {
                // Apply scale instantly without transition animation
                const oldTransition = numberPickerPopup.style.transition;
                numberPickerPopup.style.transition = 'none';
                numberPickerPopup.style.transform = `scale(${popupScaleState.scale})`;
                try {
                    const tp = document.getElementById('trashPopup');
                    if (tp) {
                        const oldT = tp.style.transition;
                        tp.style.transition = 'none';
                        tp.style.transform = `scale(${popupScaleState.scale})`;
                        tp.style.transformOrigin = 'top right';
                        // force layout read to apply instantly
                        void tp.offsetHeight;
                        tp.style.transition = oldT;
                    }
                } catch (e) { }
                try {
                    const fp = document.getElementById('favPopup');
                    if (fp) {
                        const oldF = fp.style.transition;
                        fp.style.transition = 'none';
                        fp.style.transform = `scale(${popupScaleState.scale})`;
                        fp.style.transformOrigin = 'top right';
                        void fp.offsetHeight;
                        fp.style.transition = oldF;
                    }
                } catch (e) { }
                try {
                    const dp = document.getElementById('draftPopup');
                    if (dp) {
                        const oldD = dp.style.transition;
                        dp.style.transition = 'none';
                        dp.style.transform = `scale(${popupScaleState.scale})`;
                        dp.style.transformOrigin = 'top left';
                        void dp.offsetHeight;
                        dp.style.transition = oldD;
                    }
                } catch (e) { }
                // Force browser to process the change
                void numberPickerPopup.offsetHeight;
                numberPickerPopup.style.transition = oldTransition;
                try { if (typeof adjustFavPosition === 'function') adjustFavPosition(); } catch (e) { }
            };

            const addPopupScaleHandle = () => {
                let handle = numberPickerPopup.querySelector('.popup-scale-handle');
                if (handle) handle.remove();

                handle = document.createElement('div');
                handle.className = 'popup-scale-handle';

                let isScaling = false;
                let startX = 0;
                let startScale = popupScaleState.scale;

                handle.addEventListener('mousedown', (e) => {
                    isScaling = true;
                    startX = e.clientX;
                    startScale = popupScaleState.scale;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScaling) return;
                    const diff = e.clientX - startX;
                    const newScale = Math.max(0.5, Math.min(2, startScale + diff * 0.0025));
                    popupScaleState.scale = parseFloat(newScale.toFixed(3));
                    applyPopupScale();
                    // update trash popup while scaling so its size/position follows immediately
                    try { if (typeof adjustTrashPosition === 'function') adjustTrashPosition(); } catch (err) { }
                });

                document.addEventListener('mouseup', () => {
                    if (isScaling) {
                        isScaling = false;
                        savePopupScale();
                    }
                });

                numberPickerPopup.appendChild(handle);
            };

            loadPopupScale();

            // Add a mirrored scale handle for the trash popup (bottom-left)
            const addTrashScaleHandle = () => {
                const trash = document.getElementById('trashPopup');
                if (!trash) return;
                let th = trash.querySelector('.trash-scale-handle');
                if (th) th.remove();
                th = document.createElement('div');
                th.className = 'trash-scale-handle';

                let isScalingT = false;
                let startX_T = 0;
                let startScale_T = popupScaleState.scale;

                th.addEventListener('mousedown', (e) => {
                    isScalingT = true;
                    startX_T = e.clientX;
                    startScale_T = popupScaleState.scale;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScalingT) return;
                    // inverted horizontal direction because handle is on bottom-left
                    const diff = startX_T - e.clientX;
                    const newScale = Math.max(0.5, Math.min(2, startScale_T + diff * 0.0025));
                    popupScaleState.scale = parseFloat(newScale.toFixed(3));
                    applyPopupScale();
                    try { if (typeof adjustTrashPosition === 'function') adjustTrashPosition(); } catch (err) { }
                });

                document.addEventListener('mouseup', () => {
                    if (isScalingT) {
                        isScalingT = false;
                        savePopupScale();
                    }
                });

                trash.appendChild(th);
            };

            // apply initial scale instantly and attach trash handle if element exists
            try { applyPopupScaleInstant(); } catch (e) { }
            try { addTrashScaleHandle(); } catch (e) { }

            // Generate number picker table (rotated 90° counter-clockwise)
            function generateNumberPickerTable() {
                const numbersInPlace = currentMode === 'number'
                    ? new Set(placeValues.filter(v => v && v.trim() && !isNaN(v)))
                    : new Set();

                // Preserve trashed numbers by reading existing DOM state before we overwrite it.
                // This avoids relying on `trashItems` being in scope here.
                const existingTrash = new Set();
                try {
                    if (numberPickerTable) {
                        Array.from(numberPickerTable.querySelectorAll('td.in-trash')).forEach(td => {
                            const v = td.dataset && td.dataset.number ? Number(td.dataset.number) : NaN;
                            if (!isNaN(v)) existingTrash.add(v);
                        });
                    }
                } catch (e) { /* ignore */ }

                const numbersByCol = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
                for (let i = 1; i <= 45; i++) {
                    const col = getCol(i);
                    numbersByCol[col].push(i);
                }

                const tbodyDisabled = currentMode === 'label' ? ' class="disabled"' : '';
                const tfootDisabled = currentMode === 'number' ? ' class="disabled"' : '';

                let html = `<tbody${tbodyDisabled}>`;
                for (let row = 7; row >= 0; row--) {
                    html += '<tr>';
                    for (let col = 1; col <= 6; col++) {
                        const nums = numbersByCol[col];
                        const num = nums[row] || '_';
                        if (num === '_') {
                            html += `<td style="color:var(--muted);opacity:0.5;">_</td>`;
                        } else {
                            const isDisabled = numbersInPlace.has(String(num));
                            const disabledClass = isDisabled ? ' disabled' : '';
                            const inTrashFlag = existingTrash.has(Number(num));
                            // If a number is both in trash and present in the place boxes,
                            // mark it with an additional class so we can render a 50% dimmed
                            // overlay instead of the full solid red used for trashed-only items.
                            const inTrashDim = inTrashFlag && numbersInPlace.has(String(num));
                            const inTrashClass = inTrashDim ? ' in-trash in-trash-dim' : (inTrashFlag ? ' in-trash' : '');
                            let draggable = (isDisabled || currentMode === 'label' || inTrashFlag) ? 'false' : 'true';
                            // Check rank toggle; when enabled, show [#x] inside the same cell, left-aligned,
                            // while keeping the number centered.
                            const rankToggleEl = document.getElementById('rankToggle');
                            const rankEnabled = !!rankToggleEl && rankToggleEl.textContent.trim() === 'rank';
                            if (rankEnabled) {
                                const rankMap = window.rankByTotal || {};
                                const r = rankMap[num] ?? '';
                                // Only render badge when we have a rank value
                                let badgeHtml = '';
                                if (r !== '' && r !== null && r !== undefined) {
                                    const rankNum = Number(r);
                                    let color = 'var(--muted)';
                                    if (!isNaN(rankNum)) {
                                        if (rankNum >= 1 && rankNum <= 9) color = '#08eb56';
                                        else if (rankNum >= 10 && rankNum <= 18) color = '#00E5FF';
                                        else if (rankNum >= 19 && rankNum <= 27) color = '#1a62ea';
                                        else if (rankNum >= 28 && rankNum <= 36) color = '#ea3ade';
                                        else if (rankNum >= 37 && rankNum <= 45) color = '#ea0313';
                                    }
                                    badgeHtml = `<span class="rank-in-cell" style="position:absolute;left:6px;top:50%;transform:translateY(-50%);font-size:0.92em;font-weight:900;color:${color};background:transparent;opacity:1;z-index:2;-webkit-text-stroke:0.4px rgba(0,0,0,0.6);text-shadow:0 0 1px rgba(0,0,0,0.22);letter-spacing:0.6px;">#${rankNum}</span>`;
                                }
                                html += `<td class="number-cell${disabledClass}${inTrashClass}" draggable="${draggable}" data-number="${num}" style="position:relative;min-height:44px;">` +
                                    `${badgeHtml}` +
                                    `<span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span>` +
                                    `</td>`;
                            } else {
                                html += `<td class="number-cell${disabledClass}${inTrashClass}" draggable="${draggable}" data-number="${num}"><span style="display:block;text-align:center;font-weight:700;font-size:1em;padding:6px 0;">${num}</span></td>`;
                            }
                        }
                    }
                    html += '</tr>';
                }
                html += '</tbody>';

                html += `<tfoot${tfootDisabled}><tr>`;
                for (let col = 1; col <= 6; col++) {
                    html += `<th class="label-cell" data-label="C${col}" draggable="true" style="cursor: grab;">C${col}</th>`;
                }
                html += '</tr></tfoot>';

                numberPickerTable.innerHTML = html;
                // If there is an active hover-driven highlight set, reapply after regeneration
                try {
                    if (window.__popupHighlights && Array.isArray(window.__popupHighlights) && window.__popupHighlights.length) {
                        applyPopupHighlights(window.__popupHighlights);
                    }
                } catch (e) { /* ignore */ }

                // Ensure favorite markers are synced after regeneration
                try { syncFavHighlights(); } catch (e) { /* ignore */ }

                // Update label cell column states (trashed/fav indicators) after regeneration
                try { if (typeof window.__updateLabelCellColStates === 'function') window.__updateLabelCellColStates(); } catch (e) { /* ignore */ }

                // Draw connections after table is rendered
                requestAnimationFrame(() => drawConnections());
            }

            // Draw connections between consecutive numbers in place boxes
            function drawConnections() {
                const connectionToggle = document.getElementById('connectionToggle');
                const connectionsEnabled = !!connectionToggle && connectionToggle.textContent.trim() === 'Hiện';
                const euclidToggle = document.getElementById('euclidToggle');
                const euclidEnabled = !!euclidToggle && euclidToggle.textContent.trim() === 'Hiện';
                // Only draw in number mode and when connections are enabled
                if (currentMode !== 'number' || !connectionsEnabled) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Find consecutive pairs in placeValues
                const pairs = [];
                for (let i = 0; i < placeValues.length - 1; i++) {
                    const curr = placeValues[i];
                    const next = placeValues[i + 1];
                    if (curr && curr.trim() && !isNaN(curr) && next && next.trim() && !isNaN(next)) {
                        pairs.push([parseInt(curr, 10), parseInt(next, 10)]);
                    }
                }

                if (pairs.length === 0) {
                    const existingCanvas = document.getElementById('connectionCanvas');
                    if (existingCanvas) existingCanvas.remove();
                    return;
                }

                // Get or create canvas
                let canvas = document.getElementById('connectionCanvas');
                const wrapper = numberPickerTable.parentElement;

                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.id = 'connectionCanvas';
                    canvas.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:1';
                    wrapper.appendChild(canvas);
                }

                const tableRect = numberPickerTable.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();

                // Get current popup scale
                const scale = popupScaleState.scale;

                // Get device pixel ratio for sharp rendering
                const dpr = window.devicePixelRatio || 1;

                // Canvas should match unscaled table size (divide by scale)
                const canvasWidth = tableRect.width / scale;
                const canvasHeight = tableRect.height / scale;

                // Set canvas display size (CSS pixels, unscaled)
                canvas.style.width = canvasWidth + 'px';
                canvas.style.height = canvasHeight + 'px';

                // Set canvas actual size (device pixels)
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;

                // Position canvas to align with table within wrapper (unscaled coordinates)
                canvas.style.left = '0px';
                canvas.style.top = '0px';

                const ctx = canvas.getContext('2d');
                // Scale context to match device pixel ratio
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Store circle centers for line drawing
                const circleCenters = {};
                const circleRadius = 9;

                // Theme-aware colors
                const cssVars = getComputedStyle(document.documentElement);
                const lineColor = (cssVars.getPropertyValue('--connection-line-color') || '#00cc00').trim();
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const circleColor = currentTheme === 'light' ? lineColor : '#667eea';

                // Draw circles around all numbers in placeValues
                const allNumbers = placeValues
                    .filter(v => v && v.trim() && !isNaN(v))
                    .map(v => parseInt(v, 10));

                allNumbers.forEach(num => {
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (!cell) return;

                    const cellRect = cell.getBoundingClientRect();

                    // Apply scale factor to coordinates
                    const x = (cellRect.left - tableRect.left) / scale + (cellRect.width / scale) / 2;
                    const y = (cellRect.top - tableRect.top) / scale + (cellRect.height / scale) / 2;

                    // Store center for line drawing
                    circleCenters[num] = { x, y };

                    // Draw circle (stroke, not fill)
                    ctx.strokeStyle = circleColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                // Draw lines between consecutive pairs, starting from circle edge
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);

                pairs.forEach(([num1, num2]) => {
                    const center1 = circleCenters[num1];
                    const center2 = circleCenters[num2];
                    if (!center1 || !center2) return;

                    const x1 = center1.x;
                    const y1 = center1.y;
                    const x2 = center2.x;
                    const y2 = center2.y;

                    // Calculate angle from center1 to center2
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    // Start line from the edge of circle1, pointing toward circle2
                    const startX = x1 + circleRadius * Math.cos(angle);
                    const startY = y1 + circleRadius * Math.sin(angle);

                    // End line at the edge of circle2, pointing back toward circle1
                    const endX = x2 - circleRadius * Math.cos(angle);
                    const endY = y2 - circleRadius * Math.sin(angle);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // --- Draw Euclidean distance (in grid cell units) near the middle of the line ---
                    try {
                        // Find grid row/col indices by inspecting tbody rows and cell positions
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${num1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${num2}"]`);
                        if (cell1 && cell2 && tbodyRows.length > 0) {
                            const rowElem1 = cell1.parentElement;
                            const rowElem2 = cell2.parentElement;
                            const rowIdx1 = tbodyRows.indexOf(rowElem1); // 0..n-1 (top -> bottom)
                            const rowIdx2 = tbodyRows.indexOf(rowElem2);

                            // In generator rows are created from row=7 down to 0, so logicalRow = 7 - rowIndex
                            const logicalRow1 = 7 - rowIdx1;
                            const logicalRow2 = 7 - rowIdx2;

                            const colIdx1 = Array.from(rowElem1.children).indexOf(cell1); // 0..5 left->right
                            const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);

                            const dx = colIdx2 - colIdx1;
                            const dy = logicalRow2 - logicalRow1;
                            const gridDistance = Math.sqrt(dx * dx + dy * dy);

                            // Midpoint of drawn segment
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;

                            // Place label directly on the line midpoint (overlay the connection)
                            const labelX = midX;
                            const labelY = midY;

                            // Draw label background for readability (only when euclid toggle enabled)
                            if (euclidEnabled) {
                                const labelText = gridDistance.toFixed(2);
                                ctx.save();
                                ctx.setLineDash([]);
                                ctx.font = '12px Inter, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                // measure
                                const metrics = ctx.measureText(labelText);
                                const paddingX = 6;
                                const paddingY = 3;
                                const rectW = metrics.width + paddingX * 2;
                                const rectH = 12 + paddingY * 2;

                                // Semi-transparent background
                                ctx.fillStyle = currentTheme === 'light' ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.7)';
                                ctx.beginPath();
                                ctx.roundRect
                                    ? ctx.roundRect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH, 4)
                                    : ctx.rect(labelX - rectW / 2, labelY - rectH / 2, rectW, rectH);
                                ctx.fill();

                                // Draw text
                                ctx.fillStyle = currentTheme === 'light' ? '#000' : '#fff';
                                ctx.fillText(labelText, labelX, labelY);
                                ctx.restore();
                            }
                        }
                    } catch (e) {
                        // ignore label drawing errors to avoid breaking connections
                    }
                });
            }

            // Generate place boxes - 6 individual boxes
            function generatePlaceBoxes() {
                placesGrid.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const placeBox = document.createElement('div');
                    placeBox.className = `place-box ${placeValues[i] ? 'filled' : ''}`;
                    placeBox.dataset.placeIndex = i;
                    // Always allow dragging so an empty slot can receive a swapped value
                    placeBox.draggable = true;

                    // Dblclick to paste clipboard into all 6 slots (number mode only)
                    placeBox.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        pasteClipboardToPlaces();
                    });

                    const value = document.createElement('div');
                    value.className = 'place-box-value';
                    value.textContent = placeValues[i] || '_';
                    placeBox.appendChild(value);

                    placeBox.addEventListener('dragstart', (e) => {
                        draggedPlaceIndex = i;
                        draggedPlaceValue = placeValues[i];
                        lastDropInsidePlace = false;
                        e.dataTransfer.effectAllowed = 'copyMove';
                        e.dataTransfer.setData('text/plain', placeValues[i] || '');
                        e.dataTransfer.setData('application/x-place-index', String(i));
                        e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    });

                    placeBox.addEventListener('dragend', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        if (!lastDropInsidePlace && draggedPlaceValue) {
                            placeValues[draggedPlaceIndex] = '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                        draggedPlaceIndex = null;
                        draggedPlaceValue = null;
                    });

                    placeBox.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                        placeBox.style.borderColor = 'var(--accent-2)';
                        placeBox.style.backgroundColor = 'rgba(102, 126, 234, 0.25)';
                    });

                    placeBox.addEventListener('dragleave', () => {
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';
                    });

                    placeBox.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        lastDropInsidePlace = true;
                        placeBox.style.borderColor = 'var(--accent)';
                        placeBox.style.backgroundColor = placeValues[i] ? 'rgba(56, 239, 125, 0.25)' : 'rgba(56, 239, 125, 0.1)';

                        if (draggedPlaceIndex !== null && draggedPlaceIndex !== i) {
                            const tmp = placeValues[i];
                            placeValues[i] = draggedPlaceValue || '';
                            placeValues[draggedPlaceIndex] = tmp || '';
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            document.querySelectorAll('.place-box').forEach(box => {
                                box.style.removeProperty('borderColor');
                                box.style.removeProperty('backgroundColor');
                                box.style.removeProperty('opacity');
                            });
                            const placeContainer = numberPickerPopup.querySelector('.place-container');
                            if (placeContainer) {
                                placeContainer.style.removeProperty('borderColor');
                                placeContainer.style.removeProperty('backgroundColor');
                                placeContainer.style.removeProperty('opacity');
                            }
                            return;
                        }

                        let data = e.dataTransfer.getData('application/x-place-set');
                        if (data) {
                            try {
                                const values = JSON.parse(data);
                                for (let j = 0; j < 6; j++) {
                                    placeValues[j] = values[j] || '';
                                }
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                                return;
                            } catch (err) { }
                        }

                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData && currentMode === 'label') {
                            const colNum = labelData.replace('C', '');
                            placeValues[i] = colNum;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                            return;
                        }

                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num) && currentMode === 'number') {
                            placeValues[i] = num;
                            generateNumberPickerTable();
                            generatePlaceBoxes();
                            setupNumberCellDragDrop();
                            setupLabelCellDragDrop();
                            updateLabelCellStyles();
                        }
                    });

                    placesGrid.appendChild(placeBox);
                }
                // remove old overlays if any
                const existing = numberPickerPopup.querySelectorAll('.place-distance-overlay');
                existing.forEach(n => n.remove());

                // helper: compute grid distance like drawConnections does
                function computeGridDistance(n1, n2) {
                    try {
                        const tbody = numberPickerTable.querySelector('tbody');
                        const tbodyRows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
                        const cell1 = numberPickerTable.querySelector(`td[data-number="${n1}"]`);
                        const cell2 = numberPickerTable.querySelector(`td[data-number="${n2}"]`);
                        if (!cell1 || !cell2 || tbodyRows.length === 0) return null;
                        const rowElem1 = cell1.parentElement;
                        const rowElem2 = cell2.parentElement;
                        const rowIdx1 = tbodyRows.indexOf(rowElem1);
                        const rowIdx2 = tbodyRows.indexOf(rowElem2);
                        const logicalRow1 = 7 - rowIdx1;
                        const logicalRow2 = 7 - rowIdx2;
                        const colIdx1 = Array.from(rowElem1.children).indexOf(cell1);
                        const colIdx2 = Array.from(rowElem2.children).indexOf(cell2);
                        const dx = colIdx2 - colIdx1;
                        const dy = logicalRow2 - logicalRow1;
                        return Math.sqrt(dx * dx + dy * dy);
                    } catch (e) { return null; }
                }

                // For each adjacent pair, if both filled and euclid enabled, create overlay
                const boxes = placesGrid.querySelectorAll('.place-box');
                // position overlays relative to the places grid so they sit centered
                // between the .place-box elements even when the popup is scrolled
                const containerRect = placesGrid.getBoundingClientRect();
                for (let i = 0; i < boxes.length - 1; i++) {
                    const a = placeValues[i];
                    const b = placeValues[i + 1];
                    if (currentMode === 'number' && euclidState && a && b && !isNaN(a) && !isNaN(b)) {
                        const boxA = boxes[i];
                        const boxB = boxes[i + 1];
                        if (!boxA || !boxB) continue;
                        // compute centers relative to placesGrid using offset values
                        const aCenterX = boxA.offsetLeft + boxA.offsetWidth / 2;
                        const bCenterX = boxB.offsetLeft + boxB.offsetWidth / 2;
                        const aCenterY = boxA.offsetTop + boxA.offsetHeight / 2;
                        const bCenterY = boxB.offsetTop + boxB.offsetHeight / 2;
                        const midX = (aCenterX + bCenterX) / 2;
                        const midY = (aCenterY + bCenterY) / 2;
                        const overlay = document.createElement('div');
                        overlay.className = 'place-distance-overlay';
                        const dist = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                        overlay.textContent = dist === null ? '' : dist.toFixed(2);
                        // set position inside placesGrid (no viewport -> container conversion needed)
                        overlay.style.left = midX + 'px';
                        overlay.style.top = midY + 'px';
                        placesGrid.appendChild(overlay);
                    }
                }
                // Compute total Euclidean distance for adjacent pairs and update display
                try {
                    const euclidTotalEl = document.getElementById('euclidTotal');
                    let total = 0;
                    for (let j = 0; j < boxes.length - 1; j++) {
                        const a = placeValues[j];
                        const b = placeValues[j + 1];
                        if (currentMode === 'number' && a && b && !isNaN(a) && !isNaN(b)) {
                            const d = computeGridDistance(parseInt(a, 10), parseInt(b, 10));
                            if (d !== null) total += d;
                        }
                    }
                    if (euclidTotalEl) {
                        // update nested value span if present
                        const valEl = document.getElementById('euclidTotalValue');
                        if (valEl) {
                            valEl.textContent = total.toFixed(2);
                            // ensure accent green emphasis remains
                            valEl.style.color = '#38ef7d';
                        } else {
                            euclidTotalEl.textContent = `Σ: ${total.toFixed(2)}`;
                        }
                        euclidTotalEl.style.opacity = (euclidState && currentMode === 'number') ? '1' : '0.5';
                    }
                } catch (e) { /* ignore */ }
                // Sync label and number highlights and redraw connections
                try {
                    updateLabelCellStyles();
                } catch (e) { /* ignore */ }
                try {
                    if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights();
                } catch (e) { /* ignore */ }
                try { drawConnections(); } catch (e) { /* ignore */ }
                try { if (typeof updateRankSummary === 'function') updateRankSummary(); } catch (e) { /* ignore */ }
            }

            function setupPlaceContainerListeners() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                placeContainer.draggable = true;

                placeContainer.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.dataTransfer.setData('text/plain', JSON.stringify(placeValues));
                    e.dataTransfer.setData('application/x-place-set', JSON.stringify(placeValues));
                    placeContainer.style.opacity = '0.6';
                });

                placeContainer.addEventListener('dragend', () => {
                    placeContainer.style.opacity = '1';
                });

                placeContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                });

                placeContainer.addEventListener('dragleave', (e) => {
                    if (e.target === placeContainer) {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }
                });

                placeContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    lastDropInsidePlace = true;
                    placeContainer.style.borderColor = 'var(--accent)';
                    placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';

                    if (currentMode === 'number') {
                        const num = e.dataTransfer.getData('text/plain');
                        if (num && !isNaN(num)) {
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = num;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                                updateLabelCellStyles();
                            }
                        }
                    } else if (currentMode === 'label') {
                        const labelData = e.dataTransfer.getData('application/x-label');
                        if (labelData) {
                            const colNum = labelData.replace('C', '');
                            const firstEmpty = placeValues.findIndex(v => !v);
                            if (firstEmpty >= 0) {
                                placeValues[firstEmpty] = colNum;
                                generateNumberPickerTable();
                                generatePlaceBoxes();
                                setupNumberCellDragDrop();
                                setupLabelCellDragDrop();
                            }
                        }
                    }
                });
            }

            function setupNumberCellDragDrop() {
                // Use event delegation on the table to ensure handlers work
                // after the table is re-rendered and to avoid duplicate listeners.
                if (!numberPickerTable) return;
                if (numberPickerTable.dataset.dragDelegation === 'true') return;
                numberPickerTable.dataset.dragDelegation = 'true';

                numberPickerTable.addEventListener('dragstart', (e) => {
                    const cell = e.target.closest('.number-cell');
                    if (!cell) return;
                    // Respect explicit draggable attribute set on cells
                    const draggableAttr = cell.getAttribute('draggable');
                    if (draggableAttr === 'false') return;
                    draggedNumber = cell.dataset.number;
                    try {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('text/plain', draggedNumber);
                    } catch (err) {
                        // Some environments may restrict dataTransfer; fail silently
                    }
                });

                numberPickerTable.addEventListener('dragend', () => {
                    draggedNumber = null;
                });
            }

            function setupLabelCellDragDrop() {
                if (!numberPickerTable) return;
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    // Skip if already setup (has data attribute)
                    if (cell.dataset.dragSetup === 'true') return;

                    // Clone to remove all old event listeners
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    // Explicitly set draggable to ensure it works after cloneNode
                    newCell.draggable = true;
                    newCell.dataset.dragSetup = 'true';

                    newCell.addEventListener('dragstart', (e) => {
                        const label = newCell.dataset.label;
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('application/x-label', label);
                        newCell.style.opacity = '0.5';
                    });

                    newCell.addEventListener('dragend', () => {
                        newCell.style.opacity = '1';
                    });
                });
            }

            // Update label cell styling based on place values
            function updateLabelCellStyles() {
                if (!numberPickerTable) return;
                const tfoot = numberPickerTable.tFoot;

                if (currentMode !== 'number') {
                    // In label mode, make all label cells bright and draggable (only inside popup)
                    const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                    labelCells.forEach(cell => cell.classList.add('with-values'));
                    if (tfoot) tfoot.classList.remove('disabled');
                    return;
                }

                // In number mode, determine which columns have values in placeValues
                const columnsWithValues = new Set();
                placeValues.forEach(val => {
                    if (val && val.trim() && !isNaN(val)) {
                        const num = parseInt(val, 10);
                        const col = getCol(num); // Use existing getCol helper
                        columnsWithValues.add(col);
                    }
                });

                // If any columns have values, remove disabled class from tfoot to show labels bright
                if (columnsWithValues.size > 0) {
                    if (tfoot) tfoot.classList.remove('disabled');
                } else {
                    if (tfoot) tfoot.classList.add('disabled');
                }

                // Update label cell styling
                const labelCells = numberPickerTable.querySelectorAll('.label-cell');
                labelCells.forEach(cell => {
                    const label = cell.dataset.label; // e.g., "C1", "C2", ...
                    const colNum = parseInt(label.substring(1), 10); // Extract column number
                    if (columnsWithValues.has(colNum)) {
                        cell.classList.add('with-values');
                    } else {
                        cell.classList.remove('with-values');
                    }
                });
            }

            // Update number-cell highlights to match placeValues
            function updateNumberCellHighlights() {
                if (!numberPickerTable) return;
                // remove previous highlights
                const prev = numberPickerTable.querySelectorAll('td.number-cell.selected-number');
                prev.forEach(p => p.classList.remove('selected-number'));

                if (currentMode !== 'number') return;

                // add highlight for each placed number
                placeValues.forEach(v => {
                    if (!v || v === '' || isNaN(v)) return;
                    const num = String(parseInt(v, 10));
                    const cell = numberPickerTable.querySelector(`td[data-number="${num}"]`);
                    if (cell) cell.classList.add('selected-number');
                });
            }

            // Render a compact summary of place values by rank color/type
            function updateRankSummary() {
                const el = document.getElementById('rankSummary');
                if (!el) return;
                const mapping = {
                    Green: '#08eb56',
                    Cyan: '#00E5FF',
                    Blue: '#1a62ea',
                    Pink: '#ea3ade',
                    Red: '#ea0313'
                };
                const counts = { Green: 0, Cyan: 0, Blue: 0, Pink: 0, Red: 0 };
                const order = ['Green', 'Cyan', 'Blue', 'Pink', 'Red'];

                for (let i = 0; i < placeValues.length; i++) {
                    const v = placeValues[i];
                    if (!v || v === '' || isNaN(v)) continue;
                    const num = parseInt(v, 10);
                    const rankMap = window.rankByTotal || {};
                    const rankNum = rankMap[num] || null;
                    let name = null;
                    if (rankNum !== null && rankNum !== undefined) {
                        if (rankNum >= 1 && rankNum <= 9) name = 'Green';
                        else if (rankNum >= 10 && rankNum <= 18) name = 'Cyan';
                        else if (rankNum >= 19 && rankNum <= 27) name = 'Blue';
                        else if (rankNum >= 28 && rankNum <= 36) name = 'Pink';
                        else if (rankNum >= 37 && rankNum <= 45) name = 'Red';
                    }
                    if (name) counts[name] = (counts[name] || 0) + 1;
                }

                // Build display
                const parts = [];
                order.forEach((nm) => {
                    const c = counts[nm];
                    if (c && c > 0) {
                        const color = mapping[nm] || 'var(--muted)';
                        parts.push(`<span style="color:${color};font-weight:900">${c}${nm}</span>`);
                    }
                });
                if (parts.length === 0) {
                    el.innerHTML = '<span style="color:var(--muted)">—</span>';
                } else {
                    // join with muted separator
                    el.innerHTML = parts.join('<span style="color:var(--muted);margin:0 6px"> - </span>');
                }
            }

            const modeSelector = document.getElementById('modeSelector');
            let modeState = 'number';
            modeSelector.addEventListener('click', () => {
                modeState = modeState === 'number' ? 'label' : 'number';
                modeSelector.textContent = modeState === 'number' ? 'Số (1-45)' : 'Label (C1-C6)';
                setNumberPickerMode(modeState, 'picker');
            });

            const modeRows = document.getElementById('modeRows');
            // Sync mode button when mode changes from external sources (cell9/10)
            if (window.onNumberPickerModeChange) {
                window.onNumberPickerModeChange((mode) => {
                    modeState = mode;
                    modeSelector.textContent = mode === 'number' ? 'Số (1-45)' : 'Label (C1-C6)';
                });
            }

            // Connection toggle
            const connectionToggle = document.getElementById('connectionToggle');
            const connectionToggleLabel = document.getElementById('connectionToggleLabel');
            const euclidToggle = document.getElementById('euclidToggle');
            const euclidToggleLabel = document.getElementById('euclidToggleLabel');

            const updateConnectionToggleState = () => {
                const isNumberMode = currentMode === 'number';
                connectionToggle.disabled = !isNumberMode;
                if (connectionToggleLabel) {
                    connectionToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                }
                connectionToggle.style.opacity = isNumberMode ? '1' : '0.5';
                connectionToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Euclid toggle should follow same availability rules as connection toggle
                if (euclidToggle) euclidToggle.disabled = !isNumberMode;
                if (euclidToggleLabel) euclidToggleLabel.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.opacity = isNumberMode ? '1' : '0.5';
                if (euclidToggle) euclidToggle.style.cursor = isNumberMode ? 'pointer' : 'not-allowed';

                // Update Euclid total display availability
                const euclidTotalEl = document.getElementById('euclidTotal');
                if (euclidTotalEl) euclidTotalEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';
                // also dim the numeric value if present
                const euclidValEl = document.getElementById('euclidTotalValue');
                if (euclidValEl) euclidValEl.style.opacity = (isNumberMode && euclidState) ? '1' : '0.5';

                // Redraw when toggled
                drawConnections();
            };

            // Expose globally for mode change callback
            window.updateConnectionToggleState = updateConnectionToggleState;

            let connectionState = true;
            connectionToggle.addEventListener('click', () => {
                connectionState = !connectionState;
                connectionToggle.textContent = connectionState ? 'Hiện' : 'Ẩn';
                drawConnections();
            });

            // Euclid toggle state and handler
            let euclidState = true; // default visible
            if (euclidToggle) {
                euclidToggle.textContent = euclidState ? 'Hiện' : 'Ẩn';
                euclidToggle.addEventListener('click', () => {
                    euclidState = !euclidState;
                    euclidToggle.textContent = euclidState ? 'Hiện' : 'Ẩn';
                    drawConnections();
                    // Refresh place overlays and Euclid total display
                    try { generatePlaceBoxes(); } catch (e) { /* ignore if not ready */ }
                });
            }

            // Initialize connection toggle state
            updateConnectionToggleState();

            // Paste clipboard into place (dblclick on any place box) when in number mode
            async function pasteClipboardToPlaces() {
                const placeContainer = numberPickerPopup.querySelector('.place-container');
                const flashFail = (reason) => {
                    console.log('Paste failed:', reason);
                    if (!placeContainer) return;
                    placeContainer.style.borderColor = '#ef4444';
                    placeContainer.style.backgroundColor = 'rgba(239, 68, 68, 0.14)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 450);
                };

                if (currentMode !== 'number') {
                    flashFail('wrong mode: ' + currentMode);
                    return;
                }

                const readClipboard = async () => {
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        return navigator.clipboard.readText();
                    }
                    if (window.clipboardData && window.clipboardData.getData) {
                        return window.clipboardData.getData('Text');
                    }
                    return null;
                };

                let txt = null;
                try {
                    txt = await readClipboard();
                    console.log('Raw clipboard result:', JSON.stringify(txt));
                } catch (err) {
                    console.error('Clipboard read error:', err);
                    flashFail('clipboard error: ' + err.message);
                    return;
                }

                if (txt === null || txt === undefined) {
                    console.error('Clipboard returned null - API blocked or not available');
                    flashFail('clipboard blocked (chạy qua http:// thay vì file://)');
                    return;
                }

                txt = txt.trim();
                if (!txt) {
                    flashFail('clipboard empty');
                    return;
                }

                const parts = txt.split(',').map(s => s.trim());
                console.log('Parts after split:', parts, 'length:', parts.length);
                if (parts.length !== 6) {
                    flashFail(`expected 6 parts, got ${parts.length}`);
                    return;
                }
                const next = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i];
                    if (p === '' || p === '_') { next.push(''); continue; }
                    const n = parseInt(p, 10);
                    console.log(`Part ${i}: "${p}" -> ${n}, valid: ${Number.isFinite(n) && n >= 1 && n <= 45}`);
                    if (!Number.isFinite(n) || n < 1 || n > 45) {
                        flashFail(`invalid number at position ${i + 1}: "${p}"`);
                        return;
                    }
                    next.push(String(n));
                }

                console.log('Paste successful:', next);
                for (let i = 0; i < 6; i++) placeValues[i] = next[i] || '';
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
                // Ensure any lingering popup highlight state is cleared after paste
                try {
                    if (typeof clearPopupHighlights === 'function') clearPopupHighlights();
                    try { window.__popupHighlights = null; window.__popupHighlightSource = null; } catch (e) { }
                } catch (e) { }
                if (placeContainer) {
                    placeContainer.style.borderColor = 'var(--accent-2)';
                    placeContainer.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                    setTimeout(() => {
                        placeContainer.style.borderColor = 'var(--accent)';
                        placeContainer.style.backgroundColor = 'rgba(56, 239, 125, 0.08)';
                    }, 400);
                }
            }

            const clearPlaceBtn = document.getElementById('clearPlaceBtn');
            clearPlaceBtn.addEventListener('click', () => {
                for (let i = 0; i < placeValues.length; i++) {
                    placeValues[i] = '';
                }
                // Also clear any popup highlights (orange outline) and popup state
                try {
                    clearPopupHighlights();
                    window.__popupHighlights = null;
                    window.__popupHighlightSource = null;
                } catch (e) { /* ignore */ }

                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                updateLabelCellStyles();
            });

            // Optional color picker (removed from UI) — attach listener only if element exists
            const cellColorPicker = document.getElementById('cellColorPicker');
            if (cellColorPicker) {
                cellColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    // Update CSS variable instead of inline style to preserve hover effects
                    document.documentElement.style.setProperty('--cell-bg-color', color);
                });
            }

            // Wrap table in a relative-positioned container
            const tableWrapper = document.createElement('div');
            tableWrapper.style.position = 'relative';
            numberPickerTable.parentElement.insertBefore(tableWrapper, numberPickerTable);
            tableWrapper.appendChild(numberPickerTable);

            generateNumberPickerTable();
            generatePlaceBoxes();
            setupPlaceContainerListeners();
            setupNumberCellDragDrop();
            setupLabelCellDragDrop();

            // Rank toggle handler: toggles between 'unnank' and 'rank' and re-renders the table
            const rankToggleBtn = document.getElementById('rankToggle');
            if (rankToggleBtn) {
                rankToggleBtn.addEventListener('click', () => {
                    const cur = rankToggleBtn.textContent.trim();
                    const next = cur === 'rank' ? 'unnank' : 'rank';
                    rankToggleBtn.textContent = next;
                    // Re-generate table to show/hide ranks
                    try { generateNumberPickerTable(); setupNumberCellDragDrop(); } catch (e) { console.warn(e); }
                });
            }

            // Apply saved scale and add scale handle
            applyPopupScale();
            addPopupScaleHandle();

            // Helper: desired popup alpha based on inline slider (preserve across open/close)
            const __POPUP_MIN_ALPHA = 0.15;
            function __desiredPopupAlpha() {
                try {
                    const el = document.getElementById('popupOpacityRangeInline');
                    if (!el) return 1;
                    const pct = Number(el.value || 0);
                    if (pct === 0) return 1;
                    return 1 - (pct / 100) * (1 - __POPUP_MIN_ALPHA);
                } catch (e) { return 1; }
            }

            // Close button
            const closeNumberPickerBtn = document.getElementById('closeNumberPickerBtn');
            closeNumberPickerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Clear any orange popup highlights and related state
                try {
                    clearPopupHighlights();
                    window.__popupHighlights = null;
                    window.__popupHighlightSource = null;
                } catch (err) { /* ignore */ }

                isPopupVisible = false;
                numberPickerPopup.style.opacity = '0';
                setTimeout(() => {
                    numberPickerPopup.style.display = 'none';
                }, 300);
                // also hide trash and fav popups when picker closes
                try { const t = document.getElementById('trashPopup'); if (t) t.style.display = 'none'; } catch (e) { }
                try { const f = document.getElementById('favPopup'); if (f) f.style.display = 'none'; } catch (e) { }
                // Hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.remove('visible');
                }
            });

            // Toggle popup on click
            htmlBadge.addEventListener('click', (e) => {
                e.stopPropagation();
                isPopupVisible = !isPopupVisible;

                if (isPopupVisible) {
                    // Apply scale BEFORE showing to prevent flash
                    applyPopupScaleInstant();

                    const savedPos = localStorage.getItem('popupPosition');
                    if (savedPos) {
                        const { top, left } = JSON.parse(savedPos);
                        numberPickerPopup.style.top = `${top}px`;
                        numberPickerPopup.style.left = `${left}px`;
                    } else {
                        const rect = htmlBadge.getBoundingClientRect();
                        numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                        numberPickerPopup.style.left = `${rect.left}px`;
                    }

                    // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                    numberPickerPopup.style.display = 'block';
                    numberPickerPopup.style.opacity = '0';

                    requestAnimationFrame(() => {
                        numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                    });
                } else {
                    numberPickerPopup.style.opacity = '0';
                    setTimeout(() => {
                        numberPickerPopup.style.display = 'none';
                    }, 300);
                    // hide trash and fav popups when picker is programmatically hidden via toggle
                    try { const t = document.getElementById('trashPopup'); if (t) t.style.display = 'none'; } catch (e) { }
                    try { const f = document.getElementById('favPopup'); if (f) f.style.display = 'none'; } catch (e) { }
                }

                // Show/hide scale handle
                const handle = document.querySelector('.popup-scale-handle');
                if (handle) {
                    handle.classList.toggle('visible', isPopupVisible);
                }
            });

            // Toggle popup with Ctrl
            let ctrlPressed = false;
            let ctrlWithOtherKey = false;
            // New: detect mouse interaction (click/mousedown) while Ctrl is held so
            // Ctrl+mouse actions (e.g., Ctrl+click to select a row) don't also toggle popup
            let ctrlHadMouseInteraction = false;

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control' && !e.repeat) {
                    ctrlPressed = true;
                    ctrlWithOtherKey = false;
                    ctrlHadMouseInteraction = false;
                } else if (ctrlPressed && e.key !== 'Control') {
                    ctrlWithOtherKey = true;
                }
            });

            // mark any mouse interaction while ctrl is pressed
            document.addEventListener('mousedown', (e) => {
                try { if (ctrlPressed) ctrlHadMouseInteraction = true; } catch (err) { }
            }, true);
            document.addEventListener('touchstart', (e) => {
                try { if (ctrlPressed) ctrlHadMouseInteraction = true; } catch (err) { }
            }, true);

            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control' && ctrlPressed && !ctrlWithOtherKey && !ctrlHadMouseInteraction) {
                    isPopupVisible = !isPopupVisible;
                    if (isPopupVisible) {
                        // Apply scale BEFORE showing
                        applyPopupScaleInstant();

                        const savedPos = localStorage.getItem('popupPosition');
                        if (savedPos) {
                            const { top, left } = JSON.parse(savedPos);
                            numberPickerPopup.style.top = `${top}px`;
                            numberPickerPopup.style.left = `${left}px`;
                        } else {
                            const rect = htmlBadge.getBoundingClientRect();
                            numberPickerPopup.style.top = `${rect.bottom + 8}px`;
                            numberPickerPopup.style.left = `${rect.left}px`;
                        }

                        // Set display and opacity 0, then fade in to slider-target alpha after scale applied
                        numberPickerPopup.style.display = 'block';
                        numberPickerPopup.style.opacity = '0';

                        requestAnimationFrame(() => {
                            numberPickerPopup.style.opacity = String(__desiredPopupAlpha());
                        });
                        // restore trash popup to previous state if it was visible before the Ctrl-hide
                        try {
                            const t = document.getElementById('trashPopup');
                            if (t && window.__prevTrashVisible) {
                                t.style.display = 'block';
                                if (window.__adjustTrashPosition && typeof window.__adjustTrashPosition === 'function') {
                                    try { window.__adjustTrashPosition(); } catch (e) { }
                                }
                            }
                        } catch (e) { }
                        // restore fav popup to previous state if it was visible before the Ctrl-hide
                        try {
                            const f = document.getElementById('favPopup');
                            if (f && window.__prevFavVisible) {
                                f.style.display = 'block';
                                if (typeof adjustFavPosition === 'function') {
                                    try { adjustFavPosition(); } catch (e) { }
                                }
                            }
                        } catch (e) { }
                    } else {
                        numberPickerPopup.style.opacity = '0';
                        setTimeout(() => {
                            numberPickerPopup.style.display = 'none';
                        }, 300);
                        // hide trash and fav popups when picker is programmatically hidden via Ctrl toggle
                        try {
                            const t = document.getElementById('trashPopup');
                            // record previous visible state so we can restore when opening again
                            window.__prevTrashVisible = !!(t && (getComputedStyle(t).display !== 'none'));
                            if (t) t.style.display = 'none';
                        } catch (e) { }
                        try {
                            const f = document.getElementById('favPopup');
                            // record previous visible state so we can restore when opening again
                            window.__prevFavVisible = !!(f && (getComputedStyle(f).display !== 'none'));
                            if (f) f.style.display = 'none';
                        } catch (e) { }
                    }

                    // Show/hide scale handle
                    const handle = document.querySelector('.popup-scale-handle');
                    if (handle) {
                        handle.classList.toggle('visible', isPopupVisible);
                    }
                }
                if (e.key === 'Control') {
                    ctrlPressed = false;
                    ctrlWithOtherKey = false;
                    ctrlHadMouseInteraction = false;
                }
            });

            // Make popup draggable by background
            let popupOffsetX = 0, popupOffsetY = 0, isDraggingPopup = false;
            // track last mouse positions during popup drag so trash can follow the same movement
            let lastDragClientX = 0, lastDragClientY = 0;
            numberPickerPopup.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on close button
                if (e.target.closest('.number-picker-close-btn')) {
                    return;
                }
                if (e.target === numberPickerPopup) {
                    isDraggingPopup = true;
                    const rect = numberPickerPopup.getBoundingClientRect();
                    popupOffsetX = e.clientX - rect.left;
                    popupOffsetY = e.clientY - rect.top;
                    // initialize last drag mouse pos
                    lastDragClientX = e.clientX;
                    lastDragClientY = e.clientY;
                    e.preventDefault();
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (isDraggingPopup) {
                    const newLeft = e.clientX - popupOffsetX;
                    const newTop = e.clientY - popupOffsetY;
                    numberPickerPopup.style.left = newLeft + 'px';
                    numberPickerPopup.style.top = newTop + 'px';
                    localStorage.setItem('popupPosition', JSON.stringify({ top: newTop, left: newLeft }));
                    // Move trash popup by the same pointer delta when trash is attached to body
                    try {
                        const t = document.getElementById('trashPopup');
                        if (t && t.style.display === 'block' && t.parentElement === document.body) {
                            // compute pointer delta
                            const dx = e.clientX - lastDragClientX;
                            const dy = e.clientY - lastDragClientY;
                            // ensure numeric left/top values
                            let curLeft = parseFloat(t.style.left);
                            let curTop = parseFloat(t.style.top);
                            if (isNaN(curLeft) || isNaN(curTop)) {
                                // initialize via adjustTrashPosition then read values
                                if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                                curLeft = parseFloat(t.style.left) || 0;
                                curTop = parseFloat(t.style.top) || 0;
                            }
                            t.style.left = (curLeft + dx) + 'px';
                            t.style.top = (curTop + dy) + 'px';
                            // Also move fav popup by same delta if it's shown separately
                            try {
                                const f = document.getElementById('favPopup');
                                if (f && f.style.display === 'block' && f.parentElement === document.body) {
                                    let fLeft = parseFloat(f.style.left);
                                    let fTop = parseFloat(f.style.top);
                                    if (isNaN(fLeft) || isNaN(fTop)) {
                                        if (typeof adjustFavPosition === 'function') adjustFavPosition();
                                        fLeft = parseFloat(f.style.left) || 0;
                                        fTop = parseFloat(f.style.top) || 0;
                                    }
                                    f.style.left = (fLeft + dx) + 'px';
                                    f.style.top = (fTop + dy) + 'px';
                                }
                            } catch (e) { /* ignore fav move errors */ }
                            try {
                                const d = document.getElementById('draftPopup');
                                if (d && d.style.display === 'block' && d.parentElement === document.body) {
                                    let dLeft = parseFloat(d.style.left);
                                    let dTop = parseFloat(d.style.top);
                                    if (isNaN(dLeft) || isNaN(dTop)) {
                                        if (typeof adjustDraftPosition === 'function') adjustDraftPosition();
                                        dLeft = parseFloat(d.style.left) || 0;
                                        dTop = parseFloat(d.style.top) || 0;
                                    }
                                    d.style.left = (dLeft + dx) + 'px';
                                    d.style.top = (dTop + dy) + 'px';
                                }
                            } catch (e) { /* ignore draft move errors */ }
                        } else {
                            // fallback: if trash is child of popup or not visible, keep regular adjust behavior
                            if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                            try { if (typeof adjustFavPosition === 'function') adjustFavPosition(); } catch (e) { }
                        }
                    } catch (err) { /* ignore */ }
                    // update last drag mouse pos for next delta
                    lastDragClientX = e.clientX;
                    lastDragClientY = e.clientY;
                }
            });
            document.addEventListener('mouseup', () => { isDraggingPopup = false; });

            // Expose placeValues globally
            window.getPlaceValues = () => placeValues;
            window.markPlaceDropHandled = () => { lastDropInsidePlace = true; };
            window.setPlaceValues = (values) => {
                if (Array.isArray(values)) {
                    for (let i = 0; i < 6; i++) {
                        const v = values[i];
                        placeValues[i] = (v === undefined || v === null) ? '' : v;
                    }
                }
                generateNumberPickerTable();
                generatePlaceBoxes();
                setupNumberCellDragDrop();
                setupLabelCellDragDrop();
                // Reapply Cell6.5 highlights based on the new place values; run several times
                try { if (typeof applyCell6_5HighlightSet === 'function') applyCell6_5HighlightSet(placeValues); } catch (e) { }
                try { if (typeof updateCell6_5Highlights === 'function') updateCell6_5Highlights(); } catch (e) { }
                setTimeout(() => { try { if (typeof applyCell6_5HighlightSet === 'function') applyCell6_5HighlightSet(placeValues); } catch (e) { } }, 180);
                setTimeout(() => { try { if (typeof applyCell6_5HighlightSet === 'function') applyCell6_5HighlightSet(placeValues); } catch (e) { } }, 520);
            };
            window.applyPlaceValuesToInputs = (inputArray) => {
                if (inputArray && inputArray.length >= 6) {
                    for (let i = 0; i < 6; i++) {
                        const val = placeValues[i];
                        if (val && !isNaN(val)) {
                            inputArray[i].value = val;
                            inputArray[i].dispatchEvent(new Event('input'));
                        }
                    }
                }
            };

            // Scroll to top button
            const scrollBtn = document.getElementById('scrollToTop');
            scrollBtn.onclick = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'flex';
                    scrollBtn.style.alignItems = 'center';
                    scrollBtn.style.justifyContent = 'center';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });

            // Theme toggle
            const themeToggle = document.getElementById('themeToggle');
            const root = document.documentElement;
            const savedTheme = localStorage.getItem('theme') || 'light';
            root.setAttribute('data-theme', savedTheme);
            themeToggle.onclick = () => {
                const current = root.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                root.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                // Redraw connection lines to apply theme-specific colors
                try { drawConnections(); } catch { }
            };

            // Tải dữ liệu TRƯỚC khi render các cell
            await loadData();

            // Compute global rank (by total count) so popup can show ranks
            try {
                const totalCounts = Array(46).fill(0);
                rows.forEach(r => { if (r.nums && r.nums.length === 6) r.nums.forEach(v => { totalCounts[v] = (totalCounts[v] || 0) + 1; }); });
                const ranked = [];
                for (let v = 1; v <= 45; v++) ranked.push({ v, cnt: totalCounts[v] || 0 });
                ranked.sort((a, b) => b.cnt - a.cnt || a.v - b.v);
                const rankByTotal = {};
                ranked.forEach((r, idx) => { rankByTotal[r.v] = idx + 1; });
                window.rankByTotal = rankByTotal;
                // Regenerate the number picker table now that ranks are available
                try {
                    if (typeof generateNumberPickerTable === 'function') generateNumberPickerTable();
                    if (typeof updateRankSummary === 'function') updateRankSummary();
                } catch (e) { console.warn('regen number picker after rank compute', e); }
            } catch (e) { window.rankByTotal = {}; }

            const showSection = createSectionSwitcher();
            // Renderer map for lazy section mounting
            const renderers = {
                cell4: renderCell4,
                cell5: renderCell5,
                cell5_5: renderCell5_5,
                cell6_5: renderCell6_5, // Truy x (lọc theo số x)
                cell6_6: renderCell6_6, // Mổ pattern (6 số cố định)
                cell7: renderCell7, // Nhóm theo label
                cell8: renderCell8, // Tìm kiếm theo Label
                cell9: renderCell9,
                cell10: renderCell10,
                cell11: renderCell11,
            };

            // Expose ensureRendered globally for nav handlers
            window.ensureRendered = function ensureRendered(id) {
                if (!document.getElementById(id)) {
                    const fn = renderers[id];
                    if (typeof fn === 'function') fn();
                }
            };

            buildNav(showSection);
            // Hiển thị section theo hash (nếu hợp lệ), mặc định cell4
            const initial = (location.hash || "#cell4").replace("#", "");
            // Lazy mount only the initial section
            window.ensureRendered(initial || "cell4");
            showSection(initial || "cell4");
            window.addEventListener("hashchange", () => {
                const id = (location.hash || "#cell4").replace("#", "");
                window.ensureRendered(id || "cell4");
                showSection(id || "cell4");
            });
        }

        // Tag nested cards inside `.card.card-inner` with `card-inner-child`.
        (function markInnerChildCards() {
            function mark() {
                document.querySelectorAll('.card.card-inner').forEach(wrapper => {
                    wrapper.querySelectorAll('.card').forEach(child => {
                        if (!child.classList.contains('card-inner-child')) child.classList.add('card-inner-child');
                    });
                    // If the wrapper contains exactly one descendant marked as card-inner-child,
                    // mark the wrapper with `single-child` so CSS can target descendant-only cases.
                    try {
                        const innerChildren = wrapper.querySelectorAll('.card-inner-child');
                        if (innerChildren.length === 1) wrapper.classList.add('single-child');
                        else wrapper.classList.remove('single-child');
                    } catch (e) { /* ignore */ }
                });
            }
            // initial pass
            try { mark(); } catch (e) { }
            // watch for future additions
            try {
                const mo = new MutationObserver(mark);
                mo.observe(document.body, { childList: true, subtree: true });
                // expose for debugging if needed
                window.__markInnerChildObserver = mo;
            } catch (e) { }
        })();

        // Setup Rule toggle buttons: trash toggle ("normal"/"trash") and fav toggle ("normal"/"fav")
        (function setupRuleToggle() {
            const trashBtn = document.getElementById('trashToggle');
            const favBtn = document.getElementById('favToggle');
            // Expose getters so hover handlers can check each mode independently
            window.getTrashToggleMode = function () { return trashBtn ? trashBtn.textContent.trim().toLowerCase() : 'normal'; };
            window.getFavToggleMode = function () { return favBtn ? favBtn.textContent.trim().toLowerCase() : 'normal'; };
            // Legacy compatibility: getRuleToggleMode returns 'rule' when BOTH are active
            window.getRuleToggleMode = function () {
                const t = window.getTrashToggleMode();
                const f = window.getFavToggleMode();
                if (t === 'trash' && f === 'fav') return 'rule';
                return 'normal';
            };
            if (trashBtn) {
                trashBtn.addEventListener('click', () => {
                    const cur = trashBtn.textContent.trim().toLowerCase();
                    trashBtn.textContent = (cur === 'normal') ? 'trash' : 'normal';
                });
            }
            if (favBtn) {
                favBtn.addEventListener('click', () => {
                    const cur = favBtn.textContent.trim().toLowerCase();
                    favBtn.textContent = (cur === 'normal') ? 'fav' : 'normal';
                });
            }
        })();

        // Spacebar toggles trash toggle button instead of scrolling
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                // Don't intercept when typing in inputs/textareas/selects
                const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                if (tag === 'input' || tag === 'textarea' || tag === 'select' || (e.target && e.target.isContentEditable)) return;
                e.preventDefault();
                const btn = document.getElementById('trashToggle');
                if (btn) btn.click();
            }
        });

        // Run bootstrap then enable sticky fallback for multiple sections
        bootstrap().then(() => {
            (function enableStickyFallbackForSections() {
                const SECTIONS = ['cell6_5', 'cell6_6', 'cell7', 'cell8', 'cell9', 'cell10', 'cell11'];
                const HEADER_OFFSET = 64; // matches CSS top

                SECTIONS.forEach(sectionId => {
                    const sec = document.getElementById(sectionId);
                    if (!sec) return;
                    const controls = sec.querySelector('.controls');
                    if (!controls) return;

                    let placeholder = null;

                    function update() {
                        const secRect = sec.getBoundingClientRect();
                        const ctrlRect = controls.getBoundingClientRect();
                        const shouldPin = secRect.top < HEADER_OFFSET && (secRect.bottom > (HEADER_OFFSET + ctrlRect.height));

                        if (shouldPin && !controls.classList.contains('stuck')) {
                            // create placeholder to preserve layout
                            placeholder = document.createElement('div');
                            placeholder.style.height = ctrlRect.height + 'px';
                            controls.parentNode.insertBefore(placeholder, controls);

                            controls.classList.add('stuck');
                            controls.style.position = 'fixed';
                            controls.style.top = HEADER_OFFSET + 'px';
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                            controls.style.zIndex = 1100;
                        } else if (!shouldPin && controls.classList.contains('stuck')) {
                            controls.classList.remove('stuck');
                            controls.style.position = '';
                            controls.style.top = '';
                            controls.style.left = '';
                            controls.style.width = '';
                            controls.style.zIndex = '';
                            if (placeholder) { placeholder.remove(); placeholder = null; }
                        }
                    }

                    // listeners
                    window.addEventListener('scroll', update, { passive: true });
                    window.addEventListener('resize', () => {
                        if (controls.classList.contains('stuck')) {
                            const secRect = sec.getBoundingClientRect();
                            controls.style.left = Math.max(0, secRect.left) + 'px';
                            controls.style.width = secRect.width + 'px';
                        }
                    });

                    // mutation observer to handle dynamic content
                    const mo = new MutationObserver(() => setTimeout(update, 50));
                    mo.observe(sec, { childList: true, subtree: true });

                    // initial check
                    setTimeout(update, 120);
                });
            })();
        });
    </script>
    <!-- Floating Shift Navigation button: appears while Shift is held and avoids text selection -->
    <button id="shiftNavBtn" title="Shift navigation"
        style="display:none;position:fixed;z-index:99999;padding:6px 8px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;box-shadow:0 4px 10px rgba(0,0,0,0.2);">⇧
        <!-- Draft pills: click-to-edit and drag-to-swap implementation -->
        <script>
            (function enableDraftPillInteractions() {
                const draft = document.getElementById('draftPopup');
                if (!draft) return;
                const selector = '#draftPopup .draft-body table span.pill';

                function initPill(span) {
                    if (!span || span._pillInit) return;
                    span.style.touchAction = 'none';
                    span.addEventListener('click', onPillClick);
                    span.addEventListener('mousedown', onPillMouseDown);
                    span._pillInit = true;
                }

                function flashRed(el, duration = 900) {
                    try {
                        const prev = el.style.background;
                        el.style.transition = 'background 160ms ease';
                        el.style.background = '#ffd6d6';
                        setTimeout(() => { el.style.background = prev || ''; }, duration);
                    } catch (e) { }
                }

                function rowHasValue(row, val, ignoreEl) {
                    if (!row) return false;
                    const vNum = parseInt(String(val).trim(), 10);
                    if (isNaN(vNum)) return false;
                    return Array.from(row.querySelectorAll('span.pill')).some(p => {
                        if (p === ignoreEl) return false;
                        const pnum = parseInt((p.textContent || '').trim(), 10);
                        return !isNaN(pnum) && pnum === vNum;
                    });
                }

                function rowFindPillsWithValue(row, val, ignoreEl) {
                    if (!row) return [];
                    const vNum = parseInt(String(val).trim(), 10);
                    if (isNaN(vNum)) return [];
                    return Array.from(row.querySelectorAll('span.pill')).filter(p => {
                        if (p === ignoreEl) return false;
                        const pnum = parseInt((p.textContent || '').trim(), 10);
                        return !isNaN(pnum) && pnum === vNum;
                    });
                }

                function scan() { document.querySelectorAll(selector).forEach(initPill); }
                if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', scan); else scan();
                const bodyEl = draft.querySelector('.draft-body');
                if (bodyEl) new MutationObserver(scan).observe(bodyEl, { childList: true, subtree: true });

                function isEmptyVal(v) { return v === '' || v === null || v === undefined || String(v).trim() === '' || String(v).trim() === '__'; }
                function pillText(n) {
                    if (isEmptyVal(n)) return '__';
                    const num = parseInt(String(n).trim(), 10);
                    if (isNaN(num)) return '__';
                    return String(num);
                }
                function updatePillClass(span) {
                    const txt = (span.textContent || '').trim();
                    if (txt === '__' || txt === '') span.classList.add('pill-empty');
                    else span.classList.remove('pill-empty');
                }

                // ── Editing ──
                let editing = null;
                let navigating = false; // flag to suppress blur during arrow navigation

                function onPillClick(e) {
                    if (dragging) return;
                    const span = e.currentTarget;
                    if (editing) return;
                    e.stopPropagation();
                    const oldText = span.textContent.trim();
                    const old = (oldText === '__') ? '' : oldText;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'pill-editor';
                    input.value = old;
                    const rowEl = span.closest ? span.closest('tr') : null;
                    span.replaceWith(input);
                    input.focus();
                    input.select();
                    editing = { input, span, old, row: rowEl };

                    function commit(save) {
                        if (!editing) return;
                        const valRaw = save ? input.value.trim() : old;
                        if (save) {
                            if (valRaw === '' || valRaw === '__') {
                                const newSpan = document.createElement('span');
                                newSpan.className = 'pill pill-empty';
                                newSpan.textContent = '__';
                                input.replaceWith(newSpan);
                                initPill(newSpan);
                                editing = null;
                                return;
                            }
                            const num = parseInt(valRaw, 10);
                            const row = editing.row || (editing.span && editing.span.closest ? editing.span.closest('tr') : null);
                            if (!/^[0-9]+$/.test(valRaw) || isNaN(num) || num < 1 || num > 45) {
                                flashRed(input, 900);
                                input.focus(); input.select();
                                return;
                            }
                            if (rowHasValue(row, valRaw, editing.span)) {
                                flashRed(input);
                                rowFindPillsWithValue(row, valRaw, editing.span).forEach(p => { try { flashRed(p); } catch (e) { } });
                                const reverted = document.createElement('span');
                                reverted.className = 'pill';
                                reverted.textContent = old || '__';
                                updatePillClass(reverted);
                                setTimeout(() => { try { input.replaceWith(reverted); } catch (e) { } initPill(reverted); }, 220);
                                editing = null;
                                return;
                            }
                        }
                        const val = save ? valRaw : old;
                        const newSpan = document.createElement('span');
                        newSpan.className = 'pill';
                        newSpan.textContent = pillText(val);
                        updatePillClass(newSpan);
                        input.replaceWith(newSpan);
                        initPill(newSpan);
                        editing = null;
                    }

                    // Navigate to adjacent pill with ArrowLeft / ArrowRight (wraps around)
                    function navigatePill(direction) {
                        const row = editing ? (editing.row || (editing.input && editing.input.closest ? editing.input.closest('tr') : null)) : null;
                        if (!row) return;
                        const pillsContainer = row.querySelector('.pills');
                        if (!pillsContainer) return;
                        const children = Array.from(pillsContainer.children).filter(c => c.classList.contains('pill') || c.classList.contains('pill-editor'));
                        const idx = children.indexOf(input);
                        if (idx < 0) return;
                        navigating = true; // suppress blur handler during navigation
                        commit(true);
                        navigating = false;
                        const refreshed = Array.from(pillsContainer.children).filter(c => c.classList.contains('pill') || c.classList.contains('pill-editor'));
                        let nextIdx = idx + direction;
                        if (nextIdx < 0) nextIdx = refreshed.length - 1;
                        if (nextIdx >= refreshed.length) nextIdx = 0;
                        const targetPill = refreshed[nextIdx];
                        if (targetPill && targetPill.classList.contains('pill')) {
                            setTimeout(() => targetPill.click(), 30);
                        }
                    }

                    input.addEventListener('blur', () => { if (editing && !navigating) commit(true); });
                    input.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') { ev.preventDefault(); commit(true); }
                        else if (ev.key === 'Escape') { commit(false); }
                        else if (ev.key === 'ArrowLeft') { ev.preventDefault(); navigatePill(-1); }
                        else if (ev.key === 'ArrowRight') { ev.preventDefault(); navigatePill(1); }
                        else if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
                            ev.preventDefault();
                            const cur = parseInt(input.value.trim(), 10);
                            const delta = ev.key === 'ArrowUp' ? 1 : -1;
                            let next = (isNaN(cur) ? 0 : cur) + delta;
                            if (next < 1) next = 1;
                            if (next > 45) next = 45;
                            const row = editing.row || (editing.span && editing.span.closest ? editing.span.closest('tr') : null);
                            if (rowHasValue(row, next, editing.span)) {
                                let attempts = 0;
                                while (rowHasValue(row, next, editing.span) && attempts < 45) {
                                    next += delta;
                                    if (next < 1) next = 1;
                                    if (next > 45) next = 45;
                                    attempts++;
                                }
                                if (rowHasValue(row, next, editing.span)) return;
                            }
                            input.value = String(next);
                            input.select();
                        }
                    });
                }

                // ── Drag-to-swap ──
                let dragging = false, dragSrc = null, clone = null, target = null;
                let dragStartX = 0, dragStartY = 0, dragMoved = false;
                let dragSrcOldText = '';

                function onPillMouseDown(e) {
                    if (e.button !== 0) return;
                    if (editing) return;
                    e.preventDefault(); e.stopPropagation();
                    dragSrc = e.currentTarget;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragMoved = false;
                    dragSrcOldText = '';
                    document.addEventListener('mousemove', onPillMouseMove);
                    document.addEventListener('mouseup', onPillMouseUp);
                }

                function onPillMouseMove(e) {
                    if (!dragSrc) return;
                    if (!dragMoved) {
                        const dx = e.clientX - dragStartX;
                        const dy = e.clientY - dragStartY;
                        if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return;
                        dragMoved = true;
                        dragging = true;
                        dragSrcOldText = dragSrc.textContent.trim();
                        // Create clone copying computed styles so it looks identical
                        const r = dragSrc.getBoundingClientRect();
                        clone = dragSrc.cloneNode(true);
                        const cs = getComputedStyle(dragSrc);
                        clone.style.cssText = 'position:fixed;z-index:100002;pointer-events:none;'
                            + 'left:' + r.left + 'px;top:' + r.top + 'px;'
                            + 'width:' + r.width + 'px;height:' + r.height + 'px;'
                            + 'box-shadow:0 8px 24px rgba(0,0,0,0.35);transform:scale(1.15);'
                            + 'display:inline-flex;align-items:center;justify-content:center;'
                            + 'background:' + cs.background + ';color:' + cs.color + ';'
                            + 'font:' + cs.font + ';border-radius:' + cs.borderRadius + ';';
                        document.body.appendChild(clone);
                        // Source becomes empty immediately (pill visually leaves its position)
                        dragSrc.textContent = '__';
                        dragSrc.classList.add('pill-empty');
                    }
                    if (!dragging) return;
                    clone.style.left = (e.clientX - 12) + 'px';
                    clone.style.top = (e.clientY - 12) + 'px';
                    // Only target pills inside draftPopup
                    const el = document.elementFromPoint(e.clientX, e.clientY);
                    const pill = el && el.closest ? el.closest('#draftPopup span.pill') : null;
                    if (pill && pill !== dragSrc) {
                        if (target && target !== pill) target.classList.remove('pill-target');
                        target = pill; target.classList.add('pill-target');
                    } else {
                        if (target) { target.classList.remove('pill-target'); target = null; }
                    }
                }

                function onPillMouseUp(e) {
                    document.removeEventListener('mousemove', onPillMouseMove);
                    document.removeEventListener('mouseup', onPillMouseUp);
                    if (clone && clone.parentNode) clone.parentNode.removeChild(clone);

                    if (dragging && dragSrc) {
                        const a = dragSrcOldText; // original value of source before drag
                        const aIsEmpty = isEmptyVal(a);

                        // Check if dropped outside draftPopup → delete value
                        const draftRect = draft.getBoundingClientRect();
                        const outside = e.clientX < draftRect.left || e.clientX > draftRect.right
                            || e.clientY < draftRect.top || e.clientY > draftRect.bottom;

                        if (outside) {
                            // Dropped outside: value is deleted (source already shows __)
                            updatePillClass(dragSrc);
                            if (target) target.classList.remove('pill-target');
                        } else if (target && dragSrc !== target) {
                            const b = target.textContent.trim();
                            const bIsEmpty = isEmptyVal(b);
                            const rowA = dragSrc.closest('tr');
                            const rowB = target.closest('tr');
                            let blocked = false;

                            if (rowA !== rowB) {
                                // Cross-record swap: check uniqueness both ways
                                if (!aIsEmpty && rowHasValue(rowB, a, target)) {
                                    blocked = true;
                                    // Flash 3: source, target, and the conflict pill in target row
                                    flashRed(dragSrc); flashRed(target);
                                    rowFindPillsWithValue(rowB, a, target).forEach(p => flashRed(p));
                                    // Revert source
                                    dragSrc.textContent = a;
                                    updatePillClass(dragSrc);
                                } else if (!bIsEmpty && rowHasValue(rowA, b, dragSrc)) {
                                    blocked = true;
                                    flashRed(dragSrc); flashRed(target);
                                    rowFindPillsWithValue(rowA, b, dragSrc).forEach(p => flashRed(p));
                                    dragSrc.textContent = a;
                                    updatePillClass(dragSrc);
                                }
                            }

                            if (!blocked) {
                                // Swap: source gets target's value, target gets source's original
                                dragSrc.textContent = pillText(b);
                                updatePillClass(dragSrc);
                                target.textContent = pillText(a);
                                updatePillClass(target);
                                initPill(dragSrc); initPill(target);
                            }
                            if (target) target.classList.remove('pill-target');
                        } else {
                            // Dropped on no valid target or itself: revert source
                            dragSrc.textContent = a;
                            updatePillClass(dragSrc);
                        }
                    }

                    dragging = false; dragSrc = null; clone = null; target = null;
                    dragMoved = false; dragSrcOldText = '';
                }

                window.__scanDraftPills = scan;
            })();
        </script>
        Nav
    </button>
    <script>
        // Flag Shift+click globally so the Shift-only trash toggle doesn't fire after a Shift+click action
        document.addEventListener('click', function (ev) {
            try { if (ev.shiftKey) window.__shiftClickJustUsed = true; } catch (e) { }
        }, true);
    </script>
    <script>
        (function () {
            let lastX = 0, lastY = 0;
            const btn = document.getElementById('shiftNavBtn');

            // Track cursor so the floating button can appear near it
            document.addEventListener('mousemove', (e) => {
                lastX = e.clientX;
                lastY = e.clientY;
                if (btn.style.display !== 'none') {
                    btn.style.left = (lastX + 12) + 'px';
                    btn.style.top = (lastY + 12) + 'px';
                }
            }, true);

            // Show the button while Shift is held; hide when released
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Shift') {
                    btn.style.display = 'block';
                    btn.style.left = (lastX + 12) + 'px';
                    btn.style.top = (lastY + 12) + 'px';
                }
            }, true);
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Shift') {
                    btn.style.display = 'none';
                }
            }, true);

            // Prevent native text-selection when user Shift+clicks (mousedown)
            document.addEventListener('mousedown', (e) => {
                try {
                    if (e.shiftKey && e.button === 0) {
                        e.preventDefault();
                    }
                } catch (err) { }
            }, true);

            // When the floating button is clicked, dispatch a synthetic click with shiftKey
            // at the last cursor position so existing Shift+Click handlers run.
            btn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                ev.preventDefault();
                const el = document.elementFromPoint(lastX, lastY);
                if (!el) return;
                const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    shiftKey: true,
                    clientX: lastX,
                    clientY: lastY
                });
                el.dispatchEvent(clickEvent);
                // hide after use to avoid accidental repeats
                btn.style.display = 'none';
            }, true);
        })();
    </script>
    <script>
        // Enable drag-and-drop from number picker into fav slots.
        (function enableFavDragDrop() {
            const numberTableSelector = '#numberPickerTable';
            // make number cells draggable and attach dragstart events
            function setDraggableOnNumbers(root = document) {
                const table = root.querySelector(numberTableSelector);
                if (!table) return;
                table.querySelectorAll('td').forEach(td => {
                    if (td.dataset.dragInit) return;
                    // prefer a numeric data-number attribute when present
                    const dsNum = td.dataset && td.dataset.number ? td.dataset.number : (td.getAttribute && td.getAttribute('data-number'));
                    const textFallback = td.textContent ? td.textContent.trim() : '';
                    const numeric = dsNum || (textFallback.match && (textFallback.match(/\d+/) || [])[0]) || textFallback;
                    if (!numeric) return;
                    td.setAttribute('draggable', 'true');
                    td.addEventListener('dragstart', (ev) => {
                        try {
                            // ensure favPopup receives a plain numeric string so Number(...) works
                            ev.dataTransfer.setData('text/plain', String(numeric));
                            ev.dataTransfer.setData('application/x-number-src', String(numeric));
                            ev.dataTransfer.setData('source', 'popup');
                            ev.dataTransfer.effectAllowed = 'all';
                        } catch (e) { }
                        td.classList.add('dragging-number');
                    });
                    td.addEventListener('dragend', () => td.classList.remove('dragging-number'));
                    td.dataset.dragInit = '1';
                });
            }

            // Initial attempt to enable draggables and observe future changes
            setDraggableOnNumbers();
            const table = document.querySelector(numberTableSelector);
            if (table) {
                const mo = new MutationObserver(() => setDraggableOnNumbers());
                mo.observe(table, { childList: true, subtree: true });
            } else {
                const mo2 = new MutationObserver(() => {
                    if (document.querySelector(numberTableSelector)) {
                        setDraggableOnNumbers();
                        mo2.disconnect();
                    }
                });
                mo2.observe(document.body, { childList: true, subtree: true });
            }

            // Helper to find fav slot cell (td.fav-number) from event target
            function findFavSlot(el) {
                return el && el.closest && el.closest('#favPopup td.fav-number');
            }

            document.addEventListener('dragover', (ev) => {
                const slot = findFavSlot(ev.target);
                if (slot) { ev.preventDefault(); ev.dataTransfer.dropEffect = 'copy'; slot.classList.add('fav-drop-target'); }
            }, true);

            document.addEventListener('dragleave', (ev) => {
                const slot = findFavSlot(ev.target);
                if (slot) slot.classList.remove('fav-drop-target');
            }, true);

            document.addEventListener('drop', (ev) => {
                const slot = findFavSlot(ev.target);
                if (!slot) return;
                ev.preventDefault();
                slot.classList.remove('fav-drop-target');
                const numberText = ev.dataTransfer.getData('text/plain') || ev.dataTransfer.getData('application/x-number-src');
                if (!numberText) return;
                // Try to reuse existing dblclick -> fav logic by finding the source cell and dispatching dblclick
                const table = document.querySelector(numberTableSelector);
                let srcCell = null;
                if (table) {
                    const t = numberText.trim();
                    srcCell = Array.from(table.querySelectorAll('td')).find(td => {
                        const txt = td.textContent.trim();
                        return txt === t || new RegExp('\\b' + t + '\\b').test(txt);
                    });
                }
                if (srcCell) {
                    const ev2 = new MouseEvent('dblclick', { bubbles: true, cancelable: true, view: window });
                    srcCell.dispatchEvent(ev2);
                    // After existing handler runs, attempt to move created fav into the specific drop slot
                    setTimeout(() => {
                        const favPopup = document.querySelector('#favPopup');
                        if (!favPopup) return;
                        const favCell = Array.from(favPopup.querySelectorAll('td.fav-number')).find(td => td.textContent.includes(numberText));
                        if (favCell && favCell !== slot) { slot.innerHTML = favCell.innerHTML; favCell.innerHTML = ''; }
                        else if (!favCell) { slot.textContent = numberText; }
                    }, 150);
                } else {
                    // fallback: directly insert number text into drop slot
                    slot.textContent = numberText;
                }
            }, true);
        })();
    </script>
    <script>
        // Observe changes inside favPopup and notify listeners (favchange)
        (function observeFavPopupChanges() {
            try {
                const fav = function () { return document.getElementById('favPopup'); };
                const mo = new MutationObserver((records) => {
                    try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                });
                // attempt to attach when favPopup appears
                const attach = () => {
                    const f = fav();
                    if (f) mo.observe(f, { childList: true, subtree: true, characterData: true });
                };
                // try now and also watch for future additions
                attach();
                const mo2 = new MutationObserver(() => { try { attach(); } catch (e) { } });
                mo2.observe(document.body, { childList: true, subtree: true });
            } catch (e) { /* ignore */ }
        })();
    </script>
    <script>
        // JS shim: add a compatibility class for `td:has(.pill)` so older editors/linters
        // won't complain and dynamic tables get the same behavior.
        (function markTdHasPill() {
            function markAll() {
                document.querySelectorAll('td').forEach(td => {
                    try {
                        if (td.querySelector && td.querySelector('.pill')) td.classList.add('td-has-pill');
                        else td.classList.remove('td-has-pill');
                    } catch (e) { /* ignore */ }
                });
            }
            // Initial pass
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', markAll);
            else markAll();
            // Watch for DOM changes (tables regenerated dynamically)
            const mo = new MutationObserver(() => { markAll(); });
            mo.observe(document.body, { childList: true, subtree: true });
        })();
    </script>
    <script>
        // Ctrl+Shift toggle between two most-recently-clicked sections (cells)
        (function () {
            const lastTwo = []; // keep up to 2 most recent section ids
            let lastClicked = null; // the most recently clicked section id
            let toggleLocked = false; // avoid repeat triggers while keys held

            function recordSectionClick(secId) {
                if (!secId) return;
                const idx = lastTwo.indexOf(secId);
                if (idx !== -1) lastTwo.splice(idx, 1);
                lastTwo.push(secId);
                if (lastTwo.length > 2) lastTwo.shift();
                lastClicked = secId;
            }

            // Delegate clicks: any click inside a section with an id counts
            document.addEventListener('click', function (ev) {
                try {
                    const sec = ev.target.closest('section[id]');
                    if (sec && sec.id) recordSectionClick(sec.id);
                    // Also treat clicks on nav buttons as selecting their target section
                    const navBtn = ev.target.closest('.nav-btn');
                    if (navBtn && navBtn.dataset && navBtn.dataset.target) recordSectionClick(navBtn.dataset.target);
                } catch (e) { /* ignore */ }
            }, true);

            function gotoSection(secId) {
                if (!secId) return;
                const sec = document.getElementById(secId);
                if (!sec) return;
                // Try to activate nav button if present (non-invasive)
                const selectors = [
                    '.nav-btn[data-target="' + secId + '"]',
                    '.nav-btn[data-section="' + secId + '"]',
                    '.nav-btn[href="#' + secId + '"]'
                ];
                let clicked = false;
                for (const s of selectors) {
                    const btn = document.querySelector(s);
                    if (btn) { btn.click(); clicked = true; break; }
                }
                // Fallback: scroll into view and focus safely
                if (!clicked) {
                    sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    try { if (typeof safeFocus === 'function') safeFocus(sec); else sec.focus(); } catch (e) { }
                }
                lastClicked = secId;
            }

            function toggleLastTwo() {
                if (lastTwo.length < 2) return;
                const older = lastTwo[0], newer = lastTwo[1];
                const target = (lastClicked === newer) ? older : newer;
                gotoSection(target);
            }

            // Trigger when Ctrl is held and Shift is tapped (allow repeated taps while Ctrl held)
            document.addEventListener('keydown', function (e) {
                try {
                    // only respond to physical Shift key down to avoid repeats from holding
                    if (e.key === 'Shift' && e.ctrlKey && !toggleLocked) {
                        toggleLocked = true; // lock until Shift is released
                        window.__ctrlShiftJustUsed = true; // prevent Shift-only handlers from firing
                        toggleLastTwo();
                        e.preventDefault();
                    }
                } catch (err) { }
                try { draggingNumber = null; } catch (e) { }
            }, true);
            document.addEventListener('keyup', function (e) {
                try {
                    // release the lock when Shift is released so another tap can trigger
                    if (e.key === 'Shift') toggleLocked = false;
                } catch (err) { }
            }, true);

            // Initialize by recording the first section in document (if any)
            (function init() {
                const first = document.querySelector('main section[id]');
                if (first && first.id) recordSectionClick(first.id);
            })();
        })();
    </script>
    <script>
        // More robust auto-scroll: MutationObserver + polling to handle slow loads.
        (function () {
            try {
                const toTop = document.getElementById('scrollToTop');
                const toBottom = document.getElementById('scrollToBottom');
                if (!toTop || !toBottom) return;

                let autoScrollActive = false;
                let mo = null;
                let pollIntervalId = null;
                let lastDocumentHeight = document.documentElement.scrollHeight;
                let lastScrollY = window.scrollY || window.pageYOffset || 0;

                function showHideButtons() {
                    const sc = window.scrollY || window.pageYOffset || 0;
                    const max = document.documentElement.scrollHeight - window.innerHeight;
                    toTop.style.display = (sc > 200) ? 'block' : 'none';
                    toBottom.style.display = (sc < max - 200) ? 'block' : 'none';
                }

                function scrollToBottomImmediate() {
                    const top = document.documentElement.scrollHeight - window.innerHeight;
                    window.scrollTo({ top: top, behavior: 'auto' });
                }

                function startPolling() {
                    if (pollIntervalId) return;
                    pollIntervalId = setInterval(() => {
                        const h = document.documentElement.scrollHeight;
                        if (h !== lastDocumentHeight) {
                            lastDocumentHeight = h;
                            // keep the viewport at the bottom when content grows
                            scrollToBottomImmediate();
                            // refresh button visibility after layout change
                            setTimeout(showHideButtons, 40);
                        }
                    }, 400); // check ~2.5 times/sec
                }

                function stopPolling() {
                    if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }
                }

                function startAutoScroll() {
                    if (autoScrollActive) return;
                    autoScrollActive = true;
                    // initial jump to bottom
                    scrollToBottomImmediate();
                    lastDocumentHeight = document.documentElement.scrollHeight;

                    // MutationObserver for immediate updates
                    const targetNode = document.querySelector('main') || document.documentElement;
                    mo = new MutationObserver((mutations) => {
                        if (!autoScrollActive) return;
                        const h = document.documentElement.scrollHeight;
                        if (h !== lastDocumentHeight) {
                            lastDocumentHeight = h;
                            scrollToBottomImmediate();
                            setTimeout(showHideButtons, 40);
                        }
                    });
                    try {
                        mo.observe(targetNode, { childList: true, subtree: true, attributes: true, characterData: false });
                    } catch (e) {
                        try { mo.observe(document.documentElement, { childList: true, subtree: true, attributes: true }); } catch (e) { }
                    }

                    // polling fallback to handle slow layout/async image loads
                    startPolling();
                    setTimeout(showHideButtons, 40);
                }

                function stopAutoScroll(reason) {
                    autoScrollActive = false;
                    if (mo) { try { mo.disconnect(); } catch (e) { } mo = null; }
                    stopPolling();
                    setTimeout(showHideButtons, 40);
                }

                // stop on user upward scroll or explicit interactions
                window.addEventListener('scroll', function () {
                    const sc = window.scrollY || window.pageYOffset || 0;
                    const delta = sc - lastScrollY;
                    if (autoScrollActive && delta < -2) stopAutoScroll('user-scrolled-up');
                    lastScrollY = sc;
                    showHideButtons();
                }, { passive: true });

                // wheel/touch/keyboard interruptions
                window.addEventListener('wheel', (e) => { if (autoScrollActive && e.deltaY < 0) stopAutoScroll('user-wheel-up'); }, { passive: true });
                window.addEventListener('touchstart', () => { if (autoScrollActive) stopAutoScroll('user-touch'); }, { passive: true });
                window.addEventListener('keydown', (e) => { if (!autoScrollActive) return; const upKeys = ['ArrowUp', 'PageUp', 'Home']; if (upKeys.includes(e.key)) stopAutoScroll('user-key-up'); }, true);

                window.addEventListener('resize', showHideButtons);
                setTimeout(showHideButtons, 120);

                toTop.addEventListener('click', function () { stopAutoScroll('user-request-top'); window.scrollTo({ top: 0, behavior: 'smooth' }); });

                toBottom.addEventListener('click', function () {
                    if (autoScrollActive) { stopAutoScroll('toggled-off'); return; }
                    startAutoScroll();
                });
            } catch (e) { /* ignore */ }
        })();
    </script>
    <script>
        // Trash / drag-drop helper for the number-picker popup
        (function () {
            const trashBtn = document.getElementById('trashBtn');
            const numberPickerPopup = document.getElementById('numberPickerPopup');
            const numberPickerTable = document.getElementById('numberPickerTable');

            // Require the popup/table and trash button. The manual toggle element has been removed;
            // trash is always enabled by design (see `trashEnabled` below).
            if (!numberPickerPopup || !numberPickerTable || !trashBtn) return;

            // create trash popup element and attach to document.body so it's not clipped
            const trashPopup = document.createElement('div');
            trashPopup.id = 'trashPopup';
            trashPopup.style.position = 'fixed';
            trashPopup.style.zIndex = '10001';
            // minimal UI: single numeric input for k (1..45). on submit it will compute and move numbers to trash.
            trashPopup.innerHTML = `
                <div style="padding:8px;display:flex;gap:8px;align-items:center;">
                    <label id="trashKLabel" style="font-weight:700;color:var(--text);display:inline-flex;align-items:center;height:32px;padding:0 4px 0 0;">ktrash:</label>
                    <div style="position:relative;display:inline-block;vertical-align:middle;">
                        <input id="trashKInput" type="number" min="1" max="39" step="1" value="5" style="width:56px;padding:6px 18px 6px 8px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);box-sizing:border-box;" />
                        <div style="position:absolute;right:4px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:2px;z-index:3;pointer-events:auto;width:18px;align-items:center;">
                            <button type="button" class="trash-k-up" title="Tăng 1" style="width:16px;height:10px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:9px;line-height:10px;text-align:center;font-weight:700;">▲</button>
                            <button type="button" class="trash-k-down" title="Giảm 1" style="width:16px;height:10px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:9px;line-height:10px;text-align:center;font-weight:700;">▼</button>
                        </div>
                    </div>
                    <button id="trashClearBtn" class="clear-btn" title="Xóa" style="height:32px;padding:6px 10px;">Xóa</button>
                </div>
                <div style="padding:6px 8px;max-height:calc(var(--trash-row-height,36px) * 15);overflow:visible;">
                    <table><tbody></tbody></table>
                </div>`;
            document.body.appendChild(trashPopup);
            // start hidden by default
            try { trashPopup.style.display = 'none'; } catch (e) { }
            // create favorite popup element (favpopup) and attach
            const favPopup = document.createElement('div');
            favPopup.id = 'favPopup';
            favPopup.style.position = 'fixed';
            favPopup.style.zIndex = '10001';
            favPopup.innerHTML = `
                <div style="padding:6px;display:flex;gap:6px;align-items:center;">
                    <!-- fneed: compute N numbers to add to fav so 'include' filter matches maximum distinct periods -->
                    <div style="display:inline-flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;color:var(--muted);">fneed</label>
                        <div style="position:relative;display:inline-block;vertical-align:middle;">
                            <input id="favFneedInput" type="number" min="1" max="39" value="3" style="width:48px;padding:4px 18px 4px 8px;height:28px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);box-sizing:border-box;text-align:center;" title="Số lượng số cần thêm tự động (1-39)">
                            <div style="position:absolute;right:4px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:2px;z-index:3;pointer-events:auto;width:18px;align-items:center;">
                                <button type="button" class="fav-k-up" title="Tăng 1" style="width:16px;height:10px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:9px;line-height:10px;text-align:center;font-weight:700;">▲</button>
                                <button type="button" class="fav-k-down" title="Giảm 1" style="width:16px;height:10px;border-radius:3px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;padding:0;font-size:9px;line-height:10px;text-align:center;font-weight:700;">▼</button>
                            </div>
                        </div>
                    </div>
                    <button id="favClearBtn" class="clear-btn" title="Xóa yêu thích" style="height:26px;padding:4px 8px;font-size:13px;line-height:1;">Xóa</button>
                    <div style="display:inline-flex;align-items:center;gap:4px;margin-left:4px;">
                        <label style="font-size:12px;color:var(--muted);">f</label>
                        <select id="favFilterOp" style="height:28px;padding:4px;">
                            <option value=">=">&gt;=</option>
                            <option value="=">=</option>
                            <option value="<=">&lt;=</option>
                        </select>
                        <input id="favFilterCount" type="number" min="0" max="6" value="2" style="width:36px;height:28px;padding:4px;text-align:center;" title="Số lượng khớp với fav (0-6)">
                    </div>
                </div>
                <div style="padding:6px 8px;max-height:calc(var(--trash-row-height,36px) * 15);overflow:visible;">
                    <table><tbody></tbody></table>
                </div>
                <div class="trash-scale-handle" aria-hidden="true" style="position:absolute;left:0;bottom:0;width:18px;height:18px;pointer-events:auto;"></div>`;
            document.body.appendChild(favPopup);
            try { favPopup.style.display = 'none'; } catch (e) { }
            // wire fav filter controls to notify listeners
            try {
                const op = favPopup.querySelector('#favFilterOp');
                const cnt = favPopup.querySelector('#favFilterCount');
                const fneedInput = favPopup.querySelector('#favFneedInput');
                const notify = () => { try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { } };
                if (op) op.addEventListener('change', notify);
                if (cnt) cnt.addEventListener('change', notify);
                if (fneedInput) {
                    const computeAndAdd = createDebounce(async () => {
                        try {
                            let v = Number(fneedInput.value) || 0;
                            if (!Number.isInteger(v) || v < 1) { v = 1; fneedInput.value = '1'; }
                            if (v > 39) { v = 39; fneedInput.value = '39'; }
                            const res = (typeof computeBestFav === 'function') ? computeBestFav(v) : null;
                            if (res && Array.isArray(res.chosen)) {
                                try {
                                    // replace entire fav list with computed numbers
                                    favItems = [];
                                    try { renderFav(); } catch (e) { }
                                    try { const ins = numberPickerTable.querySelectorAll('td.in-fav'); ins.forEach(i => i.classList.remove('in-fav')); } catch (e) { }
                                } catch (e) { }
                                if (res.chosen.length) {
                                    for (const num of res.chosen) {
                                        try { addToFav(num); } catch (e) { }
                                    }
                                }
                                try { document.dispatchEvent(new CustomEvent('favchange', { bubbles: true, composed: true })); } catch (e) { }
                                try { renderFav(); } catch (e) { }
                                try { updateFavBadge(); } catch (e) { }
                            }
                        } catch (e) { }
                    }, 300);
                    fneedInput.addEventListener('input', computeAndAdd);
                    // wire spinner buttons for fav fneed (wrap between 1 and 39)
                    try {
                        const up = favPopup.querySelector('.fav-k-up');
                        const down = favPopup.querySelector('.fav-k-down');
                        const MIN_K = 1, MAX_K = 39;
                        if (up) up.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(fneedInput.value, 10);
                            if (!Number.isInteger(v)) v = 0;
                            v = v + 1;
                            if (v > MAX_K) v = MIN_K;
                            fneedInput.value = String(v);
                            try { computeAndAdd(); } catch (e) { fneedInput.dispatchEvent(new Event('input', { bubbles: true })); }
                        });
                        if (down) down.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(fneedInput.value, 10);
                            if (!Number.isInteger(v)) v = 0;
                            v = v - 1;
                            if (v < MIN_K) v = MAX_K;
                            fneedInput.value = String(v);
                            try { computeAndAdd(); } catch (e) { fneedInput.dispatchEvent(new Event('input', { bubbles: true })); }
                        });
                    } catch (err) { /* ignore spinner wiring errors */ }
                }
            } catch (e) { }
            // expose helper for restoring position from other scopes
            try { window.__adjustTrashPosition = adjustTrashPosition; } catch (e) { }

            // Observe popup position/style changes and keep trash (fav) and draft aligned.
            try {
                const popupPosObserver = new MutationObserver((mutations) => {
                    // while user is actively dragging the popup, avoid calling adjust
                    // handlers because we move trash/fav manually during drag.
                    try { if (typeof isDraggingPopup !== 'undefined' && isDraggingPopup) return; } catch (e) { }
                    for (const m of mutations) {
                        if (m.type === 'attributes' && m.attributeName === 'style') {
                            try {
                                if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                            } catch (e) { }
                            try {
                                if (typeof adjustDraftPosition === 'function') adjustDraftPosition();
                            } catch (e) { }
                            // Sync draft visibility with number-picker visibility:
                            try {
                                const dp = document.getElementById('draftPopup');
                                const npStyle = window.getComputedStyle(numberPickerPopup);
                                const npVisible = npStyle.display !== 'none' && numberPickerPopup.offsetWidth > 0 && numberPickerPopup.getBoundingClientRect().width > 0;
                                if (!npVisible) {
                                    // picker hidden -> remember current draft visibility then hide draft
                                    try { window.__prevDraftVisible = !!(dp && dp.style.display === 'block'); } catch (e) { }
                                    try { if (dp && dp.style.display === 'block') { if (typeof window.__hideDraft === 'function') window.__hideDraft(true); else dp.style.display = 'none'; } } catch (e) { }
                                } else {
                                    // picker visible -> restore draft only if it was visible before picker hid
                                    try { if (window.__prevDraftVisible && dp && dp.style.display !== 'block') { if (typeof window.__showDraft === 'function') window.__showDraft(); } } catch (e) { }
                                }
                            } catch (e) { }
                            break;
                        }
                    }
                });
                popupPosObserver.observe(numberPickerPopup, { attributes: true, attributeFilter: ['style'] });
                // store observer so it can be disconnected later if needed
                try { window.__popupPosObserver = popupPosObserver; } catch (e) { }
            } catch (e) { }

            // drag state for trash -> fallback restore when dragend occurs without drop
            let draggingFromTrash = null;
            let draggingNumber = null; // current number being dragged (from popup or trash)
            let lastDragClientX = 0;
            let lastDragClientY = 0;

            let trashEnabled = true;
            let trashItems = [];
            // favorites list
            let favItems = [];

            // Enforce exclusivity at startup: if a number is both in fav and trash,
            // prefer `fav` and remove it from `trashItems` so a number belongs to at most one list.
            try {
                const favSet = new Set((favItems || []).map(n => Number(n)));
                if (Array.isArray(trashItems) && favSet.size) trashItems = (trashItems || []).filter(n => !favSet.has(Number(n)));
            } catch (e) { }

            function setTrashButtonState() {
                trashBtn.classList.toggle('disabled', !trashEnabled);
            }
            // Manual toggle removed; trashEnabled remains controlled programmatically and defaults to true.

            trashBtn.addEventListener('click', (ev) => {
                if (!trashEnabled) return; // only clickable when enabled
                trashPopup.style.display = (trashPopup.style.display === 'block') ? 'none' : 'block';
                // remember the user's explicit toggle state
                window.__prevTrashVisible = (trashPopup.style.display === 'block');
                adjustTrashPosition();
            });

            // Favorite button toggle
            const favBtn = document.getElementById('favBtn');
            function adjustFavPosition() {
                try {
                    // Ensure fav uses fixed positioning for predictable viewport coords
                    favPopup.style.position = 'fixed';
                    const pickerRect = numberPickerPopup.getBoundingClientRect();

                    // Always compute hypothetical trash position (same logic as
                    // adjustTrashPosition) so favPopup stays in the EXACT same place
                    // regardless of whether trash is visible or hidden.
                    const sample = numberPickerTable.querySelector('tbody tr td');
                    const cellW = sample ? Math.max(28, Math.round(sample.getBoundingClientRect().width)) : 80;
                    let hypTrashW = Math.max(3 * cellW + 80, 300);
                    let hypTrashH = Math.round(hypTrashW / 1.732);

                    // Fav uses same unscaled dimensions as trash
                    const unscaledW = hypTrashW;
                    const unscaledH = hypTrashH;
                    favPopup.style.width = unscaledW + 'px';
                    favPopup.style.height = unscaledH + 'px';

                    // Compute hypothetical trash left/top
                    const gap = 12;
                    let hypLeft = pickerRect.left - hypTrashW - gap;
                    if (hypLeft < 4) hypLeft = pickerRect.right + gap;
                    hypLeft = Math.max(4, Math.min(hypLeft, window.innerWidth - hypTrashW - 4));
                    let hypTop = pickerRect.top + 8;
                    if (hypTop + hypTrashH > window.innerHeight - 8) hypTop = Math.max(8, window.innerHeight - hypTrashH - 8);

                    // Read current popup scale from inline transform
                    const scaleMatch = (trashPopup.style.transform || favPopup.style.transform || '').match(/scale\(([^)]+)\)/);
                    const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

                    // Place fav below hypothetical trash.
                    // With transformOrigin 'top right', visual trash bottom =
                    // hypTop + hypTrashH * scale. Right edge = hypLeft + hypTrashW (fixed).
                    const favGap = 14;
                    let left = Math.round(hypLeft);
                    let top = Math.round(hypTop + hypTrashH * scale + favGap);

                    // Basic viewport clamping (same approach as adjustTrashPosition)
                    left = Math.max(4, Math.min(left, window.innerWidth - unscaledW - 4));
                    if (top + unscaledH > window.innerHeight - 8) {
                        top = Math.max(8, Math.round(pickerRect.top - unscaledH - favGap));
                    }

                    favPopup.style.left = left + 'px';
                    favPopup.style.top = top + 'px';
                } catch (e) { }
            }

            if (favBtn) {
                favBtn.addEventListener('click', () => {
                    favPopup.style.display = (favPopup.style.display === 'block') ? 'none' : 'block';
                    if (favPopup.style.display === 'block') {
                        adjustFavPosition();
                    }
                });
                // Allow dropping numbers onto the fav button (or its container) to add to favorites
                const favDropHandler = (e) => {
                    try {
                        e.preventDefault();
                        try { e.stopImmediatePropagation(); } catch (xx) { }
                        // mark handled so global fallback ignores
                        try { window.__favDropHandled = true; setTimeout(() => window.__favDropHandled = false, 120); } catch (xx) { }
                        // try to read from dataTransfer first
                        let n = Number(e.dataTransfer.getData('text/plain'));
                        // fallback to delegated draggedNumber var if available
                        if (!Number.isFinite(n) && typeof draggedNumber !== 'undefined' && draggedNumber) {
                            n = Number(draggedNumber);
                        }
                        if (Number.isFinite(n)) addToFav(n);
                    } catch (err) { }
                };

                const favDragOver = (e) => { e.preventDefault(); try { e.stopImmediatePropagation(); e.dataTransfer.dropEffect = 'move'; } catch (err) { } };
                const favDragEnter = (e) => { try { e.stopImmediatePropagation(); favBtn.classList.add('fav-drag-over'); } catch (err) { } };
                const favDragLeave = (e) => { try { e.stopImmediatePropagation(); favBtn.classList.remove('fav-drag-over'); } catch (err) { } };

                favBtn.addEventListener('dragover', favDragOver);
                favBtn.addEventListener('dragenter', favDragEnter);
                favBtn.addEventListener('dragleave', favDragLeave);
                favBtn.addEventListener('drop', (e) => { favDragLeave(e); favDropHandler(e); });

                // also allow dropping onto the small container holding trash/fav buttons
                try {
                    const favContainer = favBtn.parentElement;
                    if (favContainer) {
                        favContainer.addEventListener('dragover', favDragOver);
                        favContainer.addEventListener('drop', favDropHandler);
                        favContainer.addEventListener('dragenter', favDragEnter);
                        favContainer.addEventListener('dragleave', favDragLeave);
                    }
                } catch (err) { }
            }

            function renderFav() {
                try {
                    const tbody = favPopup.querySelector('tbody');
                    tbody.innerHTML = '';
                    for (let i = 0; i < favItems.length; i += 3) {
                        const tr = document.createElement('tr');
                        for (let j = 0; j < 3; j++) {
                            const idx = i + j;
                            const td = document.createElement('td');
                            if (idx < favItems.length) {
                                const n = favItems[idx];
                                td.dataset.number = String(n);
                                // mark this td so fav-specific visuals apply
                                td.classList.add('fav-number');
                                const src = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                                if (src) {
                                    // preserve nested markup (rank pills, spans) similar to trash clone
                                    const inner = document.createElement('div');
                                    inner.className = 'trash-inner';
                                    inner.innerHTML = src.innerHTML;
                                    // remove any injected restore handles from the cloned markup
                                    try {
                                        const bad = Array.from(inner.querySelectorAll('.restore-handle, .restore-handle-test'));
                                        for (const b of bad) try { b.remove(); } catch (e) { }
                                    } catch (e) { }
                                    // copy relevant attributes/classes from source td to fav td
                                    try {
                                        for (const cls of Array.from(src.classList || [])) {
                                            // don't copy transient markers into the fav popup
                                            if (cls === 'in-fav' || cls === 'in-trash') continue;
                                            if (!td.classList.contains(cls)) td.classList.add(cls);
                                        }
                                        // copy inline style if present, but strip visual properties so source highlights
                                        // don't override fav popup visuals
                                        const s = src.getAttribute('style');
                                        if (s) {
                                            try {
                                                let sanitized = String(s)
                                                    .replace(/background[^;]*;?/gi, '')
                                                    .replace(/color[^;]*;?/gi, '')
                                                    .replace(/box-shadow[^;]*;?/gi, '')
                                                    .replace(/outline[^;]*;?/gi, '')
                                                    .replace(/border-color[^;]*;?/gi, '');
                                                if (sanitized.trim()) {
                                                    td.setAttribute('style', (td.getAttribute('style') || '') + ';' + sanitized);
                                                }
                                            } catch (err) { /* ignore sanitize errors */ }
                                        }
                                    } catch (err) { /* ignore */ }
                                    td.appendChild(inner);
                                } else {
                                    const inner = document.createElement('div');
                                    inner.className = 'trash-inner';
                                    inner.textContent = String(n);
                                    td.appendChild(inner);
                                }
                                td.draggable = true;
                                td.addEventListener('dragstart', (e) => {
                                    e.dataTransfer.setData('text/plain', String(n));
                                    e.dataTransfer.setData('source', 'fav');
                                    e.dataTransfer.effectAllowed = 'move';
                                });
                                td.addEventListener('dblclick', () => { removeFromFav(n); });
                            }
                            tr.appendChild(td);
                        }
                        tbody.appendChild(tr);
                    }
                    adjustFavPosition();
                    try { updateFavBadge(); } catch (e) { }
                } catch (e) { }
            }

            // --- Fav preview on hover (temporary, does not modify `favItems`) ---
            let __favPreviewActive = false;
            let __favPreviewTimer = null;
            let __favPopupPrev = null;
            // no manual-open tracking: preview will either replace favPopup contents
            // if favPopup is already visible, or use the numberPicker highlight when closed
            let __favPreviewUsesPickerHighlight = false;

            function renderFavPreview(n) {
                try {
                    if (!n || !Number.isFinite(Number(n))) return;
                    // always allow preview to replace favPopup contents while active
                    const tbody = favPopup.querySelector('tbody');
                    if (!tbody) return;
                    // save previous state so we can restore
                    if (!__favPreviewActive) {
                        // compute current visibility (respect CSS-driven visibility)
                        // record whether popup was explicitly opened by the user (inline style)
                        const inlineVisible = (favPopup.style && favPopup.style.display === 'block');
                        // save current popup tbody html and display, and also badge state
                        const b = document.getElementById('favBadge');
                        const badgeState = b ? { text: b.textContent || '', hidden: b.classList.contains('hidden') } : null;
                        __favPopupPrev = { html: tbody.innerHTML, display: favPopup.style.display || '', badge: badgeState, inlineVisible: !!inlineVisible };
                        __favPreviewUsesPickerHighlight = false;
                    }
                    // Build preview row and always show it in the fav popup (behave like trash preview)
                    const tr = document.createElement('tr');
                    for (let j = 0; j < 3; j++) {
                        const td = document.createElement('td');
                        if (j === 0) {
                            td.dataset.number = String(n);
                            td.classList.add('fav-number');
                            const src = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                            if (src) {
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                inner.innerHTML = src.innerHTML;
                                // sanitize remove restore handles if any
                                try { Array.from(inner.querySelectorAll('.restore-handle, .restore-handle-test')).forEach(x => x.remove()); } catch (e) { }
                                // copy relevant attributes/classes from source td to fav td (match renderFav())
                                try {
                                    for (const cls of Array.from(src.classList || [])) {
                                        if (cls === 'in-fav' || cls === 'in-trash') continue;
                                        if (!td.classList.contains(cls)) td.classList.add(cls);
                                    }
                                    const s = src.getAttribute('style');
                                    if (s) {
                                        try {
                                            let sanitized = String(s)
                                                .replace(/background[^;]*;?/gi, '')
                                                .replace(/color[^;]*;?/gi, '')
                                                .replace(/box-shadow[^;]*;?/gi, '')
                                                .replace(/outline[^;]*;?/gi, '')
                                                .replace(/border-color[^;]*;?/gi, '');
                                            if (sanitized.trim()) {
                                                td.setAttribute('style', (td.getAttribute('style') || '') + ';' + sanitized);
                                            }
                                        } catch (err) { }
                                    }
                                } catch (err) { }
                                td.appendChild(inner);
                            } else {
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                inner.textContent = String(n);
                                td.appendChild(inner);
                            }
                            td.draggable = true;
                        }
                        tr.appendChild(td);
                    }

                    // Replace popup contents and force it visible for the duration of the preview
                    try {
                        tbody.innerHTML = '';
                        tbody.appendChild(tr);
                        // only show popup if it was visible before preview
                        try {
                            // only update inline display/badge if popup was explicitly open before preview
                            if (__favPopupPrev && __favPopupPrev.inlineVisible) favPopup.style.display = 'block';
                        } catch (err) { }
                        try {
                            const b = document.getElementById('favBadge');
                            if (b) {
                                b.classList.remove('hidden');
                                b.textContent = '1';
                            }
                        } catch (e) { }
                        adjustFavPosition();
                        __favPreviewUsesPickerHighlight = false;
                    } catch (e) { }
                    __favPreviewActive = true;
                } catch (e) { }
            }

            function clearFavPreviewSoon(delay = 180) {
                try {
                    if (__favPreviewTimer) { clearTimeout(__favPreviewTimer); __favPreviewTimer = null; }
                    __favPreviewTimer = setTimeout(() => {
                        try {
                            if (!__favPreviewActive) return;
                            const tbody = favPopup.querySelector('tbody');
                            if (__favPreviewUsesPickerHighlight) {
                                // restore picker cell classes
                                try {
                                    if (__favPopupPrev && __favPopupPrev.pickerCell) {
                                        const c = __favPopupPrev.pickerCell;
                                        try { c.classList.remove('popup-number-highlight'); } catch (e) { }
                                        try {
                                            if (!__favPopupPrev.pickerCellHadInFav) c.classList.remove('in-fav');
                                        } catch (e) { }
                                    }
                                } catch (e) { }
                                __favPreviewUsesPickerHighlight = false;
                            } else {
                                if (tbody && __favPopupPrev) tbody.innerHTML = __favPopupPrev.html || '';
                                favPopup.style.display = (__favPopupPrev && __favPopupPrev.display) ? __favPopupPrev.display : 'none';
                                // restore fav badge state if saved
                                try {
                                    const b = document.getElementById('favBadge');
                                    if (b) {
                                        if (__favPopupPrev && __favPopupPrev.badge) {
                                            b.textContent = __favPopupPrev.badge.text || '';
                                            if (__favPopupPrev.badge.hidden) b.classList.add('hidden'); else b.classList.remove('hidden');
                                        } else { b.classList.add('hidden'); b.textContent = ''; }
                                    }
                                } catch (e) { }
                            }
                            __favPreviewActive = false;
                            __favPopupPrev = null;
                        } catch (e) { }
                    }, Number(delay) || 180);
                } catch (e) { }
            }

            // Delegated hover: when hovering rows inside Cell5.5, show a temporary fav preview
            document.addEventListener('mouseover', (ev) => {
                try {
                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-result]') : null;
                    if (!tr) return;
                    // ensure the row belongs to cell5_5 or cell6_5
                    const sec = tr.closest('section');
                    if (!sec || (sec.id !== 'cell5_5' && sec.id !== 'cell6_5' && sec.id !== 'cell6_6' && sec.id !== 'cell7' && sec.id !== 'cell8' && sec.id !== 'cell9' && sec.id !== 'cell11')) return;
                    // Only preview fav when fav toggle is "fav"
                    try {
                        const favMode = (typeof window.getFavToggleMode === 'function') ? window.getFavToggleMode() : 'normal';
                        if (favMode !== 'fav') return;
                    } catch (e) { return; }
                    // allow preview even if favPopup is visible (handled in renderFavPreview)
                    // try parse rule column (third td) like `16>{6,13...}`
                    let n = null;
                    try {
                        const ruleTd = tr.querySelector('td:last-child');
                        const ruleText = ruleTd ? String(ruleTd.textContent || '') : '';
                        const m = ruleText.match(/^\s*(\d{1,2})\s*>/);
                        if (m) n = Number(m[1]);
                    } catch (e) { }
                    // fallback: use second number in data-result (common in your example)
                    if (!n) {
                        const data = tr.dataset && tr.dataset.result ? String(tr.dataset.result) : '';
                        if (data) {
                            const parts = data.split(',').map(s => s.trim()).filter(Boolean);
                            if (parts.length >= 2) n = Number(parts[1]); else if (parts.length === 1) n = Number(parts[0]);
                        }
                    }
                    if (n && Number.isFinite(n)) {
                        // cancel any pending clear and show preview
                        try { if (__favPreviewTimer) { clearTimeout(__favPreviewTimer); __favPreviewTimer = null; } } catch (e) { }
                        renderFavPreview(n);
                    }
                } catch (e) { }
            }, true);

            // hide preview when leaving rows or moving pointer elsewhere
            document.addEventListener('mouseout', (ev) => {
                try {
                    const related = ev.relatedTarget;
                    // if moving into the favPopup or fav button, keep preview (user might interact)
                    if (related && (related.closest && (related.closest('#favPopup') || related.closest('#favBtn')))) return;
                    // otherwise schedule clear
                    clearFavPreviewSoon(180);
                } catch (e) { }
            }, true);

            function addToFav(n) {
                try {
                    n = Number(n);
                    if (!Number.isFinite(n)) return;
                    // Ensure exclusivity: remove from trash if present
                    // Skip when __skipFavTrashExclusion is set (temp hover restore keeps trash intact)
                    try {
                        if (!window.__skipFavTrashExclusion && Array.isArray(trashItems) && trashItems.includes(n)) {
                            trashItems = trashItems.filter(v => v !== n);
                            try { const c = numberPickerTable.querySelector('td[data-number="' + n + '"]'); if (c) c.classList.remove('in-trash'); } catch (e) { }
                            try { renderTrash(); } catch (e) { }
                            try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                        }
                    } catch (e) { }

                    if (!favItems.includes(n)) favItems.push(n);
                    renderFav();
                    try { updateFavBadge(); } catch (e) { }
                    // mark popup cell as fav and ensure trash marker removed
                    try {
                        const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                        if (cell) {
                            if (!window.__skipFavTrashExclusion) cell.classList.remove('in-trash');
                            cell.classList.add('in-fav');
                        }
                    } catch (e) { }
                } catch (e) { }
            }

            function removeFromFav(n) {
                try {
                    n = Number(n);
                    favItems = favItems.filter(v => v !== n);
                    renderFav();
                    try { updateFavBadge(); } catch (e) { }
                    try { const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]'); if (cell) cell.classList.remove('in-fav'); } catch (e) { }
                } catch (e) { }
            }

            // clear favs
            try { const favClear = favPopup.querySelector('#favClearBtn'); if (favClear) favClear.addEventListener('click', () => { favItems = []; renderFav(); try { updateFavBadge(); } catch (e) { } const ins = numberPickerTable.querySelectorAll('td.in-fav'); ins.forEach(i => i.classList.remove('in-fav')); }); } catch (e) { }

            // allow dropping numbers into favPopup (robust: stop propagation, set dropEffect, mark handled)
            favPopup.addEventListener('dragover', (e) => { try { e.preventDefault(); e.stopImmediatePropagation(); } catch (err) { } });
            favPopup.addEventListener('dragenter', (e) => { try { e.stopImmediatePropagation(); favPopup.classList && favPopup.classList.add('fav-drag-over'); } catch (err) { } });
            favPopup.addEventListener('dragleave', (e) => { try { e.stopImmediatePropagation(); favPopup.classList && favPopup.classList.remove('fav-drag-over'); } catch (err) { } });
            favPopup.addEventListener('drop', (e) => {
                try {
                    e.preventDefault();
                    try { e.stopImmediatePropagation(); } catch (xx) { }
                    try { window.__favDropHandled = true; setTimeout(() => window.__favDropHandled = false, 120); } catch (xx) { }
                    favPopup.classList && favPopup.classList.remove('fav-drag-over');
                    const n = Number(e.dataTransfer.getData('text/plain'));
                    if (!Number.isFinite(n)) return;
                    addToFav(n);
                } catch (err) { }
            });

            // double-click on fav popup: read clipboard and append valid numbers to fav list
            try {
                favPopup.addEventListener('dblclick', async (ev) => {
                    try {
                        // If dblclick happened on a number cell inside favPopup (user intends to remove),
                        // do not run the paste-from-clipboard logic here. Let the per-cell handler run.
                        try {
                            if (ev.target && ev.target.closest && ev.target.closest('td.fav-number, .fav-number, td.trash-number, .number-main, .rank-in-cell, .pill')) return;
                        } catch (ee) { }

                        // Ignore dblclicks that originate from UI controls (buttons/inputs/selects)
                        try {
                            if (ev.target && (ev.target.closest('button') || ev.target.closest('input') || ev.target.closest('select'))) return;
                        } catch (ee) { }

                        const processText = (text) => {
                            if (!text) return;
                            const parts = String(text).split(/[^0-9]+/).filter(Boolean);
                            if (parts.length === 0) return;
                            const nums = parts.map(s => parseInt(s, 10)).filter(n => Number.isInteger(n) && n >= 1 && n <= 45);
                            if (nums.length === 0) return;
                            const unique = Array.from(new Set(nums));
                            for (const n of unique) {
                                try { addToFav(n); } catch (e) { }
                            }
                        };

                        // try modern clipboard API first
                        let text = '';
                        try {
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                text = await navigator.clipboard.readText();
                            }
                        } catch (err) { text = ''; }

                        if (text) {
                            processText(text);
                            return;
                        }

                        // Fallback: show a small overlay to paste manually
                        const overlay = document.createElement('div');
                        overlay.style.position = 'fixed';
                        overlay.style.zIndex = 10002;
                        overlay.style.left = '50%';
                        overlay.style.top = '50%';
                        overlay.style.transform = 'translate(-50%,-50%)';
                        overlay.style.background = 'white';
                        overlay.style.border = '2px solid #888';
                        overlay.style.padding = '10px';
                        overlay.style.borderRadius = '8px';
                        overlay.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                        overlay.setAttribute('role', 'dialog');

                        const msg = document.createElement('div');
                        msg.style.marginBottom = '8px';
                        msg.style.color = '#111';
                        msg.textContent = 'Paste numbers here (e.g. 1,2,3) or click "Use clipboard"';
                        const ta = document.createElement('textarea');
                        ta.style.width = '320px';
                        ta.style.height = '80px';
                        ta.style.fontSize = '14px';
                        ta.style.padding = '6px';
                        ta.placeholder = 'Paste (Ctrl+V) or type numbers then press Ctrl+Enter';

                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.gap = '8px';
                        row.style.marginTop = '8px';

                        const useBtn = document.createElement('button');
                        useBtn.textContent = 'Use clipboard';
                        useBtn.className = 'ghost';
                        const submitBtn = document.createElement('button');
                        submitBtn.textContent = 'Submit';
                        submitBtn.className = 'primary';
                        const cancelBtn = document.createElement('button');
                        cancelBtn.textContent = 'Cancel';
                        cancelBtn.className = 'clear-btn';

                        row.appendChild(useBtn);
                        row.appendChild(submitBtn);
                        row.appendChild(cancelBtn);

                        overlay.appendChild(msg);
                        overlay.appendChild(ta);
                        overlay.appendChild(row);
                        document.body.appendChild(overlay);
                        ta.focus();

                        let resolved = false;
                        const clean = (v) => {
                            if (resolved) return; resolved = true;
                            try { overlay.remove(); } catch (e) { }
                            if (v) processText(v);
                        };

                        useBtn.addEventListener('click', async () => {
                            try {
                                if (navigator.clipboard && navigator.clipboard.readText) {
                                    const t = await navigator.clipboard.readText();
                                    if (t) { clean(t); return; }
                                    alert('Clipboard is empty or not available. Please paste manually.');
                                } else {
                                    alert('Clipboard API not available. Please paste manually.');
                                }
                            } catch (e) { alert('Cannot read clipboard. Please paste manually.'); }
                        });

                        submitBtn.addEventListener('click', () => { clean(ta.value || ''); });
                        cancelBtn.addEventListener('click', () => { clean(''); });

                        ta.addEventListener('paste', (e) => {
                            try {
                                e.preventDefault();
                                const d = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : null;
                                if (d) clean(String(d));
                                else setTimeout(() => clean(ta.value || ''), 50);
                            } catch (err) { clean(''); }
                        }, { once: true });

                        ta.addEventListener('keydown', (e) => {
                            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                                e.preventDefault();
                                clean(ta.value || '');
                            }
                        });

                        setTimeout(() => { clean(''); }, 12000);
                    } catch (err) { }
                });
            } catch (e) { }

            // allow dropping from fav back to popup: accept drops on numberPickerTable to remove
            numberPickerTable.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
            numberPickerTable.addEventListener('drop', (e) => {
                try {
                    e.preventDefault();
                    const src = e.dataTransfer.getData('source');
                    const n = Number(e.dataTransfer.getData('text/plain'));
                    if (src === 'fav' && Number.isFinite(n)) {
                        removeFromFav(n);
                    }
                } catch (err) { }
            });

            // dblclick on a popup number toggles fav state
            numberPickerTable.addEventListener('dblclick', (e) => {
                try {
                    // Handle label cell (C1-C6) dblclick: toggle fav for all numbers in that column
                    const th = e.target.closest('th.label-cell');
                    if (th) {
                        const label = th.dataset.label; // e.g. "C2"
                        const colNum = parseInt(label.substring(1), 10);
                        const colNums = [];
                        for (let i = 1; i <= 45; i++) { if (getCol(i) === colNum) colNums.push(i); }
                        if (!colNums.length) return;
                        // Check if ALL numbers in this column are already in fav
                        const allInFav = colNums.every(n => favItems.includes(n));
                        if (allInFav) {
                            // Remove all from fav
                            for (const n of colNums) { try { removeFromFav(n); } catch (e) { } }
                        } else {
                            // Add all to fav (will also remove from trash via exclusivity)
                            for (const n of colNums) { try { addToFav(n); } catch (e) { } }
                        }
                        try { updateLabelCellColStates(); } catch (e) { }
                        return;
                    }
                    const td = e.target.closest('td');
                    if (!td) return;
                    const n = Number(td.dataset.number || td.getAttribute('data-number'));
                    if (!Number.isFinite(n)) return;
                    if (favItems.includes(n)) removeFromFav(n); else addToFav(n);
                } catch (err) { }
            });

            // Helper: get all numbers belonging to a column
            function getColNumbers(colNum) {
                const nums = [];
                for (let i = 1; i <= 45; i++) { if (getCol(i) === colNum) nums.push(i); }
                return nums;
            }

            // Helper: update label cell visual states (trashed/fav indicators)
            function updateLabelCellColStates() {
                try {
                    const labels = numberPickerTable.querySelectorAll('th.label-cell');
                    labels.forEach(cell => {
                        const colNum = parseInt(cell.dataset.label.substring(1), 10);
                        const colNums = getColNumbers(colNum);
                        const allTrash = colNums.length > 0 && colNums.every(n => trashItems.includes(n));
                        const allFav = colNums.length > 0 && colNums.every(n => favItems.includes(n));
                        cell.classList.toggle('col-all-trashed', allTrash);
                        cell.classList.toggle('col-all-fav', allFav);
                    });
                } catch (e) { }
            }
            // Expose globally so regeneratePopupTable can call it
            window.__updateLabelCellColStates = updateLabelCellColStates;

            // Listen for trash/fav changes to keep label states in sync
            try {
                document.addEventListener('trashupdated', () => { try { updateLabelCellColStates(); } catch (e) { } }, true);
                document.addEventListener('favchange', () => { try { updateLabelCellColStates(); } catch (e) { } }, true);
            } catch (e) { }

            function adjustTrashPosition() {
                const sample = numberPickerTable.querySelector('tbody tr td');
                const cellW = sample ? Math.max(28, Math.round(sample.getBoundingClientRect().width)) : 80;
                let trashW = 3 * cellW + 80; // add extra width to avoid horizontal scrollbar
                const MIN_TRASH_W = 300; // ensure popup is wide enough to contain header controls (k̄, buttons)
                trashW = Math.max(trashW, MIN_TRASH_W);
                const trashH = Math.round(trashW / 1.732);
                trashPopup.style.setProperty('--trash-width', trashW + 'px');
                trashPopup.style.width = trashW + 'px';
                trashPopup.style.minWidth = MIN_TRASH_W + 'px';
                trashPopup.style.height = trashH + 'px';

                // position relative to the picker popup but in viewport coords
                const pickerRect = numberPickerPopup.getBoundingClientRect();
                const gap = 12;
                // prefer left side if there's space, otherwise place on the right
                let left = pickerRect.left - trashW - gap;
                if (left < 4) left = pickerRect.right + gap; // place to right if not enough left space
                // ensure popup stays within viewport horizontally
                left = Math.max(4, Math.min(left, window.innerWidth - trashW - 4));
                // vertical: align near top of picker, but keep within viewport
                let top = pickerRect.top + 8;
                if (top + trashH > window.innerHeight - 8) top = Math.max(8, window.innerHeight - trashH - 8);
                trashPopup.style.left = left + 'px';
                trashPopup.style.top = top + 'px';
                try { if (typeof adjustFavPosition === 'function') adjustFavPosition(); } catch (e) { }
            }

            // Position the draft popup so it sticks to the right side of the
            // number-picker popup (and falls back to the left if no room).
            function adjustDraftPosition() {
                try {
                    const draftPopup = document.getElementById('draftPopup');
                    if (!draftPopup) return;
                    // ensure fixed positioning
                    draftPopup.style.position = 'fixed';
                    const pickerRect = numberPickerPopup.getBoundingClientRect();
                    const gap = 8;

                    // measure draft dimensions
                    const dpW = draftPopup.offsetWidth || Math.max(280, 320);
                    const dpH = draftPopup.offsetHeight || Math.round(dpW / 1.732);

                    // preferred: attach to right of picker
                    let left = Math.round(pickerRect.right + gap);
                    if (left + dpW > window.innerWidth - 4) {
                        // not enough room on right -> place to left
                        left = Math.round(pickerRect.left - dpW - gap);
                    }
                    // clamp into viewport
                    left = Math.max(4, Math.min(left, window.innerWidth - dpW - 4));

                    let top = Math.round(pickerRect.top + 8);
                    if (top + dpH > window.innerHeight - 8) top = Math.max(8, window.innerHeight - dpH - 8);

                    draftPopup.style.left = left + 'px';
                    draftPopup.style.top = top + 'px';
                } catch (e) { /* ignore */ }
            }

            try { window.__adjustDraftPosition = adjustDraftPosition; } catch (e) { }

            function renderTrash() {
                const tbody = trashPopup.querySelector('tbody');
                tbody.innerHTML = '';
                for (let i = 0; i < trashItems.length; i += 3) {
                    const tr = document.createElement('tr');
                    for (let j = 0; j < 3; j++) {
                        const idx = i + j;
                        const td = document.createElement('td');
                        if (idx < trashItems.length) {
                            const n = trashItems[idx];
                            td.className = 'trash-number';
                            td.dataset.number = String(n);
                            // try to clone inside markup if available, otherwise plain text
                            const src = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                            if (src) {
                                // preserve the exact inner markup (numbers, rank pills, spans)
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                // copy innerHTML so the nested spans and pills keep their classes
                                inner.innerHTML = src.innerHTML;
                                // remove any injected restore handles from the cloned markup
                                try {
                                    const bad = Array.from(inner.querySelectorAll('.restore-handle, .restore-handle-test'));
                                    for (const b of bad) try { b.remove(); } catch (e) { }
                                } catch (e) { }
                                // copy relevant attributes from source td to trash td (except id)
                                try {
                                    for (const cls of Array.from(src.classList || [])) {
                                        if (!td.classList.contains(cls)) td.classList.add(cls);
                                    }
                                    // ensure trash-number class remains present
                                    if (!td.classList.contains('trash-number')) td.classList.add('trash-number');
                                    // copy inline style if present, but strip visual properties
                                    // (background/color/box-shadow/outline) so highlights
                                    // from the source don't override the trash popup visuals.
                                    const s = src.getAttribute('style');
                                    if (s) {
                                        try {
                                            let sanitized = String(s)
                                                .replace(/background[^;]*;?/gi, '')
                                                .replace(/color[^;]*;?/gi, '')
                                                .replace(/box-shadow[^;]*;?/gi, '')
                                                .replace(/outline[^;]*;?/gi, '')
                                                .replace(/border-color[^;]*;?/gi, '');
                                            if (sanitized.trim()) {
                                                td.setAttribute('style', (td.getAttribute('style') || '') + ';' + sanitized);
                                            }
                                        } catch (err) { /* ignore sanitize errors */ }
                                    }
                                } catch (err) { /* ignore */ }
                                td.appendChild(inner);
                            } else {
                                const inner = document.createElement('div');
                                inner.className = 'trash-inner';
                                inner.textContent = String(n);
                                td.appendChild(inner);
                            }
                            td.draggable = true;
                            td.addEventListener('dragstart', (e) => {
                                e.dataTransfer.setData('text/plain', String(n));
                                e.dataTransfer.setData('source', 'trash');
                                e.dataTransfer.effectAllowed = 'move';
                            });
                            td.addEventListener('dblclick', () => { restoreFromTrash(n); });
                        } else {
                            td.innerHTML = '';
                        }
                        tr.appendChild(td);
                    }
                    tbody.appendChild(tr);
                }
                adjustTrashPosition();
                // After rendering trash cells update their tooltips (x<>y)
                try { updateTrashTooltips(); } catch (e) { /* ignore */ }
                // update the visual badge on the trash button so users see count
                try { if (typeof updateTrashBadge === 'function') updateTrashBadge(); } catch (e) { }
                // ensure restore handles exist for any in-popup trashed cells
                try { if (typeof ensureRestoreHandles === 'function') ensureRestoreHandles(); } catch (e) { }
            }

            function ensureTrashBadge() {
                try {
                    let b = document.getElementById('trashBadge');
                    const btn = document.getElementById('trashBtn');
                    if (!btn) return null;
                    if (!b) {
                        b = document.createElement('span');
                        b.id = 'trashBadge';
                        b.className = 'trash-badge hidden';
                        b.setAttribute('aria-hidden', 'true');
                        try { if (btn && btn.style) btn.style.position = btn.style.position || 'relative'; } catch (e) { }
                        try { btn.appendChild(b); } catch (e) { }
                    }
                    return b;
                } catch (e) { return null; }
            }

            function ensureFavBadge() {
                try {
                    let b = document.getElementById('favBadge');
                    const btn = document.getElementById('favBtn');
                    if (!btn) return null;
                    if (!b) {
                        b = document.createElement('span');
                        b.id = 'favBadge';
                        b.className = 'trash-badge hidden';
                        b.setAttribute('aria-hidden', 'true');
                        try { if (btn && btn.style) btn.style.position = btn.style.position || 'relative'; } catch (e) { }
                        try { btn.appendChild(b); } catch (e) { }
                    }
                    return b;
                } catch (e) { return null; }
            }

            function updateFavBadge() {
                try {
                    const b = ensureFavBadge();
                    if (!b) return;
                    const count = Array.isArray(favItems) ? favItems.length : 0;
                    if (!count) { b.classList.add('hidden'); b.textContent = ''; }
                    else { b.classList.remove('hidden'); b.textContent = (count > 99 ? '99+' : String(count)); }
                } catch (e) { /* ignore */ }
            }

            function updateTrashBadge() {
                try {
                    const b = ensureTrashBadge();
                    if (!b) return;
                    const count = Array.isArray(trashItems) ? trashItems.length : ((window.getTrashItems && window.getTrashItems().length) || 0);
                    if (!count) { b.classList.add('hidden'); b.textContent = ''; }
                    else { b.classList.remove('hidden'); b.textContent = (count > 99 ? '99+' : String(count)); }
                } catch (e) { /* ignore */ }
            }

            // Helper: read current average k (try header span, fallback to visible rows)
            function getCurrentAvgK() {
                try {
                    if (typeof window.__lastAvgK === 'number' && !Number.isNaN(window.__lastAvgK)) {
                        //console.log('[TRASH-DEBUG] getCurrentAvgK returning __lastAvgK=', window.__lastAvgK);
                        return window.__lastAvgK;
                    }
                } catch (e) { }
                try {
                    const tp = document.getElementById('trashPopup');
                    if (tp) {
                        const span = tp.querySelector('.avg-k');
                        if (span) {
                            const m = String(span.textContent || '').match(/([0-9]+(?:\.[0-9]+)?)/);
                            if (m) {
                                //console.log('[TRASH-DEBUG] getCurrentAvgK parsed avg from popup span=', Number(m[1]));
                                return Number(m[1]);
                            }
                        }
                    }
                } catch (e) { }
                // fallback: compute avg from full filtered rows (no scrolling) using row cache
                try {
                    const filtered = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                    const ks = filtered.map(r => {
                        try { return (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(r)) : NaN; } catch (e) { return NaN; }
                    }).filter(v => Number.isFinite(v));
                    if (!ks.length) return 0;
                    const computed = ks.reduce((a, b) => a + b, 0) / ks.length;
                    //console.log('[TRASH-DEBUG] getCurrentAvgK computed fallback avg=', computed, 'count=', ks.length);
                    return computed;
                } catch (e) { return 0; }
            }

            // Return array of row objects matching current Cell5.5 filters (year/month/trash)
            window.getCell5_5FilteredRows = function () {
                try {
                    const section = document.getElementById('cell5_5');
                    if (!section) return rows.slice();
                    const controls = section.querySelector('.controls');
                    if (!controls) return rows.slice();
                    const selects = Array.from(controls.querySelectorAll('select'));
                    // selects order in renderCell5_5: [sortSel, yearSel, monthSel, (maybe) trashSel]
                    const yearSel = selects[1] || null;
                    const monthSel = selects[2] || null;
                    const trashSel = selects[3] || null;
                    const yearVal = yearSel ? yearSel.value : 'all';
                    const monthVal = monthSel ? monthSel.value : 'all';
                    const trashVal = trashSel ? trashSel.value : 'include';

                    // filter rows similar to buildCountsHtml/populateMonths
                    const filtered = rows.filter(r => {
                        try {
                            const s = String(r.date || '');
                            if (!s) return false;
                            if (yearVal && yearVal !== 'all') {
                                if (s.length < 4 || s.slice(-4) !== yearVal) return false;
                            }
                            if (monthVal && monthVal !== 'all') {
                                // parse dd/mm/yyyy or other common formats similar to renderCell5_5.parseDateSortable
                                let ts = 0;
                                let m1 = s.match(/^\s*(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s*$/);
                                if (m1) {
                                    let dd = Number(m1[1]), mm = Number(m1[2]), yy = Number(m1[3]);
                                    if (yy < 100) yy += 2000;
                                    const dt = new Date(yy, mm - 1, dd);
                                    if (!isNaN(dt)) ts = dt.getTime();
                                }
                                if (!ts) {
                                    const digits = s.replace(/\D/g, '');
                                    if (/^\d+$/.test(digits)) {
                                        if (digits.length === 8) {
                                            const dd = Number(digits.slice(0, 2)), mm = Number(digits.slice(2, 4)), yyyy = Number(digits.slice(4, 8));
                                            const dt2 = new Date(yyyy, mm - 1, dd);
                                            if (!isNaN(dt2)) ts = dt2.getTime();
                                        } else {
                                            const d6 = digits.padStart(6, '0');
                                            const dd = Number(d6.slice(0, 2)), mm = Number(d6.slice(2, 4)), yy2 = 2000 + Number(d6.slice(4, 6));
                                            const dt3 = new Date(yy2, mm - 1, dd);
                                            if (!isNaN(dt3)) ts = dt3.getTime();
                                        }
                                    }
                                }
                                if (!ts) {
                                    const dtf = new Date(s);
                                    if (!isNaN(dtf)) ts = dtf.getTime();
                                }
                                if (!ts) return false;
                                const dtFinal = new Date(ts);
                                const m = String(dtFinal.getMonth() + 1).padStart(2, '0');
                                if (m !== monthVal) return false;
                            }
                            // if trashSel == 'exclude', filter out rows that do not contain any number currently in trash
                            if (trashVal === 'exclude') {
                                // when excluding, keep rows that DO NOT contain any trashed number
                                try {
                                    if (!Array.isArray(r.nums)) return true;
                                    for (const v of (r.nums || [])) if (trashItems.includes(Number(v))) return false;
                                } catch (e) { }
                            }
                            return true;
                        } catch (e) { return false; }
                    });
                    return filtered;
                } catch (e) { return rows.slice(); }
            };

            // Update tooltip (title) on each trash-number cell to show x<>y
            function updateTrashTooltips() {
                try {
                    const tp = document.getElementById('trashPopup');
                    if (!tp) return;
                    const avg = getCurrentAvgK();
                    const tds = Array.from(tp.querySelectorAll('td.trash-number'));
                    // get the full set of filtered rows (not just DOM-mounted pages)
                    const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                    for (const td of tds) {
                        try {
                            const n = Number(td.dataset.number);
                            if (!n) { td.removeAttribute('title'); continue; }
                            let x = 0, y = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const nums = rowObj.nums || [];
                                    const has = nums.some(v => Number(v) === n);
                                    if (!has) continue;
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) x++; else if (kVal >= avg) y++;
                                } catch (e) { }
                            }
                            // store aggregated counts on a data attribute instead of `title`
                            td.setAttribute('data-agg', `${x}<>${y}`);
                            td.removeAttribute('title');
                        } catch (e) { /* per-td ignore */ }
                    }
                    // also update avg-k header span to show aggregate counts across visible rows
                    try {
                        const firstDiv = tp.querySelector('div');
                        if (firstDiv) {
                            const avgSpan = firstDiv.querySelector('.avg-k');
                            if (avgSpan) {
                                // compute aggregated x/y across filteredRows
                                let aggX = 0, aggY = 0;
                                for (const rowObj of filteredRows) {
                                    try {
                                        const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                        if (!Number.isFinite(kVal)) continue;
                                        if (kVal < avg) aggX++; else if (kVal > avg) aggY++;
                                    } catch (e) { }
                                }
                                // store aggregated counts on a data attribute to avoid native tooltip
                                avgSpan.setAttribute('data-agg', `${aggX}<>${aggY}`);
                                avgSpan.removeAttribute('title');
                                // ensure tooltip updates on hover: attach recompute handler once
                                try {
                                    if (!avgSpan.__aggTooltipBound) {
                                        avgSpan.addEventListener('mouseenter', (ev) => {
                                            try {
                                                // recompute average at the moment of hover so the tooltip
                                                // always reflects the latest k̄ rather than a stale closure
                                                const liveAvg = getCurrentAvgK();
                                                let ax = 0, ay = 0;
                                                const curFiltered = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                                                for (const r2 of curFiltered) {
                                                    try {
                                                        const kv = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(r2)) : NaN;
                                                        if (!Number.isFinite(kv)) continue;
                                                        if (kv < liveAvg) ax++; else if (kv > liveAvg) ay++;
                                                    } catch (ee) { }
                                                }
                                                // update data-agg for the styled tooltip fallback
                                                avgSpan.setAttribute('data-agg', `${ax}<>${ay}`);
                                            } catch (ee) { }
                                        });
                                        avgSpan.__aggTooltipBound = true;
                                        // make span focusable so tooltip can appear on keyboard focus too
                                        if (!avgSpan.hasAttribute('tabindex')) avgSpan.setAttribute('tabindex', '0');
                                    }
                                } catch (e) { }
                            }
                        }
                    } catch (e) { }
                } catch (e) { }
            }

            // Observe changes to Cell5.5 so tooltips recalc after user changes year/month or pages
            try {
                const cell55 = document.getElementById('cell5_5');
                if (cell55 && !cell55.__trashTooltipObserverAdded) {
                    const mo55 = new MutationObserver(() => { try { updateTrashTooltips(); } catch (e) { } });
                    mo55.observe(cell55, { childList: true, subtree: true, attributes: true });
                    cell55.__trashTooltipObserverAdded = true;
                }
            } catch (e) { }

            // Also recalc when trash content changes
            try { (document.getElementById('trashPopup') || document.body).addEventListener('trashchange', () => { try { updateTrashTooltips(); } catch (e) { } }); } catch (e) { }

            // Update Cell6.5 unpair rows highlighting when trash changes.
            function updateCell6_5Highlights() {
                try {
                    const t = (Array.isArray(trashItems) ? trashItems.slice() : (window.getTrashItems ? window.getTrashItems() : []));
                    const set = new Set((t || []).map(n => Number(n)));
                    const rows = Array.from(document.querySelectorAll('#cell6_5 table tbody tr'));
                    for (const r of rows) {
                        try {
                            const numTd = r.children && r.children[0] ? r.children[0] : null;
                            const dontTd = r.children && r.children[1] ? r.children[1] : null;
                            if (!numTd || !dontTd) continue;
                            const raw = (dontTd.textContent || '').trim();
                            const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                            // compute row's main number value
                            const rawNum = (numTd.textContent || '').trim();
                            const rowNum = rawNum === '' ? NaN : Number(rawNum);
                            const rowInTrash = Number.isFinite(rowNum) && set.has(Number(rowNum));
                            // highlight only when ALL dontmatch numbers are present in trash
                            const allInTrash = nums.length > 0 && nums.every(v => set.has(Number(v)));

                            // precedence: if the row's own num is in trash, show yellow->red gradient
                            if (rowInTrash) {
                                numTd.classList.add('cell6-num-in-trash');
                                numTd.classList.remove('cell6-num-highlight');
                                // ensure row no longer appears as dragged-out when the num itself is in trash
                                r.classList.remove('dragged-out', 'dragging-out');
                            } else {
                                numTd.classList.remove('cell6-num-in-trash');
                                if (allInTrash) {
                                    numTd.classList.add('cell6-num-highlight');
                                    // style surrounding record with the same green dragged-out border
                                    r.classList.add('dragged-out');
                                } else {
                                    numTd.classList.remove('cell6-num-highlight');
                                    r.classList.remove('dragged-out', 'dragging-out');
                                }
                            }
                        } catch (e) { }
                    }
                } catch (e) { }
            }

            try { (trashPopup || document.body).addEventListener('trashupdated', () => { try { updateCell6_5Highlights(); } catch (e) { } }); } catch (e) { }
            // Expose to global scope so computeAndApplyUnpairBest (inside renderCell6_5) can call it
            try { window.updateCell6_5Highlights = updateCell6_5Highlights; } catch (e) { }

            // Helper: apply Cell6.5 highlights using an explicit set/array of numbers
            function applyCell6_5HighlightSet(values) {
                try {
                    const set = new Set((values || []).map(v => Number(v)).filter(Number.isFinite));
                    const rows = Array.from(document.querySelectorAll('#cell6_5 table tbody tr'));
                    for (const r of rows) {
                        try {
                            const numTd = r.children && r.children[0] ? r.children[0] : null;
                            const dontTd = r.children && r.children[1] ? r.children[1] : null;
                            if (!numTd || !dontTd) continue;
                            const raw = (dontTd.textContent || '').trim();
                            const nums = raw ? raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n)) : [];
                            const rawNum = (numTd.textContent || '').trim();
                            const rowNum = rawNum === '' ? NaN : Number(rawNum);

                            const rowInSet = Number.isFinite(rowNum) && set.has(Number(rowNum));
                            const allInSet = nums.length > 0 && nums.every(v => set.has(Number(v)));

                            if (rowInSet) {
                                numTd.classList.add('cell6-num-in-trash');
                                numTd.classList.remove('cell6-num-highlight');
                                r.classList.remove('dragged-out', 'dragging-out');
                            } else {
                                numTd.classList.remove('cell6-num-in-trash');
                                if (allInSet) {
                                    numTd.classList.add('cell6-num-highlight');
                                    r.classList.add('dragged-out');
                                } else {
                                    numTd.classList.remove('cell6-num-highlight');
                                    r.classList.remove('dragged-out', 'dragging-out');
                                }
                            }
                        } catch (e) { }
                    }
                } catch (e) { }
            }

            // Keep Cell5.5 in sync when trash changes and mode = 'exclude'
            try {
                (trashPopup || document.body).addEventListener('trashupdated', () => {
                    try {
                        const cell55 = document.getElementById('cell5_5');
                        if (!cell55 || cell55.classList.contains('hidden')) return;
                        const sel = document.getElementById('cell5_5_trashSel');
                        // If selector missing (rare) or set to 'exclude', trigger the internal 'trashchange' event
                        // so the existing in-closure listener inside renderCell5_5 recomputes without creating a new section.
                        if (!sel || sel.value === 'exclude') {
                            try { (document.body || document).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        }
                    } catch (e) { }
                });
            } catch (e) { }
            // Also update highlights whenever Cell6.5 content rerenders
            try {
                const cell65 = document.getElementById('cell6_5');
                if (cell65 && !cell65.__cell6_5HighlighterObserver) {
                    const mo65 = new MutationObserver(() => { try { updateCell6_5Highlights(); } catch (e) { } });
                    mo65.observe(cell65, { childList: true, subtree: true });
                    cell65.__cell6_5HighlighterObserver = mo65;
                }
            } catch (e) { }

            // Create floating tooltip element and delegated handlers as a robust fallback
            try {
                function ensureTrashAggTooltip() {
                    if (document.getElementById('trashAggTooltip')) return document.getElementById('trashAggTooltip');
                    const t = document.createElement('div');
                    t.id = 'trashAggTooltip';
                    t.style.position = 'fixed';
                    t.style.zIndex = 12000;
                    t.style.padding = '6px 8px';
                    t.style.borderRadius = '6px';
                    t.style.background = 'rgba(0,0,0,0.8)';
                    t.style.color = '#fff';
                    t.style.fontWeight = '700';
                    t.style.fontSize = '12px';
                    t.style.pointerEvents = 'none';
                    t.style.transition = 'opacity 0.12s';
                    t.style.opacity = '0';
                    t.style.whiteSpace = 'nowrap';
                    document.body.appendChild(t);
                    return t;
                }

                const aggTip = ensureTrashAggTooltip();

                let aggHideTimeout = null;
                let aggMoveHandler = null;
                function showAggTipAt(text, rect, followCursor = false) {
                    try {
                        aggTip.textContent = text;
                        aggTip.style.opacity = '1';
                        if (aggHideTimeout) { clearTimeout(aggHideTimeout); aggHideTimeout = null; }

                        // If requested, follow the cursor: install a document-level mousemove handler
                        if (followCursor) {
                            if (!aggMoveHandler) {
                                aggMoveHandler = (ev) => {
                                    try {
                                        const pad = 12;
                                        let left = ev.clientX + 12;
                                        let top = ev.clientY + 18;
                                        // prevent going offscreen horizontally
                                        if (left + aggTip.offsetWidth + 8 > window.innerWidth) left = ev.clientX - aggTip.offsetWidth - 12;
                                        if (left < 8) left = 8;
                                        // prevent going offscreen vertically
                                        if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = ev.clientY - aggTip.offsetHeight - 12;
                                        if (top < 8) top = 8;
                                        aggTip.style.left = Math.round(left) + 'px';
                                        aggTip.style.top = Math.round(top) + 'px';
                                    } catch (e) { }
                                };
                                document.addEventListener('mousemove', aggMoveHandler, true);
                            }
                            // position immediately based on provided rect or cursor fallback
                            if (rect && rect.left != null) {
                                aggTip.style.left = Math.round(rect.left + (rect.width / 2) - aggTip.offsetWidth / 2) + 'px';
                                let top = rect.bottom + 8;
                                if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = rect.top - aggTip.offsetHeight - 8;
                                aggTip.style.top = Math.round(top) + 'px';
                            }
                        } else {
                            // position relative to element rectangle (centered)
                            if (rect && rect.left != null) {
                                const pad = 8;
                                let left = Math.round(rect.left + (rect.width / 2) - aggTip.offsetWidth / 2);
                                if (Number.isNaN(left)) left = rect.left + pad;
                                left = Math.max(8, Math.min(left, window.innerWidth - aggTip.offsetWidth - 8));
                                let top = rect.bottom + 8;
                                if (top + aggTip.offsetHeight + 8 > window.innerHeight) top = rect.top - aggTip.offsetHeight - 8;
                                aggTip.style.left = left + 'px';
                                aggTip.style.top = top + 'px';
                            }
                        }
                    } catch (e) { }
                }
                function hideAggTipSoon(delay = 100) {
                    try {
                        if (aggHideTimeout) { clearTimeout(aggHideTimeout); aggHideTimeout = null; }
                        // remove mousemove handler when hiding
                        if (aggMoveHandler) { try { document.removeEventListener('mousemove', aggMoveHandler, true); } catch (e) { } aggMoveHandler = null; }
                        if (!delay || Number(delay) <= 0) {
                            try { aggTip.style.opacity = '0'; } catch (e) { }
                        } else {
                            aggHideTimeout = setTimeout(() => { try { aggTip.style.opacity = '0'; } catch (e) { } }, Number(delay));
                        }
                    } catch (e) { }
                }

                document.addEventListener('mouseover', (ev) => {
                    try {
                        const td = ev.target.closest && ev.target.closest('td.trash-number');
                        const avgEl = ev.target.closest && ev.target.closest('#trashPopup > div:nth-child(1) > span');
                        if (td) {
                            // compute x<>y for this specific number
                            const n = Number(td.dataset.number);
                            if (!n) return;
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let x = 0, y = 0;
                            const avg = getCurrentAvgK();
                            for (const rowObj of filteredRows) {
                                try {
                                    const nums = rowObj.nums || [];
                                    const has = nums.some(v => Number(v) === n);
                                    if (!has) continue;
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) x++; else if (kVal > avg) y++;
                                } catch (e) { }
                            }
                            const rect = td.getBoundingClientRect();
                            showAggTipAt(`${x}<>${y}`, rect, true);
                            return;
                        }
                        if (avgEl) {
                            const avg = getCurrentAvgK();
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let aggX = 0, aggY = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) aggX++; else if (kVal >= avg) aggY++;
                                } catch (e) { }
                            }
                            const rect = avgEl.getBoundingClientRect();
                            showAggTipAt(`${aggX}<>${aggY}`, rect, true);
                            return;
                        }
                    } catch (e) { }
                }, true);

                document.addEventListener('mouseout', (ev) => {
                    try {
                        const related = ev.relatedTarget;
                        const tgt = ev.target;
                        // if leaving to an element inside tooltip or same td/span, ignore
                        // keep tooltip while moving inside the specific header span or the floating tooltip
                        if (related && (related.closest && (related.closest('#trashPopup > div:nth-child(1) > span') || related.closest('#trashAggTooltip')))) return;
                        // if the pointer left the specific header span, hide immediately
                        if (tgt && tgt.closest && tgt.closest('#trashPopup > div:nth-child(1) > span')) {
                            hideAggTipSoon(0);
                        } else {
                            hideAggTipSoon();
                        }
                    } catch (e) { }
                }, true);

                // keyboard focus fallback
                document.addEventListener('focusin', (ev) => {
                    try {
                        const el = ev.target;
                        if (!el) return;
                        if (el.matches && el.matches('#trashPopup > div:nth-child(1) > span')) {
                            const rect = el.getBoundingClientRect();
                            const avg = getCurrentAvgK();
                            const filteredRows = (window.getCell5_5FilteredRows && window.getCell5_5FilteredRows()) || rows.slice();
                            let aggX = 0, aggY = 0;
                            for (const rowObj of filteredRows) {
                                try {
                                    const kVal = (typeof window.getRowTrashK === 'function') ? Number(window.getRowTrashK(rowObj)) : NaN;
                                    if (!Number.isFinite(kVal)) continue;
                                    if (kVal < avg) aggX++; else if (kVal >= avg) aggY++;
                                } catch (e) { }
                            }
                            showAggTipAt(`${aggX}<>${aggY}`, rect, true);
                        }
                    } catch (e) { }
                }, true);
                document.addEventListener('focusout', () => hideAggTipSoon(), true);
            } catch (e) { }

            function moveToTrash(n) {
                n = Number(n);
                try { if (window && window.__trashClearing) return; } catch (e) { }
                if (!n || trashItems.includes(n)) return;
                // Ensure exclusivity: remove from fav if present
                // Skip when __skipTrashFavExclusion is set (temporary hover mode keeps fav intact)
                try {
                    if (!window.__skipTrashFavExclusion && Array.isArray(favItems) && favItems.includes(n)) {
                        favItems = favItems.filter(v => v !== n);
                        try { const c2 = numberPickerTable.querySelector('td[data-number="' + n + '"]'); if (c2) c2.classList.remove('in-fav'); } catch (e) { }
                        try { renderFav(); } catch (e) { }
                        try { updateFavBadge(); } catch (e) { }
                    }
                } catch (e) { }

                const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                if (cell) {
                    if (!window.__skipTrashFavExclusion) cell.classList.remove('in-fav');
                    cell.classList.add('in-trash');
                    // If this number is currently in a place box, show dim overlay (half green / half red)
                    try {
                        const plVals = (window.getPlaceValues ? window.getPlaceValues() : []).map(Number);
                        if (plVals.includes(n)) cell.classList.add('in-trash-dim');
                    } catch (e) { }
                }
                trashItems.push(n);
                renderTrash();
                // ensure trashed popup cells expose a small draggable restore handle
                try { ensureRestoreHandles(); } catch (e) { }
                // update trash popup tooltips immediately
                try { updateTrashTooltips(); } catch (e) { }
                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                // If a user dragged a number from the popup into the trash, treat this as
                // a manual change and disable the Cell6.5 optimizer (if active).
                try {
                    if (typeof draggingNumber !== 'undefined' && draggingNumber === n && (draggingFromTrash === null || draggingFromTrash === undefined)) {
                        const opt = document.getElementById('cell6_5_optimize');
                        if (opt && opt.checked) {
                            opt.checked = false;
                            try { opt.dispatchEvent(new Event('change', { bubbles: true })); } catch (er) { try { opt.dispatchEvent(new Event('change')); } catch (ee) { } }
                        }
                    }
                } catch (e) { }
                // Only notify/listeners and trigger recompute when effective trash mode is 'exclude'.
                try {
                    const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel') || document.getElementById('cell5_5_trashSel'));
                    const mode = (tEl && tEl.value) ? String(tEl.value) : 'include';
                    if (mode === 'exclude') {
                        try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        try {
                            const sec = document.getElementById('cell6_5');
                            if (sec && typeof sec.__invalidate === 'function') sec.__invalidate();
                            if (sec && typeof sec.__group === 'function') sec.__group();
                        } catch (err) { }
                    }
                } catch (e) { }
            }

            // Allow other parts of the app to request adding multiple numbers into trash
            // Dispatch event: `moveMultipleToTrash` with detail { nums: [1,2,3] }
            try {
                document.addEventListener('moveMultipleToTrash', (ev) => {
                    try {
                        if (!trashEnabled) return; // only when trash is enabled
                        const nums = (ev && ev.detail && Array.isArray(ev.detail.nums)) ? ev.detail.nums : [];
                        for (const v of nums) {
                            try { moveToTrash(Number(v)); } catch (e) { }
                        }
                    } catch (e) { }
                });
                // Allow other parts of the app to request restoring multiple numbers from trash
                // Dispatch event: `restoreMultipleFromTrash` with detail { nums: [1,2,3] }
                document.addEventListener('restoreMultipleFromTrash', (ev) => {
                    try {
                        const nums = (ev && ev.detail && Array.isArray(ev.detail.nums)) ? ev.detail.nums : [];
                        for (const v of nums) {
                            try { restoreFromTrash(Number(v)); } catch (e) { }
                        }
                    } catch (e) { }
                });
            } catch (e) { }

            function restoreFromTrash(n) {
                n = Number(n);
                const idx = trashItems.indexOf(n);
                if (idx === -1) return;
                trashItems.splice(idx, 1);
                const cell = numberPickerTable.querySelector('td[data-number="' + n + '"]');
                if (cell) { cell.classList.remove('in-trash'); cell.classList.remove('in-trash-dim'); }
                renderTrash();
                try { ensureRestoreHandles(); } catch (e) { }
                // update trash popup tooltips immediately
                try { updateTrashTooltips(); } catch (e) { }
                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                // If optimizer checkbox is active for Cell6.5, uncheck it when user restores any number
                try {
                    const opt = document.getElementById('cell6_5_optimize');
                    if (opt && opt.checked) {
                        opt.checked = false;
                        try { opt.dispatchEvent(new Event('change', { bubbles: true })); } catch (er) { try { opt.dispatchEvent(new Event('change')); } catch (ee) { } }
                    }
                } catch (e) { }
                // Only notify/listeners and trigger recompute when effective trash mode is 'exclude'.
                try {
                    const tEl = (document.getElementById('cell6_6_trashSel') || document.getElementById('cell6_5_trashSel') || document.getElementById('cell5_5_trashSel'));
                    const mode = (tEl && tEl.value) ? String(tEl.value) : 'include';
                    if (mode === 'exclude') {
                        try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        try {
                            const sec = document.getElementById('cell6_5');
                            if (sec && typeof sec.__invalidate === 'function') sec.__invalidate();
                            if (sec && typeof sec.__group === 'function') sec.__group();
                        } catch (err) { }
                    }
                } catch (e) { }
            }

            // delegated dragstart to mark source for popup cells and track trash-origin
            document.addEventListener('dragstart', (e) => {
                try {
                    // Handle label cell (C1-C6) drag for column-level trash/restore
                    const th = e.target.closest('th.label-cell');
                    if (th && th.closest('#numberPickerTable')) {
                        const label = th.dataset.label; // e.g. "C2"
                        const colNum = parseInt(label.substring(1), 10);
                        e.dataTransfer.setData('text/plain', label);
                        e.dataTransfer.setData('source', 'label-col');
                        e.dataTransfer.setData('application/x-label', label);
                        e.dataTransfer.effectAllowed = 'move';
                        th.style.opacity = '0.5';
                        window.__lastDragSource = 'label-col';
                        window.__draggingLabelCol = colNum;
                        window.__dragOriginCell = th;
                        draggingNumber = null;
                        draggingFromTrash = null;
                        return; // don't fall through to td handling
                    }
                    const td = e.target.closest('td');
                    if (!td) return;
                    const num = td.dataset && td.dataset.number ? td.dataset.number : (td.textContent || '').trim();
                    const parsed = parseInt(num);
                    if (!parsed) return;
                    // determine logical source: prefer explicit trash origin when the cell
                    // has been marked as `in-trash` (even if it's still rendered inside the popup).
                    let source = td.closest('#trashPopup') ? 'trash' : td.closest('#favPopup') ? 'fav' : (td.closest('#numberPickerTable') ? 'popup' : 'other');
                    try {
                        if (td.classList && td.classList.contains('in-trash')) source = 'trash';
                    } catch (inner) { }
                    e.dataTransfer.setData('text/plain', String(parsed));
                    e.dataTransfer.setData('source', source);
                    e.dataTransfer.effectAllowed = 'move';
                    // track dragged number and whether it originated in the trash
                    draggingNumber = parsed;
                    if (source === 'trash') {
                        draggingFromTrash = parsed;
                    } else {
                        draggingFromTrash = null;
                    }
                    // store explicit source for dragend fallback handling
                    try { window.__lastDragSource = source; } catch (e) { }
                    // save origin cell element for short-distance trash detection
                    try { window.__dragOriginCell = td; } catch (e) { }
                } catch (err) { }
            }, true);

            // allow drops everywhere so we can detect drops outside popup and record pointer position
            document.addEventListener('dragover', (e) => {
                try {
                    lastDragClientX = e.clientX || lastDragClientX;
                    lastDragClientY = e.clientY || lastDragClientY;
                } catch (err) { }
                e.preventDefault();
            }, true);

            document.addEventListener('drop', (e) => {
                try {
                    e.preventDefault();
                    const data = e.dataTransfer.getData('text/plain');
                    const source = e.dataTransfer.getData('source');
                    // Handle label-col drops on fav/trash targets
                    if (source === 'label-col') {
                        const colNum = window.__draggingLabelCol;
                        if (!colNum) return;
                        const colNums = getColNumbers(colNum);
                        if (!colNums.length) return;
                        const dropOnFav = !!e.target.closest('#favPopup') || !!e.target.closest('#favBtn');
                        const dropOnTrash = !!e.target.closest('#trashPopup');
                        if (dropOnFav) {
                            // Toggle: if all in fav, remove all; otherwise add all
                            const allInFav = colNums.every(n => favItems.includes(n));
                            if (allInFav) {
                                for (const n of colNums) { try { removeFromFav(n); } catch (e) { } }
                            } else {
                                for (const n of colNums) { try { addToFav(n); } catch (e) { } }
                            }
                            try { updateLabelCellColStates(); } catch (e) { }
                            window.__labelColDropHandled = true;
                            return;
                        }
                        if (dropOnTrash && trashEnabled) {
                            // Toggle: if all in trash, restore all; otherwise trash all
                            const allInTrash = colNums.every(n => trashItems.includes(n));
                            if (allInTrash) {
                                for (const n of colNums) { try { restoreFromTrash(n); } catch (e) { } }
                            } else {
                                for (const n of colNums) { try { moveToTrash(n); } catch (e) { } }
                            }
                            try { updateLabelCellColStates(); } catch (e) { }
                            window.__labelColDropHandled = true;
                            return;
                        }
                        // Other drop targets for label-col are handled in dragend
                        return;
                    }
                    const num = parseInt(data);
                    if (!num) return;
                    const dropOnTrash = !!e.target.closest('#trashPopup');
                    const dropOnNumberTable = !!e.target.closest('#numberPickerTable');
                    const dropInsidePopup = !!e.target.closest('#numberPickerPopup');
                    // handle drops targeted at fav UI (fav button or fav popup)
                    // prefer the fav-specific handlers, but if they weren't attached
                    // (e.g. favBtn missing), fall back to calling `addToFav` directly
                    const dropOnFav = !!e.target.closest('#favPopup') || !!e.target.closest('#favBtn');
                    if (dropOnFav) {
                        try { if (typeof addToFav === 'function') { addToFav(num); return; } } catch (e) { }
                        return;
                    }

                    if (dropOnTrash) {
                        // allow dropping from popup or fav into trash
                        if (source === 'popup' || source === 'fav') moveToTrash(num);
                        // allow dropping an entire Cell6.5 Unpair row (multiple numbers)
                        if (source === 'cell6_5_unpair') {
                            try {
                                const raw = e.dataTransfer.getData('application/x-nums') || e.dataTransfer.getData('text/plain');
                                const arr = (raw && raw.trim().startsWith('[')) ? JSON.parse(raw) : String(raw || '').split(',').map(s => Number(s)).filter(n => Number.isFinite(n));
                                if (Array.isArray(arr) && arr.length) {
                                    for (const n of arr) try { moveToTrash(Number(n)); } catch (err) { }
                                }
                                try { if (window.__draggingUnpair) window.__draggingUnpair.handled = true; } catch (e) { }
                            } catch (err) { /* ignore JSON/parse errors */ }
                        }
                        return;
                    }

                    if (dropOnNumberTable) {
                        if (source === 'trash') {
                            // Require the drop point to be outside the original trashed-cell
                            // bounding rectangle before restoring. This avoids tiny pointer
                            // nudges inside the same red cell from triggering a restore.
                            try {
                                const originCell = numberPickerTable.querySelector('td[data-number="' + num + '"]');
                                const px = (e.clientX || lastDragClientX || 0);
                                const py = (e.clientY || lastDragClientY || 0);
                                let doRestore = true;
                                if (originCell) {
                                    const rect = originCell.getBoundingClientRect();
                                    const inside = (px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom);
                                    doRestore = !inside; // only restore when drop point is outside
                                }
                                if (doRestore) restoreFromTrash(num);
                            } catch (err) { try { restoreFromTrash(num); } catch (e) { } }
                        }
                        return;
                    }

                    // drop outside popup area:
                    // - if dragged FROM fav and dropped anywhere outside the fav popup, remove from fav
                    // - if dragged FROM trash and dropped anywhere outside the trash, restore it back to the popup
                    // - if dragged FROM popup and dropped outside its origin cell, treat as move-to-trash
                    if (!dropInsidePopup) {
                        // fav → outside favPopup: remove from fav (return to popup)
                        if (source === 'fav' && !dropOnFav) {
                            try { removeFromFav(num); } catch (err) { }
                            return;
                        }
                        if (source === 'trash') {
                            // When dropping outside the popup, only restore when the
                            // drop point is truly outside the original trashed cell.
                            try {
                                const originCell = numberPickerTable.querySelector('td[data-number="' + num + '"]');
                                const px = (e.clientX || lastDragClientX || 0);
                                const py = (e.clientY || lastDragClientY || 0);
                                let doRestore = true;
                                if (originCell) {
                                    const rect = originCell.getBoundingClientRect();
                                    const inside = (px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom);
                                    doRestore = !inside;
                                }
                                if (doRestore) {
                                    restoreFromTrash(num);
                                    return;
                                }
                            } catch (err) { try { restoreFromTrash(num); return; } catch (e) { } }
                        }
                        if (trashEnabled && source === 'popup') {
                            moveToTrash(num);
                            return;
                        }
                    }
                    // Drop inside popup but outside origin cell → also move to trash
                    if (dropInsidePopup && !dropOnTrash && !dropOnFav && trashEnabled && source === 'popup') {
                        try {
                            const originCell = window.__dragOriginCell || null;
                            const px = (e.clientX || lastDragClientX || 0);
                            const py = (e.clientY || lastDragClientY || 0);
                            let outsideOrigin = true;
                            if (originCell) {
                                const rect = originCell.getBoundingClientRect();
                                outsideOrigin = !(px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom);
                            }
                            if (outsideOrigin) {
                                moveToTrash(num);
                                return;
                            }
                        } catch (err) { }
                    }
                } catch (err) { }
            }, true);

            // dragend fallback: if user dragged from trash but didn't drop over a restore target,
            // restore the item when drag ends outside the trash popup (fixes intermittent "stuck" behavior)
            document.addEventListener('dragend', (e) => {
                try {
                    // Handle label-col drag end: move/restore entire column to/from trash
                    const labelSource = (window && window.__lastDragSource === 'label-col');
                    if (labelSource && window.__draggingLabelCol) {
                        const colNum = window.__draggingLabelCol;
                        const colNums = getColNumbers(colNum);
                        // Restore label cell opacity
                        try {
                            const originTh = window.__dragOriginCell;
                            if (originTh) originTh.style.opacity = '1';
                        } catch (e) { }
                        // If the drop handler already processed this (fav/trash target), skip
                        const alreadyHandled = !!window.__labelColDropHandled;
                        window.__labelColDropHandled = false;
                        if (!alreadyHandled) {
                            // Check if drag ended outside the label cell area
                            const x = lastDragClientX || e.clientX || 0;
                            const y = lastDragClientY || e.clientY || 0;
                            let outsideOrigin = true;
                            try {
                                const originCell = window.__dragOriginCell || null;
                                if (originCell) {
                                    const rect = originCell.getBoundingClientRect();
                                    outsideOrigin = !(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom);
                                }
                            } catch (e) { }
                            if (outsideOrigin && colNums.length && trashEnabled) {
                                // Check where drag ended
                                const x2 = lastDragClientX || e.clientX || 0;
                                const y2 = lastDragClientY || e.clientY || 0;
                                const el = document.elementFromPoint(x2, y2);
                                const endedOverFav = el && el.closest && el.closest('#favPopup, #favBtn');
                                const endedOverTrash = el && el.closest && el.closest('#trashPopup');
                                if (endedOverFav) {
                                    // Add all to fav
                                    const allInFav = colNums.every(n => favItems.includes(n));
                                    if (allInFav) {
                                        for (const n of colNums) { try { removeFromFav(n); } catch (e) { } }
                                    } else {
                                        for (const n of colNums) { try { addToFav(n); } catch (e) { } }
                                    }
                                } else if (endedOverTrash) {
                                    // Add all to trash
                                    const allInTrash = colNums.every(n => trashItems.includes(n));
                                    if (allInTrash) {
                                        for (const n of colNums) { try { restoreFromTrash(n); } catch (e) { } }
                                    } else {
                                        for (const n of colNums) { try { moveToTrash(n); } catch (e) { } }
                                    }
                                } else {
                                    // Dragged outside = trash (original behavior)
                                    const allInTrash = colNums.every(n => trashItems.includes(n));
                                    if (allInTrash) {
                                        for (const n of colNums) { try { restoreFromTrash(n); } catch (e) { } }
                                    } else {
                                        for (const n of colNums) { try { moveToTrash(n); } catch (e) { } }
                                    }
                                }
                                try { updateLabelCellColStates(); } catch (e) { }
                            }
                        }
                        // Clean up
                        window.__draggingLabelCol = null;
                        window.__lastDragSource = null;
                        window.__dragOriginCell = null;
                        draggingFromTrash = null;
                        return;
                    }
                    // If the drag started from the trash and didn't end over the trash,
                    // restore it — but only when the pointer ended outside the original
                    // trashed cell rectangle (prevents tiny pointer movements from toggling).
                    if (draggingFromTrash) {
                        // prefer last known dragover coords, fallback to dragend client coords
                        const x = lastDragClientX || e.clientX || 0;
                        const y = lastDragClientY || e.clientY || 0;
                        try {
                            const originCell = numberPickerTable.querySelector('td[data-number="' + draggingFromTrash + '"]');
                            let doRestore = true;
                            if (originCell) {
                                const rect = originCell.getBoundingClientRect();
                                const inside = (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom);
                                doRestore = !inside;
                            }
                            if (doRestore) restoreFromTrash(draggingFromTrash);
                        } catch (innerErr) {
                            try { restoreFromTrash(draggingFromTrash); } catch (e) { }
                        }
                    } else {
                        // Fallback: if the drag started from fav and ended outside favPopup,
                        // remove from fav so the number returns to the popup.
                        try {
                            const source = (window && window.__lastDragSource) ? window.__lastDragSource : null;
                            if (source === 'fav' && typeof draggingNumber !== 'undefined' && draggingNumber !== null && draggingNumber !== 0) {
                                const x = lastDragClientX || e.clientX || 0;
                                const y = lastDragClientY || e.clientY || 0;
                                const el = document.elementFromPoint(x, y);
                                const endedOverFav = el && el.closest && el.closest('#favPopup, #favBtn');
                                if (!endedOverFav) {
                                    try { removeFromFav(draggingNumber); } catch (err) { }
                                }
                            }
                        } catch (err) { }
                        // Fallback: if the drag started from the popup and ended outside the popup,
                        // treat it as move-to-trash to cover cases where a native `drop` event
                        // did not fire reliably on the target.
                        try {
                            const source = (window && window.__lastDragSource) ? window.__lastDragSource : null;
                            if (source === 'popup' && typeof draggingNumber !== 'undefined' && draggingNumber !== null && draggingNumber !== 0 && trashEnabled) {
                                const x = lastDragClientX || e.clientX || 0;
                                const y = lastDragClientY || e.clientY || 0;
                                const el = document.elementFromPoint(x, y);
                                const endedOverTrash = el && el.closest && el.closest('#trashPopup');
                                const endedOverFav = el && el.closest && el.closest('#favPopup, #favBtn');
                                // Check if drag ended outside the origin cell (short-distance trash)
                                let outsideOriginCell = true;
                                try {
                                    const originCell = window.__dragOriginCell || null;
                                    if (originCell) {
                                        const rect = originCell.getBoundingClientRect();
                                        outsideOriginCell = !(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom);
                                    }
                                } catch (err2) { }
                                // move to trash when drag ended outside origin cell and not over trash or fav
                                if (outsideOriginCell && !endedOverTrash && !endedOverFav) {
                                    try { moveToTrash(draggingNumber); } catch (err) { }
                                }
                            }
                        } catch (err) { }
                    }
                } catch (err) { }
                draggingFromTrash = null;
                try { window.__lastDragSource = null; } catch (e) { }
                try { window.__dragOriginCell = null; } catch (e) { }
            }, true);

            // When popup content regenerates, ensure positioning updates
            const mo = new MutationObserver(() => { adjustTrashPosition(); });
            mo.observe(numberPickerTable, { childList: true, subtree: true });
            window.addEventListener('resize', adjustTrashPosition);
            window.addEventListener('scroll', adjustTrashPosition, true);

            // initial state
            setTrashButtonState();
            renderTrash();
            try { updateFavBadge(); } catch (e) { }

            // helper: get unique numbers present in the popup table
            function getPopupNumbers() {
                try {
                    const nodes = Array.from(numberPickerTable.querySelectorAll('td[data-number]'));
                    const nums = nodes.map(n => Number(n.dataset.number)).filter(n => Number.isInteger(n) && n >= 1 && n <= 45);
                    return Array.from(new Set(nums)).sort((a, b) => a - b);
                } catch (e) { return []; }
            }

            // Inject a small draggable restore handle into any popup cell marked `.in-trash`.
            // The handle has pointer-events enabled and starts a drag with source='trash'
            // so users can drag the red cell area to restore it even when the main
            // cell contents are hidden/disabled.
            function ensureRestoreHandles() {
                try {
                    if (!numberPickerTable) return;
                    // add handles for current in-trash cells
                    const tds = Array.from(numberPickerTable.querySelectorAll('td.in-trash'));
                    for (const td of tds) {
                        try {
                            if (td.querySelector && td.querySelector('.restore-handle')) continue;
                            const handle = document.createElement('span');
                            handle.className = 'restore-handle';
                            handle.setAttribute('title', 'Kéo để khôi phục');
                            // make the handle cover the entire cell (transparent overlay)
                            handle.textContent = '';
                            Object.assign(handle.style, {
                                position: 'absolute',
                                left: '0',
                                top: '0',
                                right: '0',
                                bottom: '0',
                                width: '100%',
                                height: '100%',
                                display: 'block',
                                background: 'transparent',
                                color: 'transparent',
                                borderRadius: 'inherit',
                                cursor: 'grab',
                                zIndex: 999999,
                                pointerEvents: 'auto',
                                userSelect: 'none',
                                visibility: 'visible',
                                opacity: '1',
                                touchAction: 'none'
                            });
                            handle.draggable = true;
                            // Ensure visibility/pointer-events override any global hiding rules
                            try {
                                handle.style.setProperty('visibility', 'visible', 'important');
                                handle.style.setProperty('pointer-events', 'auto', 'important');
                                handle.style.setProperty('opacity', '1', 'important');
                                handle.style.setProperty('left', '0', 'important');
                                handle.style.setProperty('top', '0', 'important');
                                handle.style.setProperty('right', '0', 'important');
                                handle.style.setProperty('bottom', '0', 'important');
                                handle.style.setProperty('width', '100%', 'important');
                                handle.style.setProperty('height', '100%', 'important');
                                handle.style.zIndex = '999999';
                            } catch (e) { }
                            handle.addEventListener('dragstart', (e) => {
                                try {
                                    const num = td.dataset && td.dataset.number ? td.dataset.number : (td.textContent || '').trim();
                                    const parsed = parseInt(num);
                                    if (!parsed) return;
                                    e.dataTransfer.setData('text/plain', String(parsed));
                                    e.dataTransfer.setData('source', 'trash');
                                    e.dataTransfer.effectAllowed = 'move';
                                    draggingNumber = parsed;
                                    draggingFromTrash = parsed;
                                    try { window.__lastDragSource = 'trash'; } catch (e) { }
                                    // save origin cell for short-distance restore check
                                    try { window.__dragOriginCell = td; } catch (e) { }
                                } catch (ee) { }
                            }, true);
                            // block click on restore-handle — restore only via drag outside cell
                            handle.addEventListener('click', (ev) => {
                                try { ev.stopPropagation(); ev.preventDefault(); } catch (e) { }
                            }, true);
                            td.appendChild(handle);
                        } catch (e) { }
                    }
                    // remove orphan handles from non-in-trash cells
                    try {
                        const orphans = Array.from(numberPickerTable.querySelectorAll('span.restore-handle'));
                        for (const h of orphans) {
                            const p = h.parentElement;
                            if (!p || !p.classList.contains('in-trash')) try { h.remove(); } catch (e) { }
                        }
                    } catch (e) { }
                } catch (e) { }
            }

            // keep handles in sync with popup DOM changes
            try {
                const moHandles = new MutationObserver(() => { try { ensureRestoreHandles(); } catch (e) { } });
                if (numberPickerTable) moHandles.observe(numberPickerTable, { childList: true, subtree: true, attributes: true });
            } catch (e) { }

            // Helper: toggle dragged-out class for all unpair rows matching a stable key
            function toggleDraggedOutForKey(key, add) {
                try {
                    if (!key) return;
                    // find any rows in the document that look like unpair rows (two columns: num and dontmatch)
                    const candidates = Array.from(document.querySelectorAll('#cell6_5 table tbody tr'));
                    for (const r of candidates) {
                        try {
                            const dont = r.children && r.children[1] ? (r.children[1].textContent || '').trim() : '';
                            const nums = dont ? dont.split(',').map(s => Number(s.trim())).filter(Number.isFinite) : [];
                            const k = Array.from(new Set(nums)).sort((a, b) => a - b).join(',');
                            if (!k) continue;
                            if (k === key) {
                                if (add) r.classList.add('dragged-out'); else r.classList.remove('dragged-out');
                            }
                        } catch (e) { }
                    }
                } catch (e) { }
            }

            // compute best k-number removal (exact when combos small, greedy otherwise)
            function computeBestRemoval(k) {
                k = Number(k) || 0; if (k < 1) return null;
                const filtered = rows.slice();
                const total = filtered.length;
                if (!total) return { total: 0, remaining: 0, pages: 0, chosen: [], excludedCount: 0 };

                // build number -> set(rowIndex)
                const pool = getPopupNumbers();
                const poolSet = new Set(pool);
                const numToRows = new Map();
                filtered.forEach((r, idx) => {
                    const nums = r.nums || [];
                    for (let t = 0; t < nums.length; t++) {
                        const v = Number(nums[t]);
                        if (!poolSet.has(v)) continue;
                        if (!numToRows.has(v)) numToRows.set(v, new Set());
                        numToRows.get(v).add(idx);
                    }
                });

                if (pool.length <= k) {
                    const union = new Set();
                    pool.forEach(p => { const s = numToRows.get(p); if (s) for (const i of s) union.add(i); });
                    const excluded = union.size;
                    return { total, remaining: total - excluded, pages: Math.ceil((total - excluded) / 20), chosen: pool.slice(), excludedCount: excluded };
                }

                const comb = (n, r) => { if (r > n) return 0; let res = 1; for (let i = 1; i <= r; i++) { res = res * (n - (r - i)) / i; } return Math.round(res); };
                const combos = comb(pool.length, k);
                const MAX_EXACT = 200000;
                let best = { remaining: -1, chosen: [], excludedCount: 0 };

                if (combos <= MAX_EXACT) {
                    // exact backtrack
                    const idxPool = pool;
                    const stack = [];
                    function backtrack(start) {
                        if (stack.length === k) {
                            const union = new Set();
                            for (const p of stack) {
                                const s = numToRows.get(p);
                                if (s) for (const i of s) union.add(i);
                            }
                            const excluded = union.size; const remaining = total - excluded;
                            if (remaining > best.remaining) best = { remaining, chosen: stack.slice(), excludedCount: excluded };
                            return;
                        }
                        for (let i = start; i < idxPool.length; i++) { stack.push(idxPool[i]); backtrack(i + 1); stack.pop(); }
                    }
                    backtrack(0);
                } else {
                    // greedy approximate: pick candidates that cover fewest new rows
                    const available = new Set(pool);
                    const chosen = [];
                    const excludedSet = new Set();
                    for (let step = 0; step < k; step++) {
                        let bestChoice = null, bestMarginal = Infinity;
                        for (const candidate of Array.from(available)) {
                            const s = numToRows.get(candidate);
                            if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                            let marginal = 0; for (const idx of s) if (!excludedSet.has(idx)) marginal++;
                            if (marginal < bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                        }
                        if (bestChoice === null) break;
                        const s2 = numToRows.get(bestChoice); if (s2) for (const i of s2) excludedSet.add(i);
                        chosen.push(bestChoice); available.delete(bestChoice);
                    }
                    best = { remaining: total - excludedSet.size, chosen, excludedCount: excludedSet.size };
                }

                return { total, remaining: best.remaining, pages: Math.ceil(best.remaining / 20), chosen: best.chosen, excludedCount: best.excludedCount };
            }

            // compute best N numbers to ADD to fav (maximize distinct periods matched)
            function computeBestFav(n) {
                n = Number(n) || 0; if (n < 1) return null;
                const filtered = rows.slice();
                const total = filtered.length;
                if (!total) return { total: 0, included: 0, pages: 0, chosen: [], includedCount: 0 };

                // build number -> set(rowIndex)
                const pool = getPopupNumbers();
                const poolSet = new Set(pool);
                const numToRows = new Map();
                filtered.forEach((r, idx) => {
                    const nums = r.nums || [];
                    for (let t = 0; t < nums.length; t++) {
                        const v = Number(nums[t]);
                        if (!poolSet.has(v)) continue;
                        if (!numToRows.has(v)) numToRows.set(v, new Set());
                        numToRows.get(v).add(idx);
                    }
                });

                if (pool.length <= n) {
                    const union = new Set();
                    pool.forEach(p => { const s = numToRows.get(p); if (s) for (const i of s) union.add(i); });
                    const included = union.size;
                    return { total, included, pages: Math.ceil(included / 20), chosen: pool.slice(), includedCount: included };
                }

                const comb = (N, r) => { if (r > N) return 0; let res = 1; for (let i = 1; i <= r; i++) { res = res * (N - (r - i)) / i; } return Math.round(res); };
                const combos = comb(pool.length, n);
                const MAX_EXACT = 200000;
                let best = { included: -1, chosen: [], includedCount: 0 };

                if (combos <= MAX_EXACT) {
                    // exact backtrack (maximize union size)
                    const idxPool = pool;
                    const stack = [];
                    function backtrack(start) {
                        if (stack.length === n) {
                            const union = new Set();
                            for (const p of stack) {
                                const s = numToRows.get(p);
                                if (s) for (const i of s) union.add(i);
                            }
                            const included = union.size;
                            if (included > best.included) best = { included, chosen: stack.slice(), includedCount: included };
                            return;
                        }
                        for (let i = start; i < idxPool.length; i++) { stack.push(idxPool[i]); backtrack(i + 1); stack.pop(); }
                    }
                    backtrack(0);
                } else {
                    // greedy approximate: pick candidates that cover most new rows
                    const available = new Set(pool);
                    const chosen = [];
                    const includedSet = new Set();
                    for (let step = 0; step < n; step++) {
                        let bestChoice = null, bestMarginal = -Infinity;
                        for (const candidate of Array.from(available)) {
                            const s = numToRows.get(candidate);
                            if (!s || s.size === 0) { bestChoice = candidate; bestMarginal = 0; break; }
                            let marginal = 0; for (const idx of s) if (!includedSet.has(idx)) marginal++;
                            if (marginal > bestMarginal) { bestMarginal = marginal; bestChoice = candidate; }
                        }
                        if (bestChoice === null) break;
                        const s2 = numToRows.get(bestChoice); if (s2) for (const i of s2) includedSet.add(i);
                        chosen.push(bestChoice); available.delete(bestChoice);
                    }
                    best = { included: includedSet.size, chosen, includedCount: includedSet.size };
                }

                return { total, included: best.included, pages: Math.ceil(best.included / 20), chosen: best.chosen, includedCount: best.includedCount };
            }

            // wire input: when user enters k and presses Enter or blurs, compute and move chosen numbers to trash
            (function wireTrashInput() {
                try {
                    const kInput = trashPopup.querySelector('#trashKInput');
                    if (!kInput) return;
                    const doComputeAndMove = async () => {
                        let k = parseInt(kInput.value, 10);
                        if (!Number.isInteger(k) || k < 1) { k = 1; kInput.value = '1'; }
                        if (k > 39) { k = 39; kInput.value = '39'; }
                        // compute
                        const res = computeBestRemoval(k);
                        // clear existing trash items first (replace behavior)
                        try {
                            if (trashItems && trashItems.length) {
                                // remove in-trash class from popup cells
                                try {
                                    for (const old of trashItems.slice()) {
                                        const c = numberPickerTable.querySelector('td[data-number="' + old + '"]');
                                        if (c) c.classList.remove('in-trash');
                                    }
                                } catch (e) { }
                                trashItems.length = 0;
                                renderTrash();
                                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                            }
                        } catch (e) { }
                        if (res && Array.isArray(res.chosen) && res.chosen.length) {
                            for (const n of res.chosen) {
                                try { moveToTrash(n); } catch (e) { }
                            }
                        }
                    };
                    kInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { ev.preventDefault(); doComputeAndMove(); } });
                    kInput.addEventListener('change', () => { doComputeAndMove(); });

                    // wire spinner buttons: wrap between 1 and 39 and trigger change
                    try {
                        const up = trashPopup.querySelector('.trash-k-up');
                        const down = trashPopup.querySelector('.trash-k-down');
                        const MIN_K = 1, MAX_K = 39;
                        if (up) up.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(kInput.value, 10);
                            if (!Number.isInteger(v)) v = 0; // default to 0 when empty
                            v = v + 1;
                            if (v > MAX_K) v = MIN_K; // wrap
                            kInput.value = String(v);
                            try { doComputeAndMove(); } catch (e) { kInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        });
                        if (down) down.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            let v = parseInt(kInput.value, 10);
                            if (!Number.isInteger(v)) v = 0; // default to 0 when empty
                            v = v - 1;
                            if (v < MIN_K) v = MAX_K; // wrap
                            kInput.value = String(v);
                            try { doComputeAndMove(); } catch (e) { kInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        });
                    } catch (err) { /* ignore spinner wiring errors */ }
                } catch (e) { }
            })();
            // double-click on trash popup: read clipboard and append valid numbers (tolerant parser)
            trashPopup.addEventListener('dblclick', async (ev) => {
                try {
                    if (!trashEnabled) return;
                    // Ignore dblclicks that originate from UI controls (buttons/inputs/selects)
                    // This prevents spinner clicks or other control interactions from
                    // accidentally triggering the paste/clipboard prompt.
                    try {
                        if (ev.target && (ev.target.closest('button') || ev.target.closest('input') || ev.target.closest('select'))) return;
                    } catch (ee) { }

                    const processText = (text) => {
                        if (!text) return;
                        const parts = String(text).split(/[^0-9]+/).filter(Boolean);
                        if (parts.length === 0) return;
                        const nums = parts.map(s => parseInt(s, 10)).filter(n => Number.isInteger(n) && n >= 1 && n <= 45);
                        if (nums.length === 0) return;
                        const unique = Array.from(new Set(nums));
                        for (const n of unique) {
                            try { moveToTrash(n); } catch (e) { }
                        }
                    };

                    // try modern clipboard API first
                    let text = '';
                    let clipboardTried = false;
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            clipboardTried = true;
                            text = await navigator.clipboard.readText();
                        }
                    } catch (err) { clipboardTried = true; text = ''; }

                    if (text) {
                        processText(text);
                        return;
                    }

                    // If clipboard read failed or empty, show a visible paste UI so user can paste (or retry clipboard)
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.zIndex = 10002;
                    overlay.style.left = '50%';
                    overlay.style.top = '50%';
                    overlay.style.transform = 'translate(-50%,-50%)';
                    overlay.style.background = 'white';
                    overlay.style.border = '2px solid #888';
                    overlay.style.padding = '10px';
                    overlay.style.borderRadius = '8px';
                    overlay.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
                    overlay.setAttribute('role', 'dialog');

                    const msg = document.createElement('div');
                    msg.style.marginBottom = '8px';
                    msg.style.color = '#111';
                    msg.textContent = 'Paste numbers here (e.g. 1,2,3) or click "Use clipboard"';
                    const ta = document.createElement('textarea');
                    ta.style.width = '320px';
                    ta.style.height = '80px';
                    ta.style.fontSize = '14px';
                    ta.style.padding = '6px';
                    ta.placeholder = 'Paste (Ctrl+V) or type numbers then press Ctrl+Enter';

                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.marginTop = '8px';

                    const useBtn = document.createElement('button');
                    useBtn.textContent = 'Use clipboard';
                    useBtn.className = 'ghost';
                    const submitBtn = document.createElement('button');
                    submitBtn.textContent = 'Submit';
                    submitBtn.className = 'primary';
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.className = 'clear-btn';

                    row.appendChild(useBtn);
                    row.appendChild(submitBtn);
                    row.appendChild(cancelBtn);

                    overlay.appendChild(msg);
                    overlay.appendChild(ta);
                    overlay.appendChild(row);
                    document.body.appendChild(overlay);
                    ta.focus();

                    let resolved = false;
                    const clean = (v) => {
                        if (resolved) return; resolved = true;
                        try { overlay.remove(); } catch (e) { }
                        if (v) processText(v);
                    };

                    useBtn.addEventListener('click', async () => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                const t = await navigator.clipboard.readText();
                                if (t) { clean(t); return; }
                                alert('Clipboard is empty or not available. Please paste manually.');
                            } else {
                                alert('Clipboard API not available. Please paste manually.');
                            }
                        } catch (e) { alert('Cannot read clipboard. Please paste manually.'); }
                    });

                    submitBtn.addEventListener('click', () => { clean(ta.value || ''); });
                    cancelBtn.addEventListener('click', () => { clean(''); });

                    ta.addEventListener('paste', (e) => {
                        try {
                            e.preventDefault();
                            const d = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : null;
                            if (d) clean(String(d));
                            else setTimeout(() => clean(ta.value || ''), 50);
                        } catch (err) { clean(''); }
                    }, { once: true });

                    ta.addEventListener('keydown', (e) => {
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            clean(ta.value || '');
                        }
                    });

                    // auto-remove after 12s if user doesn't act
                    setTimeout(() => { clean(''); }, 12000);
                } catch (err) { /* ignore overall */ }
            });
            // Clear-all button inside trash popup: remove all tracked trash items and update visuals
            try {
                const clearBtn = trashPopup.querySelector('#trashClearBtn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', (ev) => {
                        try {
                            ev.preventDefault();
                        } catch (e) { }
                        try { window.__trashClearing = true; } catch (e) { }
                        try {
                            // clear popup-tracked array if present and sync to closure variable
                            try {
                                if (Array.isArray(window.__trashItems)) window.__trashItems.length = 0;
                            } catch (e) { /* ignore */ }
                            try { window.__trashItems = window.__trashItems || []; } catch (e) { }
                        } catch (e) { }
                        try {
                            // clear local tracked array and remove in-trash classes
                            try {
                                for (const old of (trashItems || []).slice()) {
                                    try {
                                        const c = numberPickerTable.querySelector('td[data-number="' + old + '"]');
                                        if (c) c.classList.remove('in-trash');
                                    } catch (ee) { }
                                }
                            } catch (ee) { }
                            // empty the array and ensure global reference points to same array
                            try { trashItems.length = 0; } catch (ee) { }
                            try { window.__trashItems = trashItems; } catch (ee) { }
                        } catch (e) { }
                        try { renderTrash(); } catch (e) { }
                        try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
                        try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashchange', { bubbles: true, composed: true })); } catch (e) { }
                        try { if (typeof updateTrashBadge === 'function') updateTrashBadge(); } catch (e) { }
                        // Ensure popup visuals fully reflect cleared state:
                        try {
                            // remove any displayed avg-k span
                            const tp = document.getElementById('trashPopup');
                            if (tp) {
                                try {
                                    const firstDiv = tp.querySelector('div');
                                    if (firstDiv) {
                                        const existing = firstDiv.querySelector('.avg-k');
                                        if (existing) existing.remove();
                                    }
                                    // clear any trash-number cells inside the popup table and strip draggable
                                    const trows = tp.querySelectorAll('td.trash-number');
                                    for (const td of Array.from(trows)) {
                                        try { td.draggable = false; td.removeAttribute('draggable'); } catch (er) { }
                                        try { td.remove(); } catch (er) { try { td.innerHTML = ''; } catch (ee) { } }
                                    }
                                    // also clear tbody to remove any lingering rows
                                    try {
                                        const tb = tp.querySelector('tbody');
                                        if (tb) {
                                            tb.innerHTML = '';
                                            const pr = document.createElement('tr');
                                            for (let i = 0; i < 3; i++) { const e = document.createElement('td'); e.innerHTML = ''; pr.appendChild(e); }
                                            tb.appendChild(pr);
                                        }
                                    } catch (er) { }
                                } catch (err) { }
                            }
                            // also clear in-trash markers inside the number picker popup cells
                            try {
                                const picker = document.getElementById('numberPickerTable');
                                if (picker) {
                                    const marked = picker.querySelectorAll('td.in-trash');
                                    for (const m of Array.from(marked)) try { m.classList.remove('in-trash'); } catch (er) { }
                                }
                                // ensure number cells remain draggable after clearing trash
                                try {
                                    const numberCells = picker.querySelectorAll('td[data-number]');
                                    for (const c of Array.from(numberCells)) {
                                        try { c.draggable = true; c.setAttribute('draggable', 'true'); } catch (er) { }
                                    }
                                } catch (er) { }
                            } catch (err) { }
                            // re-render the trash popup to reflect now-empty state
                            try { renderTrash(); } catch (err) { }
                        } catch (e) { }
                        // If Cell6.5 optimizer is active, uncheck it when user clears trash
                        try {
                            const opt = document.getElementById('cell6_5_optimize');
                            const optMode = document.getElementById('cell6_5_optMode');
                            if (opt && opt.checked) {
                                opt.checked = false;
                                try { opt.dispatchEvent(new Event('change', { bubbles: true })); } catch (er) { try { opt.dispatchEvent(new Event('change')); } catch (ee) { } }
                            }
                            if (optMode) optMode.disabled = true;
                        } catch (e) { }
                        // Schedule a short re-check to ensure no other listener repopulated the popup
                        try {
                            setTimeout(() => {
                                try { if (Array.isArray(window.__trashItems)) window.__trashItems.length = 0; } catch (e) { }
                                try { if (Array.isArray(trashItems)) trashItems.length = 0; } catch (e) { }
                                try {
                                    const tp2 = document.getElementById('trashPopup');
                                    if (tp2) {
                                        const tb2 = tp2.querySelector('tbody');
                                        if (tb2) tb2.innerHTML = '';
                                    }
                                } catch (e) { }
                                try { renderTrash(); } catch (e) { }
                                try { if (typeof updateTrashBadge === 'function') updateTrashBadge(); } catch (e) { }
                                try { window.__trashClearing = false; } catch (e) { }
                            }, 60);
                        } catch (e) { }
                    });
                }
            } catch (e) { }
            // expose current trash items via a safe global getter for other sections (Cell5.5 uses this)
            try { window.getTrashItems = function () { return trashItems.slice(); }; window.__trashItems = trashItems; } catch (e) { /* ignore */ }
            // expose addToFav / removeFromFav globally so renderCell6_5 (computeAndApplyUnpairBest) can use them
            try { window.addToFav = addToFav; window.removeFromFav = removeFromFav; } catch (e) { }
            // expose current fav items via a safe global getter for other sections
            try { window.getFavItems = function () { return favItems.slice(); }; } catch (e) { }

            // expose a clearAllTrash function so cross-scope code can reliably
            // clear the trashItems array and re-render the trash popup.
            function clearAllTrash() {
                try { numberPickerTable.querySelectorAll('td.in-trash').forEach(c => { c.classList.remove('in-trash'); c.classList.remove('in-trash-dim'); }); } catch (e) { }
                trashItems.length = 0;
                try { renderTrash(); } catch (e) { }
                try { updateTrashBadge(); } catch (e) { }
                try { (trashPopup || document.body).dispatchEvent(new CustomEvent('trashupdated', { bubbles: true, composed: true })); } catch (e) { }
            }
            try { window.clearAllTrash = clearAllTrash; } catch (e) { }

            // Shift-key toggle: when the main number picker popup is open, pressing
            // and releasing the Shift key will toggle the visibility of the trash popup.
            // Only active when trash is enabled and when the picker popup is visible.
            function isPickerOpen() {
                try {
                    if (!numberPickerPopup) return false;
                    if (numberPickerPopup.classList && numberPickerPopup.classList.contains('show')) return true;
                    if (numberPickerPopup.style && numberPickerPopup.style.display === 'block') return true;
                    return getComputedStyle(numberPickerPopup).display !== 'none';
                } catch (e) { return false; }
            }

            function onShiftKeyUp(e) {
                try {
                    // Toggle trash on Shift release
                    if (e.key === 'Shift') {
                        // Skip if Ctrl+Shift section-toggle was just used
                        if (window.__ctrlShiftJustUsed) { window.__ctrlShiftJustUsed = false; return; }
                        // Skip if a Shift+click was performed (avoid toggling trash after Shift+click actions)
                        if (window.__shiftClickJustUsed) { window.__shiftClickJustUsed = false; return; }
                        if (!isPickerOpen()) return; // only when main popup is open
                        if (!trashEnabled) return; // respect trash enabled state
                        // toggle
                        const wasVisible = trashPopup.style.display === 'block';
                        const nowVisible = wasVisible ? 'none' : 'block';
                        trashPopup.style.display = nowVisible;
                        if (nowVisible === 'block') adjustTrashPosition();

                        // If we just closed the trash popup, copy trashed numbers to clipboard
                        if (nowVisible === 'none') {
                            try {
                                // Read from popup DOM so temporary hover-preview numbers are included
                                let nums = [];
                                try {
                                    const tds = trashPopup.querySelectorAll('td[data-number]');
                                    tds.forEach(td => { const v = Number(td.dataset.number); if (Number.isFinite(v) && v > 0) nums.push(v); });
                                } catch (e) { nums = Array.isArray(trashItems) ? trashItems.slice() : []; }
                                if (!nums.length) nums = Array.isArray(trashItems) ? trashItems.slice() : [];
                                const csv = nums.join(',');
                                if (csv.length > 0) {
                                    if (navigator.clipboard && navigator.clipboard.writeText) {
                                        navigator.clipboard.writeText(csv).catch(() => {
                                            const ta = document.createElement('textarea');
                                            ta.value = csv;
                                            document.body.appendChild(ta);
                                            ta.select();
                                            try { document.execCommand('copy'); } catch (e) { }
                                            ta.remove();
                                        });
                                    } else {
                                        const ta = document.createElement('textarea');
                                        ta.value = csv;
                                        document.body.appendChild(ta);
                                        ta.select();
                                        try { document.execCommand('copy'); } catch (e) { }
                                        ta.remove();
                                    }
                                }
                            } catch (copyErr) { /* ignore clipboard errors */ }
                        }
                        return;
                    }

                    // Toggle fav on Alt release (mirror Shift->trash behavior)
                    else if (e.key === 'Alt') {
                        try {
                            try { e.preventDefault(); } catch (pe) { }
                            if (!isPickerOpen()) return; // only when main popup is open
                            const wasFavVisible = favPopup.style.display === 'block';
                            const nowFavVisible = wasFavVisible ? 'none' : 'block';
                            favPopup.style.display = nowFavVisible;
                            try { window.__prevFavVisible = nowFavVisible === 'block'; } catch (e) { }
                            if (nowFavVisible === 'block') try { adjustFavPosition(); } catch (ee) { }

                            // If we just closed the fav popup, copy fav numbers to clipboard
                            if (nowFavVisible === 'none') {
                                try {
                                    // Read from popup DOM so temporary hover-preview numbers are included
                                    let nums = [];
                                    try {
                                        const tds = favPopup.querySelectorAll('td[data-number]');
                                        tds.forEach(td => { const v = Number(td.dataset.number); if (Number.isFinite(v) && v > 0) nums.push(v); });
                                    } catch (e) { nums = Array.isArray(favItems) ? favItems.slice() : []; }
                                    if (!nums.length) nums = Array.isArray(favItems) ? favItems.slice() : [];
                                    const csv = nums.join(',');
                                    if (csv.length > 0) {
                                        if (navigator.clipboard && navigator.clipboard.writeText) {
                                            navigator.clipboard.writeText(csv).catch(() => {
                                                const ta = document.createElement('textarea');
                                                ta.value = csv;
                                                document.body.appendChild(ta);
                                                ta.select();
                                                try { document.execCommand('copy'); } catch (e) { }
                                                ta.remove();
                                            });
                                        } else {
                                            const ta = document.createElement('textarea');
                                            ta.value = csv;
                                            document.body.appendChild(ta);
                                            ta.select();
                                            try { document.execCommand('copy'); } catch (e) { }
                                            ta.remove();
                                        }
                                    }
                                } catch (copyErr) { /* ignore clipboard errors */ }
                            }
                        } catch (favErr) { /* ignore fav toggle errors */ }
                    } else return;
                } catch (err) { /* ignore */ }
            }
            window.addEventListener('keyup', onShiftKeyUp, true);
            // Prevent Chrome's Alt menu from opening while our number-picker
            // is active by intercepting the Alt key on keydown (capture phase).
            window.addEventListener('keydown', function (e) {
                try {
                    if ((e.key === 'Alt' || e.key === 'AltGraph') && isPickerOpen()) {
                        try { e.preventDefault(); } catch (pe) { }
                        try { e.stopImmediatePropagation(); } catch (se) { }
                        return;
                    }
                } catch (err) { /* ignore */ }
            }, true);
        })();
    </script>
    </script>
    <script>
        // Keyboard helper: in Cell6.5 unpair mode, let `w` / `s` adjust the numtrash value
        (function () {
            document.addEventListener('keydown', (e) => {
                try {
                    const key = (e.key || '').toLowerCase();
                    if (key !== 'w' && key !== 's') return;
                    const active = document.activeElement;
                    if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
                    const controls = document.querySelector('#cell6_5 .controls.unpair-mode');
                    if (!controls) return; // only when cell6_5 is in unpair-mode
                    const upBtn = document.getElementById('cell6_5_numtrash_up');
                    const downBtn = document.getElementById('cell6_5_numtrash_down');
                    if (key === 'w') {
                        if (upBtn) { upBtn.click(); e.preventDefault(); }
                    } else if (key === 's') {
                        if (downBtn) { downBtn.click(); e.preventDefault(); }
                    }
                } catch (err) { /* ignore errors */ }
            }, true);
        })();
    </script>
    <!-- Instant floating tooltip for Cell5.5 / Cell6.5 / Cell6.6 rows: appears immediately and follows the cursor -->
    <script>
        (function () {
            const tooltip = document.createElement('div');
            tooltip.id = 'instantTooltip';
            tooltip.style.cssText = 'position:fixed;pointer-events:none;padding:6px 8px;background:rgba(0,0,0,0.85);color:#fff;border-radius:6px;font-size:13px;z-index:99999;display:none;white-space:nowrap;';
            document.body.appendChild(tooltip);

            let activeTr = null;
            let moveHandler = null;

            function positionClient(e) {
                const pad = 12;
                const w = tooltip.offsetWidth || 80;
                const h = tooltip.offsetHeight || 20;
                let x = e.clientX + 12;
                let y = e.clientY + 12;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                if (x + w + pad > vw) x = Math.max(8, e.clientX - w - 12);
                if (y + h + pad > vh) y = Math.max(8, e.clientY - h - 12);
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function showTooltipFor(e, tr) {
                if (!tr) return;
                activeTr = tr;
                // strip native title to avoid browser delay
                if (tr.getAttribute('title')) {
                    tr.dataset._origTitle = tr.getAttribute('title');
                    tr.removeAttribute('title');
                }
                const k = tr.getAttribute('data-k') || tr.dataset.k;
                tooltip.textContent = k ? `k=${k}` : (tr.dataset._origTitle || '');
                tooltip.style.display = 'block';
                positionClient(e);
                if (!moveHandler) {
                    moveHandler = (ev) => { if (activeTr) positionClient(ev); };
                    document.addEventListener('mousemove', moveHandler);
                }
            }

            function hideTooltip() {
                tooltip.style.display = 'none';
                activeTr = null;
                if (moveHandler) { document.removeEventListener('mousemove', moveHandler); moveHandler = null; }
            }

            // Delegated mouseover / mouseout to detect rows with data-k in the three cells
            document.addEventListener('mouseover', function (ev) {
                try {
                    const tr = ev.target && ev.target.closest && ev.target.closest('tr[data-result][data-k]');
                    if (!tr) return;
                    const container = tr.closest && tr.closest('#cell5_5, #cell6_5, #cell6_6, #cell7, #cell8, #cell9, #cell11');
                    if (container) showTooltipFor(ev, tr);
                } catch (e) {/* ignore */ }
            }, true);

            document.addEventListener('mouseout', function (ev) {
                try {
                    const tr = ev.target && ev.target.closest && ev.target.closest('tr[data-result][data-k]');
                    if (!tr) return;
                    const related = ev.relatedTarget;
                    if (related && tr.contains && tr.contains(related)) return;
                    const container = tr.closest && tr.closest('#cell5_5, #cell6_5, #cell6_6, #cell7, #cell8, #cell9, #cell11');
                    if (container) hideTooltip();
                } catch (e) {/* ignore */ }
            }, true);

            // Hide on scroll/blur to avoid stuck tooltip
            document.addEventListener('scroll', hideTooltip, true);
            window.addEventListener('blur', hideTooltip);

            // Strip native title attributes for existing and newly-added rows in the three containers
            const containers = ['cell5_5', 'cell6_5', 'cell6_6', 'cell7', 'cell8', 'cell9', 'cell11'].map(id => document.getElementById(id)).filter(Boolean);
            for (const c of containers) {
                try { c.querySelectorAll && c.querySelectorAll('tr[title]').forEach(el => { el.dataset._origTitle = el.getAttribute('title'); el.removeAttribute('title'); }); } catch (e) { }
                const mo = new MutationObserver(records => {
                    for (const r of records) {
                        r.addedNodes && r.addedNodes.forEach(node => {
                            try {
                                if (node.querySelectorAll) node.querySelectorAll('tr[title]').forEach(el => { el.dataset._origTitle = el.getAttribute('title'); el.removeAttribute('title'); });
                                if (node.matches && node.matches('tr[title]')) { node.dataset._origTitle = node.getAttribute('title'); node.removeAttribute('title'); }
                            } catch (e) {/* ignore */ }
                        });
                    }
                });
                mo.observe(c, { childList: true, subtree: true });
            }
        })();
    </script>
    <script>
        // Intercept drops on fav UI and prevent global trash-move fallback.
        (function () {
            window.__favDropHandled = false;

            // If a drop lands on the fav button or fav popup, swallow it early
            // so existing global handlers won't also treat it as a trash-drop.
            document.addEventListener('drop', function (e) {
                try {
                    const el = e.target && e.target.closest ? e.target.closest('#favPopup, #favBtn') : null;
                    if (el) {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        // mark that we handled a fav drop so dragend fallback won't run
                        window.__favDropHandled = true;
                        // clear soon after to avoid affecting unrelated drags
                        setTimeout(() => window.__favDropHandled = false, 100);
                        // Actually add the dropped number to fav (the favPopup's own
                        // handler won't fire because we stopped propagation above)
                        try {
                            const n = Number(e.dataTransfer.getData('text/plain'));
                            if (Number.isFinite(n) && n >= 1 && n <= 45 && typeof window.addToFav === 'function') {
                                window.addToFav(n);
                            }
                        } catch (ex) { }
                    }
                } catch (err) { /* ignore */ }
            }, true);

            // Prevent dragend-based fallback from moving items to trash if the
            // last drop was handled by the fav UI.
            document.addEventListener('dragend', function (e) {
                try {
                    if (window.__favDropHandled) {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        window.__favDropHandled = false;
                    }
                } catch (err) { /* ignore */ }
            }, true);
        })();
    </script>

    <!-- Auto: Shift+click -> open cell6_5 and set unpair mode + paste numbers -->
    <script>
        (function () {
            document.addEventListener('click', function (ev) {
                try {
                    if (!ev.shiftKey) return; // only on Shift+click
                    const tr = ev.target.closest('tr');
                    if (!tr) return;

                    // Try to obtain a 6-number string from common locations
                    let result = tr.getAttribute('data-result') || tr.dataset.result || '';
                    if (!result) {
                        const td = tr.querySelector('td[data-result], td.result, td:last-child');
                        if (td) result = td.textContent.trim();
                    }
                    if (!result) return;
                    const nums = (typeof parseSixNumbersFromString === 'function') ? parseSixNumbersFromString(result) : null;
                    if (!nums) return;

                    // Navigate to cell6_5 (click nav button if present)
                    const navBtn = document.querySelector('.nav-btn[data-target="cell6_5"]') || document.querySelector('#cell6_5_nav_btn');
                    if (navBtn) navBtn.click();

                    // After a short delay (allow renderer to run), force mode and fill inputs
                    setTimeout(() => {
                        // Try several selectors for the mode dropdown inside cell6_5
                        const modeSelect = document.querySelector('#cell6_5 .controls .mode-selector select')
                            || document.querySelector('#cell6_5 select')
                            || document.querySelector('#modeSelectorContainer select');
                        if (modeSelect) {
                            try { modeSelect.value = 'unpair'; } catch (e) { }
                            modeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                        }

                        // Fill the six unpair inputs if present (IDs are 1-indexed)
                        for (let i = 0; i < 6; i++) {
                            const input = document.getElementById(`cell6_5_unpair_input_${i + 1}`) || document.querySelector(`#cell6_5 input[name=unpair_${i}]`);
                            if (input) {
                                input.value = nums[i] ?? '';
                                input.dispatchEvent(new Event('input', { bubbles: true }));
                            }
                        }

                        // Also update place boxes if helper exists
                        if (typeof window.setPlaceValues === 'function') {
                            try { window.setPlaceValues(nums); } catch (e) { }
                        }

                        // After a short delay (allow group() to rerender), compute best rule,
                        // move dontmatch to trash, add candidate to fav, highlight num column green
                        setTimeout(() => {
                            // Reset hover state to prevent contamination from previous record's hover-trash
                            try { window.__hoverActive = false; window.__hoverPrevTrash = null; } catch (e) { }
                            try { if (typeof clearPopupHighlights === 'function') clearPopupHighlights(); } catch (e) { }
                            try {
                                if (typeof window.computeAndApplyUnpairBest === 'function') {
                                    window.computeAndApplyUnpairBest(nums);
                                }
                            } catch (e) { }
                            // Refresh visual highlights: num cell and label styles
                            try { if (typeof updateNumberCellHighlights === 'function') updateNumberCellHighlights(); } catch (e) { }
                            try { if (typeof updateLabelCellStyles === 'function') updateLabelCellStyles(); } catch (e) { }
                        }, 500);
                    }, 200);

                    ev.preventDefault();
                    ev.stopPropagation();
                } catch (e) { /* ignore errors */ }
            }, true);
        })();
    </script>
    <!-- Sync place boxes with Cell6.5 unpair inputs when entering/leaving Cell6.5 -->
    <script>
        (function () {
            function syncUnpairToPlace() {
                try {
                    const vals = [];
                    for (let i = 1; i <= 6; i++) {
                        const inp = document.getElementById('cell6_5_unpair_input_' + i);
                        vals.push(inp ? (inp.value || '').trim() : '');
                    }
                    if (typeof window.setPlaceValues === 'function') window.setPlaceValues(vals);
                } catch (e) { }
            }
            // When navigating to Cell6.5, sync after a short delay (unpair mode may be set async)
            document.addEventListener('sectionchange', (ev) => {
                try {
                    const id = ev && ev.detail && ev.detail.id;
                    if (id === 'cell6_5') {
                        // Immediate check
                        const controls = document.querySelector('#cell6_5 .controls.unpair-mode');
                        if (controls) { syncUnpairToPlace(); }
                        // Delayed check: Shift+click sets unpair mode ~200ms after sectionchange
                        setTimeout(() => {
                            try {
                                const c = document.querySelector('#cell6_5 .controls.unpair-mode');
                                if (c) syncUnpairToPlace();
                            } catch (e) { }
                        }, 350);
                    }
                } catch (e) { }
            });
            window.__syncUnpairToPlace = syncUnpairToPlace;
        })();
    </script>
    <script>
        (function () {
            try {
                let __originalTrash = null;      // global snapshot of trash before any hover
                let __hoverActiveTr = null;      // the <tr> currently being hovered
                let __tempHiddenFav = [];         // fav items temporarily hidden during trash hover
                let __tempHiddenTrash = [];       // trash items temporarily hidden during fav hover

                function _parseRowNumsFromTr(tr) {
                    try {
                        const raw = tr.getAttribute('data-result') || '';
                        const nums = raw.split(/\s*,\s*/).map(s => Number(s)).filter(Number.isFinite);
                        return nums.length === 6 ? nums : null;
                    } catch (e) { return null; }
                }

                function _getCurrentTrashSnapshot() {
                    try {
                        if (typeof window.getTrashItems === 'function') return (window.getTrashItems() || []).slice();
                        if (Array.isArray(window.__trashItems)) return (window.__trashItems || []).slice();
                        return [];
                    } catch (e) { return []; }
                }

                function _getCurrentFavSnapshot() {
                    try {
                        if (typeof window.getFavItems === 'function') return (window.getFavItems() || []).slice();
                        return [];
                    } catch (e) { return []; }
                }

                // Restore fav items that were temporarily hidden during hover
                function _restoreHiddenFav() {
                    if (!__tempHiddenFav || !__tempHiddenFav.length) return;
                    try {
                        window.__skipFavTrashExclusion = true;
                        for (const n of __tempHiddenFav) {
                            if (typeof window.addToFav === 'function') window.addToFav(n);
                        }
                        window.__skipFavTrashExclusion = false;
                    } catch (e) { window.__skipFavTrashExclusion = false; }
                    __tempHiddenFav = [];
                }

                // Hide fav items that overlap with current trash
                function _hideOverlappingFav() {
                    try {
                        const currentTrash = _getCurrentTrashSnapshot();
                        const currentFav = _getCurrentFavSnapshot();
                        const overlap = currentFav.filter(n => currentTrash.includes(n));
                        if (overlap.length) {
                            __tempHiddenFav = overlap;
                            for (const n of overlap) {
                                if (typeof window.removeFromFav === 'function') window.removeFromFav(n);
                            }
                        }
                    } catch (e) { }
                }

                // Restore trash items that were temporarily hidden during fav-only hover
                function _restoreHiddenTrash() {
                    if (!__tempHiddenTrash || !__tempHiddenTrash.length) return;
                    try {
                        window.__skipTrashFavExclusion = true;
                        for (const n of __tempHiddenTrash) {
                            try {
                                document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: [n] }, bubbles: true, composed: true }));
                            } catch (e) { }
                        }
                        window.__skipTrashFavExclusion = false;
                    } catch (e) { window.__skipTrashFavExclusion = false; }
                    __tempHiddenTrash = [];
                }

                // Hide trash items that overlap with fav candidate (for fav-only mode)
                function _hideTrashForFavCandidate(cand) {
                    try {
                        const currentTrash = _getCurrentTrashSnapshot();
                        const n = Number(cand);
                        if (currentTrash.includes(n)) {
                            __tempHiddenTrash.push(n);
                            // Remove from trash so fav yellow shows
                            try {
                                document.dispatchEvent(new CustomEvent('restoreMultipleFromTrash', { detail: { nums: [n] }, bubbles: true, composed: true }));
                            } catch (e) { }
                        }
                    } catch (e) { }
                }

                // Synchronously clear current trash and apply new set
                function _replaceTrash(numsToRemove, numsToAdd) {
                    if (numsToRemove && numsToRemove.length) {
                        try { document.dispatchEvent(new CustomEvent('restoreMultipleFromTrash', { detail: { nums: numsToRemove }, bubbles: true, composed: true })); } catch (e) { }
                    }
                    if (numsToAdd && numsToAdd.length) {
                        // Schedule after restores finish to avoid intermediate event conflicts
                        try { Promise.resolve().then(() => { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: numsToAdd }, bubbles: true, composed: true })); }); } catch (e) {
                            try { setTimeout(() => { document.dispatchEvent(new CustomEvent('moveMultipleToTrash', { detail: { nums: numsToAdd }, bubbles: true, composed: true })); }, 0); } catch (ee) { }
                        }
                    }
                }

                function _computeDontmatch(six, preferredCand) {
                    try {
                        const pairCounts = new Map();
                        (rows || []).forEach(r => {
                            try {
                                const nums = Array.isArray(r.nums) ? r.nums.slice().sort((a, b) => a - b) : [];
                                for (let i = 0; i < nums.length; i++) for (let j = i + 1; j < nums.length; j++) {
                                    const a = nums[i], b = nums[j];
                                    const key = `${a}-${b}`;
                                    pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
                                }
                            } catch (e) { }
                        });

                        const userNums = (six || []).map(n => Number(n)).filter(n => Number.isFinite(n));
                        if (userNums.length !== 6) return null;

                        // If a preferred candidate is provided and is among the six, only try that one
                        const candsToTry = (preferredCand != null && Number.isFinite(Number(preferredCand)) && userNums.includes(Number(preferredCand)))
                            ? [Number(preferredCand)]
                            : userNums;

                        let found = null;
                        for (let n = 44; n >= 1; n--) {
                            for (const cand of candsToTry) {
                                const others = [];
                                for (let y = 1; y <= 45; y++) {
                                    if (y === cand) continue;
                                    const a = Math.min(cand, y), b = Math.max(cand, y);
                                    const key = `${a}-${b}`;
                                    const c = pairCounts.get(key) || 0;
                                    others.push({ y, c });
                                }
                                others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                                const pick = others.slice(0, n).map(o => o.y);
                                const otherFive = userNums.filter(x => x !== cand);
                                const conflict = pick.some(v => otherFive.indexOf(v) !== -1);
                                if (!conflict) { found = { n, cand, pick }; break; }
                            }
                            if (found) break;
                        }
                        if (!found) {
                            const cand = candsToTry[0];
                            const others = [];
                            for (let y = 1; y <= 45; y++) { if (y === cand) continue; const a = Math.min(cand, y), b = Math.max(cand, y); const key = `${a}-${b}`; const c = pairCounts.get(key) || 0; others.push({ y, c }); }
                            others.sort((A, B) => (A.c - B.c) || (A.y - B.y));
                            found = { n: 1, cand, pick: others.slice(0, 1).map(o => o.y) };
                        }
                        if (found && Array.isArray(found.pick) && found.pick.length) {
                            return { cand: Number(found.cand), dontmatch: Array.from(new Set(found.pick.map(n => Number(n)).filter(Number.isFinite))) };
                        }
                    } catch (e) { }
                    return null;
                }

                document.addEventListener('mouseover', (ev) => {
                    try {
                        const target = ev.target || ev.srcElement;
                        const tr = target && target.closest ? target.closest('#cell5_5 table tbody tr, #cell6_5 table tbody tr, #cell6_6 table tbody tr, #cell7 table tbody tr, #cell8 table tbody tr, #cell9 table tbody tr, #cell11 table tbody tr') : null;
                        if (!tr) return;
                        // Skip Cell6.5 unpair mode — it has its own dedicated hover handlers
                        try { const c65 = tr.closest('#cell6_5'); if (c65 && c65.querySelector('.controls.unpair-mode')) return; } catch (e) { }
                        // Read both toggle modes
                        let __trashMode = 'normal', __favMode = 'normal';
                        try { __trashMode = (typeof window.getTrashToggleMode === 'function') ? window.getTrashToggleMode() : 'normal'; } catch (e) { }
                        try { __favMode = (typeof window.getFavToggleMode === 'function') ? window.getFavToggleMode() : 'normal'; } catch (e) { }
                        // Skip if both toggles are normal — nothing to do
                        if (__trashMode === 'normal' && __favMode === 'normal') return;
                        if (__hoverActiveTr === tr) return; // same row, skip

                        const six = _parseRowNumsFromTr(tr);
                        if (!six) return;

                        // First time entering hover mode → save the ORIGINAL trash
                        if (__originalTrash === null) {
                            __originalTrash = _getCurrentTrashSnapshot();
                        }

                        __hoverActiveTr = tr;

                        // Try to parse the displayed candidate from the row text (e.g., "16>{...}[10]")
                        // This ensures the hover highlights the same candidate that the section displays.
                        let __displayedCand = null;
                        try {
                            const tds = tr.querySelectorAll('td');
                            for (const td of tds) {
                                const txt = (td.textContent || '').trim();
                                const m = txt.match(/(\d+)\s*>\s*\{/);
                                if (m) { const v = Number(m[1]); if (Number.isFinite(v) && v >= 1 && v <= 45) { __displayedCand = v; break; } }
                            }
                        } catch (e) { }

                        // Compute dontmatch for this row (prefer displayed candidate if found)
                        const __result = _computeDontmatch(six, __displayedCand);
                        const uniq = __result ? __result.dontmatch : null;

                        // === TRASH MODE: apply dontmatch to trash ===
                        if (__trashMode === 'trash') {
                            // Enable flag so moveToTrash skips fav exclusivity during temp hover
                            window.__skipTrashFavExclusion = true;
                            // Restore any previously hidden fav items before changing trash
                            _restoreHiddenFav();

                            if (uniq && uniq.length) {
                                // Clear current trash and apply new dontmatch
                                const cur = _getCurrentTrashSnapshot();
                                _replaceTrash(cur, uniq);
                                try { window.__cell6_5_lastDontmatch = new Set(uniq); } catch (e) { }
                                // After trash is applied (double microtask), hide fav items that overlap with new trash
                                try { Promise.resolve().then(() => Promise.resolve().then(() => { _hideOverlappingFav(); })); } catch (e) { }
                            }
                        }

                        // === FAV MODE: add candidate to fav ===
                        if (__favMode === 'fav' && __result && __result.cand != null && typeof window.addToFav === 'function') {
                            const __prevRuleFav = window.__ruleModeHoverFavCand || null;
                            if (__prevRuleFav != null && __prevRuleFav !== __result.cand && typeof window.removeFromFav === 'function') window.removeFromFav(__prevRuleFav);
                            // In fav-only mode (trash=normal): temporarily hide trash for candidate so yellow shows
                            if (__trashMode === 'normal') {
                                _restoreHiddenTrash(); // restore any previously hidden trash
                                _hideTrashForFavCandidate(__result.cand);
                            }
                            window.addToFav(__result.cand);
                            window.__ruleModeHoverFavCand = __result.cand;
                        }
                    } catch (e) { }
                }, true);

                document.addEventListener('mouseout', (ev) => {
                    try {
                        const target = ev.target || ev.srcElement;
                        const tr = target && target.closest ? target.closest('#cell5_5 table tbody tr, #cell6_5 table tbody tr, #cell6_6 table tbody tr, #cell7 table tbody tr, #cell8 table tbody tr, #cell9 table tbody tr, #cell11 table tbody tr') : null;
                        if (!tr) return;
                        // Skip Cell6.5 unpair mode — it has its own dedicated hover handlers
                        try { const c65 = tr.closest('#cell6_5'); if (c65 && c65.querySelector('.controls.unpair-mode')) return; } catch (e) { }
                        // Read both toggle modes
                        let __trashModeOut = 'normal', __favModeOut = 'normal';
                        try { __trashModeOut = (typeof window.getTrashToggleMode === 'function') ? window.getTrashToggleMode() : 'normal'; } catch (e) { }
                        try { __favModeOut = (typeof window.getFavToggleMode === 'function') ? window.getFavToggleMode() : 'normal'; } catch (e) { }
                        // Skip if both toggles are normal
                        if (__trashModeOut === 'normal' && __favModeOut === 'normal') return;
                        if (tr.contains && ev.relatedTarget && tr.contains(ev.relatedTarget)) return;

                        // Check if moving to another tracked row → DON'T restore yet
                        const nextTr = ev.relatedTarget && ev.relatedTarget.closest ? ev.relatedTarget.closest('#cell5_5 table tbody tr, #cell6_5 table tbody tr, #cell6_6 table tbody tr, #cell7 table tbody tr, #cell8 table tbody tr, #cell9 table tbody tr, #cell11 table tbody tr') : null;
                        if (nextTr && nextTr !== tr) {
                            // Moving to another row — mouseover on nextTr will handle it
                            return;
                        }

                        // === TRASH MODE RESTORE ===
                        if (__trashModeOut === 'trash') {
                            // Leaving ALL rows → restore original trash
                            const cur = _getCurrentTrashSnapshot();
                            const saved = __originalTrash || [];
                            _replaceTrash(cur, saved);

                            // After trash is fully restored (double microtask), restore hidden fav and clear flags
                            try {
                                Promise.resolve().then(() => Promise.resolve().then(() => {
                                    _restoreHiddenFav();
                                    window.__skipTrashFavExclusion = false;
                                    if (typeof syncFavHighlights === 'function') syncFavHighlights();
                                }));
                            } catch (e) { window.__skipTrashFavExclusion = false; }
                        }

                        // === FAV MODE RESTORE ===
                        if (__favModeOut === 'fav') {
                            const __rf = window.__ruleModeHoverFavCand;
                            if (__rf != null && typeof window.removeFromFav === 'function') {
                                window.removeFromFav(__rf);
                                window.__ruleModeHoverFavCand = null;
                            }
                            // In fav-only mode: restore trash items hidden by fav candidate
                            if (__trashModeOut === 'normal') {
                                try {
                                    Promise.resolve().then(() => {
                                        _restoreHiddenTrash();
                                        if (typeof syncFavHighlights === 'function') syncFavHighlights();
                                    });
                                } catch (e) { }
                            }
                        }

                        // Reset global state
                        __originalTrash = null;
                        __hoverActiveTr = null;
                    } catch (e) { }
                }, true);
            } catch (e) { }
        })();
    </script>
    <script>
        (function () {
            const draftPopup = document.getElementById('draftPopup');
            const draftTableBody = document.querySelector('#draftTable tbody');
            const numberPicker = document.getElementById('numberPickerPopup');

            // ── helpers ──
            function isPickerVisible() {
                try {
                    if (!numberPicker) return false;
                    const s = window.getComputedStyle(numberPicker);
                    return s.display !== 'none' && numberPicker.offsetWidth > 0 && numberPicker.getBoundingClientRect().width > 0;
                } catch (e) { return false; }
            }

            function validateLine(s) {
                const parts = s.split(',').map(x => x.trim());
                if (parts.length !== 6) return null;
                const result = parts.map(p => {
                    if (p === '' || p === '__') return null;
                    const n = parseInt(p, 10);
                    if (!Number.isFinite(n) || n < 1 || n > 45) return null;
                    return n;
                });
                const filled = result.filter(v => v !== null);
                if (new Set(filled).size !== filled.length) return null;
                return result;
            }

            function recordKey(nums) {
                return nums.map(n => n === null ? '__' : String(n)).join(',');
            }

            function getExistingKeys() {
                const keys = new Set();
                try {
                    const rows = Array.from(document.querySelectorAll('#draftTable tbody tr:not(.draft-add-row-tr)'));
                    for (const r of rows) {
                        const pills = Array.from(r.querySelectorAll('.pill'));
                        if (pills.length === 6) {
                            const key = pills.map(sp => {
                                const t = (sp.textContent || '').trim();
                                return (t === '' || t === '__') ? '__' : t;
                            }).join(',');
                            keys.add(key);
                        }
                    }
                } catch (e) { }
                return keys;
            }

            function parseClipboardText(text) {
                if (!text) return [];
                const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                const records = [];
                const seen = getExistingKeys();
                for (const line of lines) {
                    const res = validateLine(line);
                    if (res) {
                        const key = recordKey(res);
                        if (!seen.has(key)) { seen.add(key); records.push(res); }
                    }
                }
                return records;
            }

            // ── Row drag state (mouse-based) ──
            let dragState = null;

            function createPlaceholder(h) {
                const ph = document.createElement('tr');
                ph.className = 'draft-row-placeholder';
                const td = document.createElement('td');
                td.colSpan = 1;
                td.style.height = h + 'px';
                ph.appendChild(td);
                return ph;
            }

            function onGrabberMouseDown(ev, tr) {
                ev.preventDefault();
                ev.stopPropagation();
                const rect = tr.getBoundingClientRect();

                // Create a proper visible clone: wrap cloned <tr> in a <table>
                const clonedTr = tr.cloneNode(true);
                const wrapTable = document.createElement('table');
                wrapTable.style.cssText = 'border-collapse:collapse;width:' + rect.width + 'px;margin:0;padding:0;';
                const wrapBody = document.createElement('tbody');
                wrapBody.appendChild(clonedTr);
                wrapTable.appendChild(wrapBody);

                const wrapper = document.createElement('div');
                wrapper.className = 'draft-dragging-clone';
                wrapper.style.left = rect.left + 'px';
                wrapper.style.top = rect.top + 'px';
                wrapper.style.width = rect.width + 'px';
                const cs = getComputedStyle(draftPopup);
                wrapper.style.background = cs.backgroundColor || 'var(--card)';
                wrapper.style.color = cs.color || 'var(--text)';
                wrapper.style.padding = '2px 0';
                wrapper.style.borderRadius = '6px';
                wrapper.appendChild(wrapTable);
                document.body.appendChild(wrapper);

                const ph = createPlaceholder(rect.height);
                tr.classList.add('draft-row-dragging');

                dragState = {
                    srcRow: tr,
                    clone: wrapper,
                    placeholder: ph,
                    offsetX: ev.clientX - rect.left,
                    offsetY: ev.clientY - rect.top
                };

                tr.parentNode.insertBefore(ph, tr);
                tr.style.display = 'none';

                // Block hover effects on picker/place during row drag
                document.body.classList.add('draft-row-dragging-active');
            }

            function onMouseMove(ev) {
                if (!dragState) return;
                ev.preventDefault();
                const { clone, placeholder, srcRow } = dragState;
                clone.style.left = (ev.clientX - dragState.offsetX) + 'px';
                clone.style.top = (ev.clientY - dragState.offsetY) + 'px';

                const elUnderneath = document.elementFromPoint(ev.clientX, ev.clientY);
                if (!elUnderneath) return;
                const targetRow = elUnderneath.closest ? elUnderneath.closest('#draftTable tbody tr:not(.draft-add-row-tr)') : null;
                if (!targetRow || targetRow === placeholder || targetRow === srcRow) return;

                const targetRect = targetRow.getBoundingClientRect();
                const before = (ev.clientY < targetRect.top + targetRect.height / 2);
                if (before) {
                    targetRow.parentNode.insertBefore(placeholder, targetRow);
                } else {
                    targetRow.parentNode.insertBefore(placeholder, targetRow.nextSibling);
                }
            }

            function onMouseUp(ev) {
                if (!dragState) return;
                const { srcRow, clone, placeholder } = dragState;

                // Check if dropped outside draftPopup → delete the record
                const draftRect = draftPopup.getBoundingClientRect();
                const outside = ev.clientX < draftRect.left || ev.clientX > draftRect.right
                    || ev.clientY < draftRect.top || ev.clientY > draftRect.bottom;

                if (outside) {
                    // Remove the row entirely
                    if (placeholder.parentNode) placeholder.remove();
                    srcRow.remove();
                } else {
                    // Insert row at placeholder position
                    if (placeholder.parentNode) {
                        placeholder.parentNode.insertBefore(srcRow, placeholder);
                        placeholder.remove();
                    }
                    srcRow.style.display = '';
                    srcRow.classList.remove('draft-row-dragging');
                }

                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                dragState = null;
                document.body.classList.remove('draft-row-dragging-active');

                updateScrollClass();
                try { if (typeof window.__scanDraftPills === 'function') window.__scanDraftPills(); } catch (e) { }
                try { draftPopup.dispatchEvent(new CustomEvent('draftreordered', { bubbles: true })); } catch (e) { }
            }

            document.addEventListener('mousemove', onMouseMove, true);
            document.addEventListener('mouseup', onMouseUp, true);

            // ── Helper: create a single record row ──
            function createRecordRow(nums, idx) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.classList.add('has-grabber');
                const row = document.createElement('div');
                row.className = 'record-row';
                const pills = document.createElement('div');
                pills.className = 'pills';
                pills.style.flex = '1';
                nums.forEach(n => {
                    const sp = document.createElement('span');
                    sp.className = 'pill';
                    if (n === null || n === undefined) {
                        sp.textContent = '__';
                        sp.classList.add('pill-empty');
                    } else {
                        sp.textContent = String(n);
                    }
                    pills.appendChild(sp);
                });
                const grabber = document.createElement('div');
                grabber.className = 'grabber';
                grabber.setAttribute('title', 'Kéo để sắp xếp lại');
                grabber.textContent = '☰';
                grabber.addEventListener('mousedown', (ev) => { onGrabberMouseDown(ev, tr); });

                row.appendChild(pills);
                row.appendChild(grabber);
                td.appendChild(row);
                tr.appendChild(td);
                tr.dataset.index = idx;
                return tr;
            }

            // ── Create "+" add row ──
            function ensureAddRow() {
                const existing = draftTableBody.querySelector('tr.draft-add-row-tr');
                if (existing) existing.remove();

                const tr = document.createElement('tr');
                tr.className = 'draft-add-row-tr';
                const td = document.createElement('td');
                const btn = document.createElement('button');
                btn.className = 'draft-add-row';
                btn.textContent = '+';
                btn.title = 'Thêm hàng rỗng';
                btn.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const emptyNums = [null, null, null, null, null, null];
                    const idx = draftTableBody.querySelectorAll('tr:not(.draft-add-row-tr)').length;
                    const newRow = createRecordRow(emptyNums, idx);
                    draftTableBody.insertBefore(newRow, tr);
                    try { if (typeof window.__scanDraftPills === 'function') window.__scanDraftPills(); } catch (e) { }
                    updateScrollClass();
                });
                td.appendChild(btn);
                tr.appendChild(td);
                draftTableBody.appendChild(tr);
            }

            function updateScrollClass() {
                try {
                    const cnt = draftTableBody.querySelectorAll('tr:not(.draft-add-row-tr)').length;
                    if (draftPopup) draftPopup.classList.toggle('has-scroll', cnt >= 10);
                } catch (e) { }
            }

            // ── Render draft records ──
            function renderDraft(records) {
                draftTableBody.innerHTML = '';
                records.forEach((nums, idx) => {
                    const tr = createRecordRow(nums, idx);
                    draftTableBody.appendChild(tr);
                });
                ensureAddRow();
                updateScrollClass();
            }

            // ── Hover: highlight numbers in popup (skip during row drag) ──
            try {
                if (draftTableBody) {
                    draftTableBody.addEventListener('mouseover', (ev) => {
                        try {
                            if (dragState) return; // don't highlight during row drag
                            const tr = ev.target && ev.target.closest ? ev.target.closest('tr') : null;
                            if (!tr || tr.classList.contains('draft-add-row-tr')) return;
                            const pillEls = Array.from(tr.querySelectorAll('.pill'));
                            if (!pillEls.length) return;
                            const nums = pillEls.map(sp => {
                                const t = (sp.textContent || '').trim();
                                if (t === '__' || t === '') return null;
                                const n = parseInt(t, 10);
                                return Number.isFinite(n) ? n : null;
                            }).filter(n => n !== null);
                            if (nums.length > 0 && typeof applyPopupHighlights === 'function') applyPopupHighlights(nums);
                        } catch (e) { }
                    }, true);

                    draftTableBody.addEventListener('mouseout', (ev) => {
                        try {
                            if (dragState) return;
                            const related = ev.relatedTarget;
                            if (related && draftPopup && draftPopup.contains(related)) return;
                            if (typeof clearPopupHighlights === 'function') clearPopupHighlights();
                        } catch (e) { }
                    }, true);
                }
            } catch (e) { }

            // ── Show / Hide ──
            function showDraft(atRecords) {
                if (!isPickerVisible()) return;
                if (atRecords) {
                    renderDraft(atRecords);
                } else if (!draftTableBody.querySelector('tr:not(.draft-add-row-tr)')) {
                    // No rows yet — try to load from localStorage
                    try {
                        const saved = localStorage.getItem('draftRecords');
                        if (saved && saved.trim()) {
                            const recs = saved.trim().split('\n').map(line => {
                                const parts = line.split(',');
                                if (parts.length !== 6) return null;
                                return parts.map(p => {
                                    const t = p.trim();
                                    if (t === '' || t === '__') return null;
                                    const n = parseInt(t, 10);
                                    return Number.isFinite(n) && n >= 1 && n <= 45 ? n : null;
                                });
                            }).filter(Boolean);
                            if (recs.length) renderDraft(recs);
                        }
                    } catch (e) { }
                }
                if (!draftTableBody.querySelector('tr.draft-add-row-tr')) ensureAddRow();
                draftPopup.style.display = 'block';
                draftPopup.style.visibility = 'hidden';
                draftPopup.style.left = '';
                draftPopup.style.right = '';

                const dpWidth = draftPopup.offsetWidth || 320;
                let placed = false;

                if (numberPicker) {
                    try {
                        if (isPickerVisible()) {
                            const rect = numberPicker.getBoundingClientRect();
                            let left = rect.right + 8;
                            if (left + dpWidth > window.innerWidth - 12) {
                                left = rect.left - 8 - dpWidth;
                            }
                            left = Math.max(8, Math.min(left, window.innerWidth - dpWidth - 12));
                            draftPopup.style.left = left + 'px';
                            draftPopup.style.top = Math.max(8, rect.top) + 'px';
                            placed = true;
                        }
                    } catch (e) { }
                }

                if (!placed) {
                    draftPopup.style.display = 'none';
                    return;
                }

                draftPopup.style.visibility = 'visible';
                draftPopup.setAttribute('aria-hidden', 'false');
                // Apply current popup scale to draft popup
                try {
                    const s = window.__popupScaleState ? window.__popupScaleState.scale : 1;
                    if (s !== 1) {
                        draftPopup.style.transform = `scale(${s})`;
                        draftPopup.style.transformOrigin = 'top left';
                    }
                } catch (e) { }
                try { window.__prevDraftVisible = true; } catch (e) { }
            }

            function hideDraft(skipRemember) {
                // Save current records to localStorage before hiding
                try {
                    const rows = Array.from(draftTableBody.querySelectorAll('tr:not(.draft-add-row-tr)'));
                    const lines = [];
                    for (const r of rows) {
                        const pills = Array.from(r.querySelectorAll('.pill'));
                        if (pills.length === 6) {
                            const vals = pills.map(sp => {
                                const t = (sp.textContent || '').trim();
                                return (t === '' || t === '__') ? '' : t;
                            });
                            // Only save rows that have at least one value
                            if (vals.some(v => v !== '')) {
                                lines.push(vals.join(','));
                            }
                        }
                    }
                    localStorage.setItem('draftRecords', lines.join('\n'));
                } catch (e) { }
                draftPopup.style.display = 'none';
                draftPopup.setAttribute('aria-hidden', 'true');
                try { if (!skipRemember) window.__prevDraftVisible = false; } catch (e) { }
            }

            try { window.__showDraft = showDraft; } catch (e) { }
            try { window.__hideDraft = hideDraft; } catch (e) { }

            // Toggle with key 'a' — only when picker is open
            document.addEventListener('keydown', (e) => {
                const active = document.activeElement;
                const tag = active && active.tagName ? active.tagName.toLowerCase() : '';
                if (tag === 'input' || tag === 'textarea' || (active && active.isContentEditable)) return;
                if (e.key === 'a' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    if (!isPickerVisible()) return;
                    if (draftPopup.style.display === 'block') {
                        // Copy all draft records to clipboard before closing
                        try {
                            const rows = Array.from(draftTableBody.querySelectorAll('tr:not(.draft-add-row-tr)'));
                            const csvLines = [];
                            for (const r of rows) {
                                const pills = Array.from(r.querySelectorAll('.pill'));
                                if (pills.length === 6) {
                                    const vals = pills.map(sp => {
                                        const t = (sp.textContent || '').trim();
                                        return (t === '' || t === '__') ? '' : t;
                                    });
                                    if (vals.some(v => v !== '')) {
                                        csvLines.push(vals.join(','));
                                    }
                                }
                            }
                            if (csvLines.length) {
                                navigator.clipboard.writeText(csvLines.join('\n')).catch(() => { });
                            }
                        } catch (ex) { }
                        hideDraft();
                    } else {
                        showDraft();
                    }
                }
            });

            // dblclick to read clipboard and append (skip if dblclick originated inside draft table)
            document.addEventListener('dblclick', async (ev) => {
                try {
                    // Skip if double-click is on a draft record row (handled separately for copy)
                    if (ev.target && ev.target.closest && ev.target.closest('#draftTable tr:not(.draft-add-row-tr)')) return;
                    if (!isPickerVisible()) return;
                    const text = await (navigator.clipboard && navigator.clipboard.readText ? navigator.clipboard.readText() : Promise.resolve(''));
                    const recs = parseClipboardText(text);
                    if (recs.length) {
                        const addRowEl = draftTableBody.querySelector('tr.draft-add-row-tr');
                        const existingCount = draftTableBody.querySelectorAll('tr:not(.draft-add-row-tr)').length;
                        recs.forEach((nums, i) => {
                            const tr = createRecordRow(nums, existingCount + i);
                            if (addRowEl) draftTableBody.insertBefore(tr, addRowEl);
                            else draftTableBody.appendChild(tr);
                        });
                        ensureAddRow();
                        updateScrollClass();
                        try { if (typeof window.__scanDraftPills === 'function') window.__scanDraftPills(); } catch (e) { }
                        if (draftPopup.style.display !== 'block') showDraft();
                    }
                } catch (e) { }
            }, true);

            // Clear button
            const clearBtn = document.getElementById('draftClearBtn');
            if (clearBtn) clearBtn.addEventListener('click', () => { renderDraft([]); });

            // ── Scale handle for draftPopup (bottom-right corner) ──
            (function addDraftScaleHandle() {
                const handle = draftPopup.querySelector('.draft-scale-handle');
                if (!handle) return;
                let isScalingD = false;
                let startX_D = 0;
                let startScale_D = 1;

                handle.addEventListener('mousedown', (e) => {
                    // Read current scale from popupScaleState if available
                    try { startScale_D = window.__popupScaleState ? window.__popupScaleState.scale : parseFloat((draftPopup.style.transform || '').replace(/[^0-9.]/g, '') || '1'); } catch (err) { startScale_D = 1; }
                    isScalingD = true;
                    startX_D = e.clientX;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isScalingD) return;
                    const diff = e.clientX - startX_D;
                    const newScale = Math.max(0.5, Math.min(2, startScale_D + diff * 0.0025));
                    const rounded = parseFloat(newScale.toFixed(3));
                    // Update global scale state and apply to all popups
                    try {
                        if (window.__popupScaleState) {
                            window.__popupScaleState.scale = rounded;
                        }
                        if (typeof window.__applyPopupScale === 'function') {
                            window.__applyPopupScale();
                        } else {
                            // Fallback: scale only draftPopup
                            draftPopup.style.transform = `scale(${rounded})`;
                            draftPopup.style.transformOrigin = 'top left';
                        }
                        if (typeof adjustTrashPosition === 'function') adjustTrashPosition();
                    } catch (err) { }
                });

                document.addEventListener('mouseup', () => {
                    if (isScalingD) {
                        isScalingD = false;
                        try { if (typeof window.__savePopupScale === 'function') window.__savePopupScale(); } catch (e) { }
                    }
                });
            })();

            // ── Double-click on draft row to copy as CSV ──
            if (draftTableBody) {
                draftTableBody.addEventListener('dblclick', (ev) => {
                    const tr = ev.target && ev.target.closest ? ev.target.closest('tr:not(.draft-add-row-tr)') : null;
                    if (!tr) return;
                    ev.stopPropagation();
                    ev.preventDefault();
                    const pills = Array.from(tr.querySelectorAll('.pill'));
                    if (pills.length !== 6) return;
                    const vals = pills.map(sp => {
                        const t = (sp.textContent || '').trim();
                        return (t === '' || t === '__') ? '' : t;
                    });
                    const csv = vals.join(',');
                    try {
                        navigator.clipboard.writeText(csv).then(() => {
                            // Flash green border
                            tr.classList.add('draft-row-copied');
                            setTimeout(() => tr.classList.remove('draft-row-copied'), 600);
                        }).catch(() => { });
                    } catch (e) { }
                }, true);
            }

            // NO click-outside-close: draft only closes via 'a' key or when picker hides
        })();
    </script>
</body>

</html>